name: HumanEval_118_get_closest_vowel
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && i < word.length - 1)\n            {\n                if(vowels.canFind(word[i\
    \ - 1]) == false && vowels.canFind(word[i + 1]) == false)\n                {\n\
    \                    if(abs(i - word.length) < min_distance)\n               \
    \     {\n                        min_distance = abs(i - word.length);\n      \
    \                  index = i;\n                    }\n                }\n    \
    \        }\n        }\n    }\n    if(index != 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc5vs984m.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpc5vs984m.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpc5vs984m.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpc5vs984m.d(35): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmpc5vs984m.d(39): Error: cannot implicitly convert expression\
    \ `abs(i - word.length)` of type `ulong` to `int`\\n/tmp/tmpc5vs984m.d(40): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpc5vs984m.d(48):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc5vs984m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    int distance = 0;\n\
    \    int index = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            distance = word.length - i - 1;\n           \
    \ if(distance < min_distance)\n            {\n                min_distance = distance;\n\
    \                result = c;\n                index = i;\n            }\n    \
    \    }\n    }\n    if(index == 0)\n        return \"\";\n    if(consonants.find(word[index\
    \ - 1]) == -1)\n        return \"\";\n    if(consonants.find(word[index + 1])\
    \ == -1)\n        return \"\";\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwb9riypu.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpwb9riypu.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwb9riypu.d(35): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmpwb9riypu.d(39):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\n/tmp/tmpwb9riypu.d(40): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmpwb9riypu.d(46): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwb9riypu.d(48): Error: no property `find` for type\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwb9riypu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int distance = -1;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(i\
    \ > 0 && i < word.length - 1)\n            {\n                if(vowels.find(word[i-1])\
    \ == -1 && vowels.find(word[i+1]) == -1)\n                {\n                \
    \    if(distance == -1 || distance > abs(i - word.length))\n                 \
    \   {\n                        distance = abs(i - word.length);\n            \
    \            index = i;\n                    }\n                }\n          \
    \  }\n        }\n    }\n    if(index != -1)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9d_b6gfx.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmp9d_b6gfx.d(35): Error: no property `find` for type `string`\\n/tmp/tmp9d_b6gfx.d(35):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp9d_b6gfx.d(39): Error:\
    \ cannot implicitly convert expression `abs(i - word.length)` of type `ulong`\
    \ to `int`\\n/tmp/tmp9d_b6gfx.d(40): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp9d_b6gfx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            int distance = word.length - i;\n           \
    \ if (distance < min_distance)\n            {\n                min_distance =\
    \ distance;\n                index = i;\n            }\n        }\n    }\n   \
    \ if (index != 0)\n    {\n        result = word[index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp88hmvdry.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp88hmvdry.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp88hmvdry.d(33): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp88hmvdry.d(43):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp88hmvdry.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ v; word)\n    {\n        if(vowels.canFind(v))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = v;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzo2yb23_.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpzo2yb23_.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpzo2yb23_.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpzo2yb23_.d(36):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzo2yb23_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, v; word)\n    {\n        if(vowels.find(v) != -1)\n        {\n \
    \           int distance = 0;\n            int j = i;\n            while(j >=\
    \ 0)\n            {\n                if(consonants.find(word[j]) != -1)\n    \
    \            {\n                    distance = i - j;\n                    break;\n\
    \                }\n                j--;\n            }\n            if(distance\
    \ > 0)\n            {\n                j = i;\n                while(j < word.length)\n\
    \                {\n                    if(consonants.find(word[j]) != -1)\n \
    \                   {\n                        distance += j - i;\n          \
    \              break;\n                    }\n                    j++;\n     \
    \           }\n            }\n            if(distance > 0 && distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = v;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp83p7v35n.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp83p7v35n.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp83p7v35n.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp83p7v35n.d(38): Error: no\
    \ property `find` for type `string`\\n/tmp/tmp83p7v35n.d(40): Error: cannot implicitly\
    \ convert expression `i - cast(ulong)j` of type `ulong` to `int`\\n/tmp/tmp83p7v35n.d(47):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp83p7v35n.d(50):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp83p7v35n.d(61): Error:\
    \ cannot implicitly convert expression `v` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp83p7v35n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest = \"\";\n    int dist = 0;\n    int min_dist = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          dist = word.length - i;\n            if(dist < min_dist)\n        \
    \    {\n                min_dist = dist;\n                closest = c;\n     \
    \       }\n        }\n    }\n    return closest;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbmue5axw.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpbmue5axw.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpbmue5axw.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpbmue5axw.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbmue5axw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(c in vowels)\n        {\n        \
    \    int j = i;\n            while(j < word.length && word[j] in vowels)\n   \
    \             j++;\n            if(j < word.length)\n            {\n         \
    \       distance = j - i;\n                if(distance < min_distance)\n     \
    \           {\n                    min_distance = distance;\n                \
    \    result = word[i..j];\n                }\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkitbm5yk.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkitbm5yk.d(31): Error: incompatible types\
    \ for `(c) in (vowels)`: `immutable(char)` and `string`\\n/tmp/tmpkitbm5yk.d(33):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpkitbm5yk.d(34):\
    \ Error: incompatible types for `(word[cast(ulong)j]) in (vowels)`: `immutable(char)`\
    \ and `string`\\n/tmp/tmpkitbm5yk.d(38): Error: cannot implicitly convert expression\
    \ `cast(ulong)j - i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkitbm5yk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = int.max;\n    int distance = 0;\n   \
    \ int index = 0;\n    int word_length = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            distance = word_length\
    \ - i - 1;\n            if(distance < min_distance)\n            {\n         \
    \       min_distance = distance;\n                index = i;\n            }\n\
    \        }\n    }\n    if(min_distance != int.max)\n    {\n        result = word[index..index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplja0qy7z.d(31): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplja0qy7z.d(34): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmplja0qy7z.d(36): Error: cannot implicitly convert\
    \ expression `cast(ulong)word_length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmplja0qy7z.d(40):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplja0qy7z.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_consonant_index\
    \ = -1;\n    int word_length = word.length;\n    for (int i = 0; i < word_length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  if (closest_consonant_index != -1)\n            {\n                if (closest_vowel_index\
    \ == -1)\n                {\n                    closest_vowel_index = i;\n  \
    \                  closest_vowel = word[i];\n                }\n             \
    \   else if (i - closest_consonant_index < closest_vowel_index - closest_consonant_index)\n\
    \                {\n                    closest_vowel_index = i;\n           \
    \         closest_vowel = word[i];\n                }\n            }\n       \
    \ }\n        else if (consonants.find(word[i]) != -1)\n        {\n           \
    \ closest_consonant_index = i;\n        }\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi7b7cz95.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpi7b7cz95.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpi7b7cz95.d(40): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\\n/tmp/tmpi7b7cz95.d(45):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\n/tmp/tmpi7b7cz95.d(49): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi7b7cz95.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(consonants.find(c) != -1)\n        {\n            foreach(j,\
    \ v; vowels)\n            {\n                if(word.find(v, i) != -1)\n     \
    \           {\n                    if(word.find(v, i) - i < min_distance)\n  \
    \                  {\n                        min_distance = word.find(v, i) -\
    \ i;\n                        result = v;\n                    }\n           \
    \     }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppcfrhtsc.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmppcfrhtsc.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmppcfrhtsc.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmppcfrhtsc.d(37): Error: no property `find` for type `string`\\\
    n/tmp/tmppcfrhtsc.d(39): Error: no property `find` for type `string`\\n/tmp/tmppcfrhtsc.d(40):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppcfrhtsc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwl6iiyz4.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpwl6iiyz4.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpwl6iiyz4.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwl6iiyz4.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwl6iiyz4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i != 0 && i != word.length - 1)\n                {\n     \
    \               if(consonants.find(word[i - 1]) != -1 && consonants.find(word[i\
    \ + 1]) != -1)\n                    {\n                        min_distance =\
    \ distance;\n                        result = c;\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4_ds5m10.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4_ds5m10.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp4_ds5m10.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp4_ds5m10.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp4_ds5m10.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp4_ds5m10.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4_ds5m10.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    if (min_distance > abs(i\
    \ - word.length))\n                    {\n                        min_distance\
    \ = abs(i - word.length);\n                        index = i;\n              \
    \      }\n                }\n            }\n        }\n    }\n    if (index !=\
    \ -1)\n    {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpergbd3kb.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpergbd3kb.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpergbd3kb.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpergbd3kb.d(35): Error: no property `find` for type `string`\\\
    n/tmp/tmpergbd3kb.d(39): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmpergbd3kb.d(48): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpergbd3kb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int pos = word.length - 1;\n    while (pos > 0)\n\
    \    {\n        if (vowels.find(word[pos]) != -1)\n        {\n            if (vowels.find(word[pos\
    \ - 1]) == -1)\n            {\n                result = word[pos];\n         \
    \       break;\n            }\n        }\n        pos--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz4m7pgf1.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpz4m7pgf1.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpz4m7pgf1.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpz4m7pgf1.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)pos]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz4m7pgf1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw5qik6ne.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpw5qik6ne.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpw5qik6ne.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpw5qik6ne.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw5qik6ne.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = -1;\n    int min = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n            {\n                if(abs(i\
    \ - word.length/2) < min)\n                {\n                    min = abs(i\
    \ - word.length/2);\n                    index = i;\n                }\n     \
    \       }\n        }\n    }\n    if(index != -1)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5eh1sw_e.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5eh1sw_e.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5eh1sw_e.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp5eh1sw_e.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmp5eh1sw_e.d(38): Error: cannot implicitly convert expression `abs(i -\
    \ word.length / 2LU)` of type `ulong` to `int`\\n/tmp/tmp5eh1sw_e.d(39): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5eh1sw_e.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1]) == -1)\n\
    \                {\n                    if (min_distance > abs(i - word.length))\n\
    \                    {\n                        min_distance = abs(i - word.length);\n\
    \                        result = word[i..$];\n                    }\n       \
    \         }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnud_cbcm.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpnud_cbcm.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpnud_cbcm.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpnud_cbcm.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpnud_cbcm.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpnud_cbcm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    int vowel_index\
    \ = -1;\n    int distance = word.length;\n    while (index >= 0)\n    {\n    \
    \    if (vowels.find(word[index]) != -1)\n        {\n            if (vowel_index\
    \ == -1)\n            {\n                vowel_index = index;\n            }\n\
    \            else\n            {\n                if (index - vowel_index < distance)\n\
    \                {\n                    distance = index - vowel_index;\n    \
    \                result = word[vowel_index];\n                }\n            \
    \    vowel_index = index;\n            }\n        }\n        index--;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv59gfjah.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpv59gfjah.d(29): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmpv59gfjah.d(32):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpv59gfjah.d(43): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)vowel_index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpv59gfjah.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbmzcnx0o.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpbmzcnx0o.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpbmzcnx0o.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpbmzcnx0o.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbmzcnx0o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            int j = i;\n            while (j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n            }\n            if (j\
    \ >= 0 && consonants.find(word[j]) == -1)\n            {\n                j++;\n\
    \            }\n            if (j < i)\n            {\n                int k =\
    \ i;\n                while (k < word.length && consonants.find(word[k]) != -1)\n\
    \                {\n                    k++;\n                }\n            \
    \    if (k < word.length && consonants.find(word[k]) == -1)\n                {\n\
    \                    k--;\n                }\n                if (k > i)\n   \
    \             {\n                    int distance = min(i - j, k - i);\n     \
    \               if (distance < min_distance)\n                    {\n        \
    \                min_distance = distance;\n                        index = i;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if (index != 0)\n    {\n        result = word[index..$];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkns4tjnn.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkns4tjnn.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpkns4tjnn.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpkns4tjnn.d(39): Error: no property `find` for type `string`\\\
    n/tmp/tmpkns4tjnn.d(46): Error: no property `find` for type `string`\\n/tmp/tmpkns4tjnn.d(50):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpkns4tjnn.d(56): Error:\
    \ undefined identifier `min`, did you mean function `main`?\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkns4tjnn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int i = word.length - 1;\n    while (i > 0)\n    {\n   \
    \     if (consonants.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i\
    \ - 1]) != -1)\n            {\n                result = word[i - 1];\n       \
    \         break;\n            }\n            else\n            {\n           \
    \     i--;\n            }\n        }\n        else\n        {\n            i--;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpncygy0qs.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpncygy0qs.d(31): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpncygy0qs.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpncygy0qs.d(35): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)(i - 1)]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpncygy0qs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != -1)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuy3ys2wq.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpuy3ys2wq.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpuy3ys2wq.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpuy3ys2wq.d(37):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuy3ys2wq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >=\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (index == word.length - 1)\n            {\n                if (vowels.find(word[index\
    \ - 1]) == -1)\n                {\n                    result = word[index];\n\
    \                    break;\n                }\n            }\n            else\
    \ if (index == 0)\n            {\n                if (vowels.find(word[index +\
    \ 1]) == -1)\n                {\n                    result = word[index];\n \
    \                   break;\n                }\n            }\n            else\
    \ if (vowels.find(word[index - 1]) == -1 && vowels.find(word[index + 1]) == -1)\n\
    \            {\n                result = word[index];\n                break;\n\
    \            }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg24y529o.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpg24y529o.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpg24y529o.d(34): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpg24y529o.d(36): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    n/tmp/tmpg24y529o.d(42): Error: no property `find` for type `string`\\n/tmp/tmpg24y529o.d(44):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\n/tmp/tmpg24y529o.d(48): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpg24y529o.d(48): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpg24y529o.d(50): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)index]` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg24y529o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ distance = 0;\n            int j = i;\n            while(j >= 0 && consonants.find(word[j])\
    \ != -1)\n            {\n                j--;\n                distance++;\n \
    \           }\n            j = i;\n            while(j < word.length && consonants.find(word[j])\
    \ != -1)\n            {\n                j++;\n                distance++;\n \
    \           }\n            if(distance > 2 && (min_distance == 0 || distance <\
    \ min_distance))\n            {\n                min_distance = distance;\n  \
    \              index = i;\n            }\n        }\n    }\n    if(min_distance\
    \ != 0)\n    {\n        result = word[index..index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpolkhnk5r.d(32): Error: no property `find` for type `string`\\\
    n/tmp/tmpolkhnk5r.d(35): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmpolkhnk5r.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpolkhnk5r.d(41): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmpolkhnk5r.d(42): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpolkhnk5r.d(50): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpolkhnk5r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    int index = 0;\n\
    \    foreach(i, char c; word)\n    {\n        if(vowels.find(c) != -1)\n     \
    \   {\n            if(i > 0 && vowels.find(word[i-1]) == -1)\n            {\n\
    \                if(i < distance)\n                {\n                    distance\
    \ = i;\n                    index = i;\n                }\n            }\n   \
    \     }\n    }\n    if(distance != word.length)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0sjocifa.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0sjocifa.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp0sjocifa.d(33): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp0sjocifa.d(37): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmp0sjocifa.d(38): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp0sjocifa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            int left = i - 1;\n            int right = i + 1;\n  \
    \          while (left >= 0 && vowels.find(word[left]) != -1)\n            {\n\
    \                left--;\n            }\n            while (right < word.length\
    \ && vowels.find(word[right]) != -1)\n            {\n                right++;\n\
    \            }\n            if (left >= 0 && right < word.length)\n          \
    \  {\n                int distance = right - left - 1;\n                if (distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i..i+1];\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfrsxas6p.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfrsxas6p.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpfrsxas6p.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpfrsxas6p.d(38): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrsxas6p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left_distance = 0;\n            int right_distance = 0;\n   \
    \         for(int j = i - 1; j >= 0; j--)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    left_distance = i - j;\n    \
    \                break;\n                }\n            }\n            for(int\
    \ j = i + 1; j < word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_distance = j - i;\n   \
    \                 break;\n                }\n            }\n            distance\
    \ = min(left_distance, right_distance);\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkb0vnpsi.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkb0vnpsi.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpkb0vnpsi.d(36): Error: cannot implicitly convert\
    \ expression `i - 1LU` of type `ulong` to `int`\\n/tmp/tmpkb0vnpsi.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpkb0vnpsi.d(40): Error: cannot\
    \ implicitly convert expression `i - cast(ulong)j` of type `ulong` to `int`\\\
    n/tmp/tmpkb0vnpsi.d(44): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmpkb0vnpsi.d(46): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpkb0vnpsi.d(48): Error: cannot implicitly convert\
    \ expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmpkb0vnpsi.d(52):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpkb0vnpsi.d(56):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkb0vnpsi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left = word[0..i].find_last_of(consonants);\n            int\
    \ right = word[i..$].find_first_of(consonants);\n            if(left != -1 &&\
    \ right != -1)\n            {\n                distance = right - left;\n    \
    \            if(distance < min_distance)\n                {\n                \
    \    min_distance = distance;\n                    result = c;\n             \
    \   }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzcueg3l4.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpzcueg3l4.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpzcueg3l4.d(34): Error: no property `find_last_of`\
    \ for type `string`\\n/tmp/tmpzcueg3l4.d(35): Error: no property `find_first_of`\
    \ for type `string`\\n/tmp/tmpzcueg3l4.d(42): Error: cannot implicitly convert\
    \ expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpzcueg3l4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    int distance\
    \ = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n      \
    \  {\n            distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqf30roii.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqf30roii.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpqf30roii.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpqf30roii.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqf30roii.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int minDistance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if (vowels.canFind(c))\n\
    \        {\n            index = i;\n            distance = word.length - index;\n\
    \            if (distance < minDistance)\n            {\n                minDistance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptwsu3ldn.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptwsu3ldn.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmptwsu3ldn.d(34): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmptwsu3ldn.d(35): Error: cannot\
    \ implicitly convert expression `word.length - cast(ulong)index` of type `ulong`\
    \ to `int`\\n/tmp/tmptwsu3ldn.d(39): Error: cannot implicitly convert expression\
    \ `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmptwsu3ldn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptj478lyn.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptj478lyn.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmptj478lyn.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmptj478lyn.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptj478lyn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int minDistance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            foreach(j, d; word[i..$])\n            {\n     \
    \           if(consonants.find(d) != -1)\n                {\n                \
    \    distance = j;\n                    break;\n                }\n          \
    \  }\n            if(distance < minDistance)\n            {\n                minDistance\
    \ = distance;\n                result = c;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgb6hir50.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgb6hir50.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpgb6hir50.d(37): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpgb6hir50.d(39): Error: cannot implicitly convert expression\
    \ `j` of type `ulong` to `int`\\n/tmp/tmpgb6hir50.d(46): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgb6hir50.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    for (int\
    \ i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && consonants.find(word[i-1]) != -1)\n     \
    \       {\n                if (i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                {\n                    if (min > abs(word.length - i))\n\
    \                    {\n                        min = abs(word.length - i);\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if (index != 0)\n    {\n        result =\
    \ word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2de8e5u4.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2de8e5u4.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp2de8e5u4.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp2de8e5u4.d(36): Error: no property `find` for type `string`\\\
    n/tmp/tmp2de8e5u4.d(40): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i)` of type `ulong` to `int`\\n/tmp/tmp2de8e5u4.d(49): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2de8e5u4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length;\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n\
    \    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int ii =\
    \ 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n   \
    \ int nn = 0;\n    int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr =\
    \ 0;\n    int ss = 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n   \
    \ int ww = 0;\n    int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aa =\
    \ 0;\n    int bb = 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n   \
    \ int ff = 0;\n    int gg = 0;\n    int hh = 0;\n    int iii = 0;\n    int jjj\
    \ = 0;\n    int kkk = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n\
    \    int ooo = 0;\n    int ppp = 0;\n\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas34hpcn.d(90): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpas34hpcn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance\
    \ = -1;\n    int word_length = word.length;\n    for (int i = 0; i < word_length;\
    \ i++)\n    {\n        if (consonants.find(word[i]) != -1)\n        {\n      \
    \      for (int j = i + 1; j < word_length; j++)\n            {\n            \
    \    if (vowels.find(word[j]) != -1)\n                {\n                    if\
    \ (closest_vowel_distance == -1)\n                    {\n                    \
    \    closest_vowel_distance = j - i;\n                        closest_vowel_index\
    \ = j;\n                    }\n                    else if (j - i < closest_vowel_distance)\n\
    \                    {\n                        closest_vowel_distance = j - i;\n\
    \                        closest_vowel_index = j;\n                    }\n   \
    \             }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ != -1)\n    {\n        closest_vowel = word[closest_vowel_index];\n    }\n \
    \   return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4rtam_ev.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4rtam_ev.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp4rtam_ev.d(37): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp4rtam_ev.d(55): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)closest_vowel_index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4rtam_ev.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz6yqvyuk.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpz6yqvyuk.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpz6yqvyuk.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpz6yqvyuk.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz6yqvyuk.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int right_consonant_index\
    \ = word.find_first_of(consonants, i + 1);\n            if(right_consonant_index\
    \ == -1)\n                break;\n            int left_consonant_index = word.find_last_of(consonants,\
    \ i - 1);\n            if(left_consonant_index == -1)\n                continue;\n\
    \            int distance = right_consonant_index - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprtqpt6t2.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprtqpt6t2.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprtqpt6t2.d(33): Error: no property `find_first_of`\
    \ for type `string`\\n/tmp/tmprtqpt6t2.d(36): Error: no property `find_last_of`\
    \ for type `string`\\n/tmp/tmprtqpt6t2.d(39): Error: cannot implicitly convert\
    \ expression `cast(ulong)right_consonant_index - i` of type `ulong` to `int`\\\
    n/tmp/tmprtqpt6t2.d(43): Error: cannot implicitly convert expression `c` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprtqpt6t2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int left_distance\
    \ = i;\n            int right_distance = word.length - i - 1;\n            if(left_distance\
    \ > 0 && right_distance > 0)\n            {\n                if(vowels.canFind(word[i-1])\
    \ || vowels.canFind(word[i+1]))\n                {\n                    continue;\n\
    \                }\n                else\n                {\n                \
    \    if(min_distance > min(left_distance, right_distance))\n                 \
    \   {\n                        min_distance = min(left_distance, right_distance);\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5mfn60wg.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5mfn60wg.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp5mfn60wg.d(32): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp5mfn60wg.d(33): Error: cannot\
    \ implicitly convert expression `word.length - i - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmp5mfn60wg.d(36): Error: no property `canFind` for type `string`\\n/tmp/tmp5mfn60wg.d(36):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp5mfn60wg.d(42): Error:\
    \ undefined identifier `min`, did you mean function `main`?\\n/tmp/tmp5mfn60wg.d(44):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmp5mfn60wg.d(45):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5mfn60wg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n\
    \            foreach(j, v; vowels)\n            {\n                if(word.find(v,\
    \ i) != -1)\n                {\n                    if(word.find(v, i) - i < min_distance)\n\
    \                    {\n                        min_distance = word.find(v, i)\
    \ - i;\n                        index = word.find(v, i);\n                   \
    \     result = v;\n                    }\n                }\n            }\n \
    \       }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_k1in8p.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpm_k1in8p.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpm_k1in8p.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpm_k1in8p.d(38): Error: no property `find` for type `string`\\\
    n/tmp/tmpm_k1in8p.d(40): Error: no property `find` for type `string`\\n/tmp/tmpm_k1in8p.d(41):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpm_k1in8p.d(42): Error:\
    \ cannot implicitly convert expression `v` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm_k1in8p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int closest_vowel_index = -1;\n    int closest_vowel_distance = 0;\n    int\
    \ current_vowel_distance = 0;\n    int current_vowel_index = -1;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            current_vowel_index\
    \ = i;\n            current_vowel_distance = word.length - i;\n            if(current_vowel_distance\
    \ > closest_vowel_distance)\n            {\n                closest_vowel_distance\
    \ = current_vowel_distance;\n                closest_vowel_index = current_vowel_index;\n\
    \            }\n        }\n    }\n    if(closest_vowel_index == -1)\n    {\n \
    \       return \"\";\n    }\n    return word[closest_vowel_index..$];\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpen14k739.d(32): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpen14k739.d(34): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmpen14k739.d(35): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpen14k739.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_qp8okjh.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_qp8okjh.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp_qp8okjh.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp_qp8okjh.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_qp8okjh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n\
    \            foreach(j, v; vowels)\n            {\n                if(word.find(v,\
    \ i) != -1)\n                {\n                    if(word.find(v, i) - i < min_distance)\n\
    \                    {\n                        min_distance = word.find(v, i)\
    \ - i;\n                        index = word.find(v, i);\n                   \
    \     result = v;\n                    }\n                }\n            }\n \
    \       }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprhbecnpb.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprhbecnpb.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprhbecnpb.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmprhbecnpb.d(38): Error: no property `find` for type `string`\\\
    n/tmp/tmprhbecnpb.d(40): Error: no property `find` for type `string`\\n/tmp/tmprhbecnpb.d(41):\
    \ Error: no property `find` for type `string`\\n/tmp/tmprhbecnpb.d(42): Error:\
    \ cannot implicitly convert expression `v` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprhbecnpb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = 0;\n    int min_index = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int A = 0;\n    int B = 0;\n    int C = 0;\n    int D = 0;\n    int E = 0;\n\
    \    int F = 0;\n    int G = 0;\n    int H = 0;\n    int I = 0;\n    int J = 0;\n\
    \    int K = 0;\n    int L = 0;\n    int M = 0;\n    int N = 0;\n    int O = 0;\n\
    \    int P = 0;\n    int Q = 0;\n    int R = 0;\n    int S = 0;\n    int T = 0;\n\
    \    int U = 0;\n    int V = 0;\n    int W = 0;\n    int X = 0;\n    int Y = 0;\n\
    \    int Z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n\
    \    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int ii =\
    \ 0;\n    int jj = 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n   \
    \ int nn = 0;\n    int oo = 0;\n    int pp =\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdvc5fwhi.d(92): Error: expression expected, not `unittest`\\\
    n/tmp/tmpdvc5fwhi.d(93): Error: semicolon expected, not `{`\\n/tmp/tmpdvc5fwhi.d(110):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdvc5fwhi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    int distance = word.length - i;\n\
    \                    if (distance < min_distance)\n                    {\n   \
    \                     min_distance = distance;\n                        result\
    \ = word[i];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptxe43irb.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptxe43irb.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmptxe43irb.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmptxe43irb.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmptxe43irb.d(36): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmptxe43irb.d(40): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptxe43irb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxnkcpr9a.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpxnkcpr9a.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpxnkcpr9a.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpxnkcpr9a.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnkcpr9a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    int i = word.length - 1;\n    while (i > 0)\n    {\n   \
    \     if (vowels.find(word[i]) != -1)\n        {\n            if (vowels.find(word[i-1])\
    \ == -1)\n            {\n                distance = word.length - i;\n       \
    \         if (distance < min_distance)\n                {\n                  \
    \  min_distance = distance;\n                    index = i;\n                }\n\
    \            }\n        }\n        i--;\n    }\n    if (min_distance != word.length)\n\
    \    {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpff19wazw.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpff19wazw.d(30): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpff19wazw.d(33):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpff19wazw.d(35): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpff19wazw.d(37): Error: cannot\
    \ implicitly convert expression `word.length - cast(ulong)i` of type `ulong` to\
    \ `int`\\n/tmp/tmpff19wazw.d(49): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)index]` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpff19wazw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = int.max;\n    foreach(i, c; word)\n    {\n\
    \        if(vowels.canFind(c))\n        {\n            int dist = 0;\n       \
    \     for(int j = i + 1; j < word.length; j++)\n            {\n              \
    \  if(consonants.canFind(word[j]))\n                {\n                    dist\
    \ = j - i;\n                    break;\n                }\n            }\n   \
    \         if(dist < min_dist)\n            {\n                min_dist = dist;\n\
    \                result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc_toqbkt.d(31): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpc_toqbkt.d(34): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmpc_toqbkt.d(36): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpc_toqbkt.d(38): Error: cannot implicitly convert\
    \ expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmpc_toqbkt.d(45):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc_toqbkt.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int closest_distance = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            int left_distance = word.length;\n            int right_distance\
    \ = word.length;\n            for (int j = i - 1; j >= 0; j--)\n            {\n\
    \                if (consonants.find(word[j]) != -1)\n                {\n    \
    \                left_distance = i - j;\n                    break;\n        \
    \        }\n            }\n            for (int j = i + 1; j < word.length; j++)\n\
    \            {\n                if (consonants.find(word[j]) != -1)\n        \
    \        {\n                    right_distance = j - i;\n                    break;\n\
    \                }\n            }\n            if (left_distance + right_distance\
    \ < closest_distance)\n            {\n                closest_distance = left_distance\
    \ + right_distance;\n                result = word[i];\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4k789n4e.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp4k789n4e.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp4k789n4e.d(33): Error: cannot implicitly convert\
    \ expression `word.length` of type `ulong` to `int`\\n/tmp/tmp4k789n4e.d(34):\
    \ Error: cannot implicitly convert expression `word.length` of type `ulong` to\
    \ `int`\\n/tmp/tmp4k789n4e.d(37): Error: no property `find` for type `string`\\\
    n/tmp/tmp4k789n4e.d(45): Error: no property `find` for type `string`\\n/tmp/tmp4k789n4e.d(54):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4k789n4e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int closest_vowel_index = word.length;\n\
    \    foreach(vowel; vowels)\n    {\n        int vowel_index = word.findLast(vowel);\n\
    \        if(vowel_index != -1 && vowel_index < closest_vowel_index)\n        {\n\
    \            closest_vowel = vowel;\n            closest_vowel_index = vowel_index;\n\
    \        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvd5xrtln.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvd5xrtln.d(30): Error: no property `findLast`\
    \ for type `string`\\n/tmp/tmpvd5xrtln.d(33): Error: cannot implicitly convert\
    \ expression `vowel` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvd5xrtln.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i == 0)\n                {\n                    if(consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \                else if(i == word.length - 1)\n                {\n          \
    \          if(consonants.find(word[i-1]) != -1)\n                    {\n     \
    \                   min_distance = distance;\n                        result =\
    \ c;\n                    }\n                }\n                else\n       \
    \         {\n                    if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5e7zb70m.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5e7zb70m.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5e7zb70m.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp5e7zb70m.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp5e7zb70m.d(41): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    n/tmp/tmp5e7zb70m.d(46): Error: no property `find` for type `string`\\n/tmp/tmp5e7zb70m.d(49):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\n/tmp/tmp5e7zb70m.d(54): Error: no property `find` for type `string`\\\
    n/tmp/tmp5e7zb70m.d(54): Error: no property `find` for type `string`\\n/tmp/tmp5e7zb70m.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5e7zb70m.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = -1;\n    int min = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            if(i\
    \ > 0 && consonants.canFind(word[i-1]) && i < word.length-1 && consonants.canFind(word[i+1]))\n\
    \            {\n                if(i < min)\n                {\n             \
    \       min = i;\n                    index = i;\n                }\n        \
    \    }\n        }\n    }\n    if(index != -1)\n    {\n        result = word[index..index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxiyz_z5w.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpxiyz_z5w.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpxiyz_z5w.d(34): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpxiyz_z5w.d(34): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmpxiyz_z5w.d(38): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmpxiyz_z5w.d(39): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxiyz_z5w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            foreach(j, d; word[i..$])\n            {\n     \
    \           if(consonants.find(d) != -1)\n                {\n                \
    \    distance = j;\n                    break;\n                }\n          \
    \  }\n            if(distance < min_distance)\n            {\n               \
    \ min_distance = distance;\n                index = i;\n            }\n      \
    \  }\n    }\n    if(min_distance != word.length)\n    {\n        result = word[index..index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5hu28deb.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5hu28deb.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5hu28deb.d(37): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp5hu28deb.d(39): Error: cannot implicitly convert expression\
    \ `j` of type `ulong` to `int`\\n/tmp/tmp5hu28deb.d(46): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5hu28deb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdi7yju6p.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpdi7yju6p.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpdi7yju6p.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpdi7yju6p.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdi7yju6p.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int dist = word.length - i;\n            if (dist < min_dist)\n           \
    \ {\n                min_dist = dist;\n                result = word[i];\n   \
    \         }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjqkobcyx.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjqkobcyx.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpjqkobcyx.d(32): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpjqkobcyx.d(36):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjqkobcyx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int index = 0;\n    int i = 0;\n    int j = 0;\n    foreach(i, char c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            index = i;\n\
    \            distance = 0;\n            for(j = index; j < word.length; j++)\n\
    \            {\n                if(vowels.find(word[j]) == -1)\n             \
    \   {\n                    distance++;\n                }\n                else\n\
    \                {\n                    break;\n                }\n          \
    \  }\n            if(distance < min_distance)\n            {\n               \
    \ min_distance = distance;\n                result = c;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp59xgrhck.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp59xgrhck.d(32): Error: variable `i` is shadowing\
    \ variable `tmp59xgrhck.get_closest_vowel.i`\\n/tmp/tmp59xgrhck.d(34): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp59xgrhck.d(36): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp59xgrhck.d(40):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp59xgrhck.d(52): Error:\
    \ cannot implicitly convert expression `c` of type `char` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp59xgrhck.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    int distance = 0;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9c3e_5u4.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9c3e_5u4.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp9c3e_5u4.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp9c3e_5u4.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9c3e_5u4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = 0;\n    int i\
    \ = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int\
    \ n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n   \
    \ int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int A = 0;\n    int B = 0;\n\
    \    int C = 0;\n    int D = 0;\n    int E = 0;\n    int F = 0;\n    int G = 0;\n\
    \    int H = 0;\n    int I = 0;\n    int J = 0;\n    int K = 0;\n    int L = 0;\n\
    \    int M = 0;\n    int N = 0;\n    int O = 0;\n    int P = 0;\n    int Q = 0;\n\
    \    int R = 0;\n    int S = 0;\n    int T = 0;\n    int U = 0;\n    int V = 0;\n\
    \    int W = 0;\n    int X = 0;\n    int Y = 0;\n    int Z = 0;\n    int a = 0;\n\
    \    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n\
    \    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj = 0;\n    int kk\
    \ = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n    int oo = 0;\n \
    \   int pp = 0;\n    int qq = 0;\n    int rr =\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeg_dutqz.d(92): Error: expression expected, not `unittest`\\\
    n/tmp/tmpeg_dutqz.d(93): Error: semicolon expected, not `{`\\n/tmp/tmpeg_dutqz.d(110):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeg_dutqz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    int distance =\
    \ word.length;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    if (abs(index - i) < distance)\n\
    \                    {\n                        distance = abs(index - i);\n \
    \                       result = word[i];\n                    }\n           \
    \     }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdd0zi27f.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpdd0zi27f.d(28): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmpdd0zi27f.d(31):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpdd0zi27f.d(35): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpdd0zi27f.d(35): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpdd0zi27f.d(40): Error: cannot implicitly\
    \ convert expression `word[cast(ulong)i]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdd0zi27f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            distance = word.length - i - 1;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               index = i;\n            }\n        }\n    }\n    if(min_distance\
    \ == word.length)\n    {\n        return result;\n    }\n    else\n    {\n   \
    \     return word[index..$];\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppd1udmlc.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmppd1udmlc.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmppd1udmlc.d(35): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmppd1udmlc.d(39):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppd1udmlc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index > 0 && index < word.length\
    \ - 1)\n    {\n        if(!vowels.canFind(word[index - 1]) && !vowels.canFind(word[index\
    \ + 1]))\n        {\n            result = word[index..$];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_p58ori.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpm_p58ori.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpm_p58ori.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpm_p58ori.d(37):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpm_p58ori.d(43):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpm_p58ori.d(43): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpm_p58ori.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    distance = word.length\
    \ - i;\n                    if (distance < min_distance)\n                   \
    \ {\n                        min_distance = distance;\n                      \
    \  result = word[i];\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdwd6k1sp.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpdwd6k1sp.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpdwd6k1sp.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpdwd6k1sp.d(35): Error: no property `find` for type `string`\\\
    n/tmp/tmpdwd6k1sp.d(37): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpdwd6k1sp.d(41): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdwd6k1sp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int closest = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ left = i;\n            int right = i;\n            while(left >= 0 && consonants.find(word[left])\
    \ != -1)\n                left--;\n            while(right < word.length && consonants.find(word[right])\
    \ != -1)\n                right++;\n            if(left >= 0 && right < word.length)\n\
    \            {\n                if(abs(i - left) < closest)\n                {\n\
    \                    closest = abs(i - left);\n                    index = i;\n\
    \                }\n            }\n        }\n    }\n    if(index != 0)\n    \
    \    result = word[index..index];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb3xa_cr8.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpb3xa_cr8.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpb3xa_cr8.d(34): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpb3xa_cr8.d(35): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpb3xa_cr8.d(36):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpb3xa_cr8.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpb3xa_cr8.d(44): Error: cannot\
    \ implicitly convert expression `abs(i - cast(ulong)left)` of type `ulong` to\
    \ `int`\\n/tmp/tmpb3xa_cr8.d(45): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpb3xa_cr8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, letter;\
    \ word)\n    {\n        if(vowels.find(letter) != -1)\n        {\n           \
    \ int distance = word.length - i;\n            if(distance < min_distance)\n \
    \           {\n                if(i > 0 && consonants.find(word[i-1]) != -1)\n\
    \                {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = letter;\n                    }\n           \
    \     }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ash1x1p.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3ash1x1p.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp3ash1x1p.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp3ash1x1p.d(36):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp3ash1x1p.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp3ash1x1p.d(41): Error: cannot\
    \ implicitly convert expression `letter` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ash1x1p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    for (int i = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = word.length - i;\n            if (distance\
    \ < minDistance)\n            {\n                minDistance = distance;\n   \
    \             result = word[i..$];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaboi71gd.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpaboi71gd.d(29): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpaboi71gd.d(31):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpaboi71gd.d(33): Error:\
    \ cannot implicitly convert expression `word.length - cast(ulong)i` of type `ulong`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaboi71gd.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int left_distance\
    \ = i;\n            int right_distance = word.length - i - 1;\n            if(left_distance\
    \ > 0 && right_distance > 0)\n            {\n                if(consonants.canFind(word[i-1])\
    \ && consonants.canFind(word[i+1]))\n                {\n                    if(min_distance\
    \ > left_distance)\n                    {\n                        min_distance\
    \ = left_distance;\n                        result = c;\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp61yjet27.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp61yjet27.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp61yjet27.d(33): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp61yjet27.d(34): Error: cannot\
    \ implicitly convert expression `word.length - i - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmp61yjet27.d(37): Error: no property `canFind` for type `string`\\n/tmp/tmp61yjet27.d(37):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp61yjet27.d(42): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp61yjet27.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index == 0)\n        return result;\n\
    \    else\n        return word[index..$];\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg5z466ge.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpg5z466ge.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpg5z466ge.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpg5z466ge.d(37):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg5z466ge.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = -1;\n    int distance = 0;\n    int temp = 0;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i == 0)\n            {\n                continue;\n\
    \            }\n            else if (i == word.length - 1)\n            {\n  \
    \              continue;\n            }\n            else if (consonants.find(word[i\
    \ - 1]) != -1 && consonants.find(word[i + 1]) != -1)\n            {\n        \
    \        temp = abs(i - word.length);\n                if (index == -1)\n    \
    \            {\n                    index = i;\n                    distance =\
    \ temp;\n                }\n                else if (temp < distance)\n      \
    \          {\n                    index = i;\n                    distance = temp;\n\
    \                }\n            }\n        }\n    }\n    if (index != -1)\n  \
    \  {\n        result = word[index];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuy5e2hw1.d(33): Error: no property `find` for type `string`\\\
    n/tmp/tmpuy5e2hw1.d(43): Error: no property `find` for type `string`\\n/tmp/tmpuy5e2hw1.d(43):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpuy5e2hw1.d(45): Error:\
    \ cannot implicitly convert expression `abs(cast(ulong)i - word.length)` of type\
    \ `ulong` to `int`\\n/tmp/tmpuy5e2hw1.d(61): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuy5e2hw1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(word.length\
    \ - i - 1))\n                    {\n                        min_distance = abs(word.length\
    \ - i - 1);\n                        result = word[i];\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrdj3x83.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpcrdj3x83.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpcrdj3x83.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpcrdj3x83.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpcrdj3x83.d(38): Error: cannot implicitly convert expression `abs(word.length\
    \ - cast(ulong)i - 1LU)` of type `ulong` to `int`\\n/tmp/tmpcrdj3x83.d(39): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcrdj3x83.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < minDistance)\n\
    \            {\n                minDistance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfspzz_pz.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfspzz_pz.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpfspzz_pz.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpfspzz_pz.d(38):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfspzz_pz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n\
    \            distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp55gol_4a.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp55gol_4a.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp55gol_4a.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp55gol_4a.d(38):\
    \ Error: cannot implicitly convert expression `c` of type `char` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55gol_4a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i != 0 && i != word.length - 1)\n                {\n     \
    \               if(consonants.find(word[i - 1]) != -1 && consonants.find(word[i\
    \ + 1]) != -1)\n                    {\n                        min_distance =\
    \ distance;\n                        result = c;\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp88y04xvb.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp88y04xvb.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp88y04xvb.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp88y04xvb.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp88y04xvb.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp88y04xvb.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp88y04xvb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ymg60rw.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3ymg60rw.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp3ymg60rw.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp3ymg60rw.d(37):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ymg60rw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int temp = 0;\n    int index\
    \ = 0;\n    foreach(i, c; word)\n    {\n        if (vowels.canFind(c))\n     \
    \   {\n            temp = word.length - i;\n            if (temp > distance)\n\
    \            {\n                distance = temp;\n                result = c;\n\
    \                index = i;\n            }\n        }\n    }\n    if (index ==\
    \ 0 || index == word.length - 1)\n        return \"\";\n    if (word[index - 1]\
    \ == ' ' || word[index + 1] == ' ')\n        return \"\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpae1m3vva.d(32): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpae1m3vva.d(34): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpae1m3vva.d(38): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\n/tmp/tmpae1m3vva.d(39):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae1m3vva.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < minDistance)\n\
    \            {\n                minDistance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2tnxafao.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2tnxafao.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp2tnxafao.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp2tnxafao.d(38):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2tnxafao.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != 0)\n    {\n        result\
    \ = word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbvj4ssod.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpbvj4ssod.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpbvj4ssod.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpbvj4ssod.d(37):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbvj4ssod.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = 0;\n            int right_distance = 0;\n            for(int j = i - 1; j\
    \ >= 0; j--)\n            {\n                if(consonants.find(word[j]) != -1)\n\
    \                {\n                    left_distance = i - j;\n             \
    \       break;\n                }\n            }\n            for(int j = i +\
    \ 1; j < word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_distance = j - i;\n   \
    \                 break;\n                }\n            }\n            if(left_distance\
    \ != 0 && right_distance != 0)\n            {\n                int distance =\
    \ min(left_distance, right_distance);\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_5qw3176.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp_5qw3176.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp_5qw3176.d(35): Error: cannot implicitly convert\
    \ expression `i - 1LU` of type `ulong` to `int`\\n/tmp/tmp_5qw3176.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp_5qw3176.d(39): Error: cannot\
    \ implicitly convert expression `i - cast(ulong)j` of type `ulong` to `int`\\\
    n/tmp/tmp_5qw3176.d(43): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmp_5qw3176.d(45): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp_5qw3176.d(47): Error: cannot implicitly convert\
    \ expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmp_5qw3176.d(53):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmp_5qw3176.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_5qw3176.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(i - word.length))\n\
    \                    {\n                        min_distance = abs(i - word.length);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxhsa6jmg.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpxhsa6jmg.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpxhsa6jmg.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpxhsa6jmg.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpxhsa6jmg.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmpxhsa6jmg.d(39): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxhsa6jmg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min = word.length;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n     \
    \       if(i != 0 && i != word.length - 1)\n            {\n                if(!vowels.canFind(word[i\
    \ - 1]) && !vowels.canFind(word[i + 1]))\n                {\n                \
    \    if(abs(i - word.length) < min)\n                    {\n                 \
    \       min = abs(i - word.length);\n                        index = i;\n    \
    \                }\n                }\n            }\n        }\n    }\n    if(index\
    \ != 0)\n    {\n        result = word[index..index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphaeemrq3.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphaeemrq3.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmphaeemrq3.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmphaeemrq3.d(35): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmphaeemrq3.d(39): Error: cannot implicitly convert expression\
    \ `abs(i - word.length)` of type `ulong` to `int`\\n/tmp/tmphaeemrq3.d(40): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphaeemrq3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int min_distance = int.max;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index != -1)\n    {\n        result\
    \ = word[index..index];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf0zjvx1q.d(31): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpf0zjvx1q.d(33): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpf0zjvx1q.d(37): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf0zjvx1q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min = word.length;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n     \
    \       int j = i;\n            while(j >= 0 && vowels.canFind(word[j]))\n   \
    \         {\n                j--;\n            }\n            if(j >= 0 && !vowels.canFind(word[j]))\n\
    \            {\n                j++;\n                if(i - j < min)\n      \
    \          {\n                    min = i - j;\n                    index = i;\n\
    \                }\n            }\n        }\n    }\n    if(min != word.length)\n\
    \    {\n        result = word[index..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp__kv8g9l.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp__kv8g9l.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp__kv8g9l.d(33): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp__kv8g9l.d(34): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmp__kv8g9l.d(38): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmp__kv8g9l.d(43): Error: cannot implicitly\
    \ convert expression `i - cast(ulong)j` of type `ulong` to `int`\\n/tmp/tmp__kv8g9l.d(44):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp__kv8g9l.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(index == 0)\n        return result;\n\
    \    if(consonants.find(word[index - 1]) != -1 && consonants.find(word[index +\
    \ 1]) != -1)\n        return word[index..$];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzq14_ull.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpzq14_ull.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpzq14_ull.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpzq14_ull.d(38):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpzq14_ull.d(44):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpzq14_ull.d(44): Error:\
    \ no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpzq14_ull.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = -1;\n    int min_distance = word.length;\n \
    \   foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                if(i > 0 && consonants.find(word[i-1]) != -1)\n\
    \                {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if(index != -1)\n    {\n        result =\
    \ word[index..$];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi5ig9lgq.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpi5ig9lgq.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpi5ig9lgq.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpi5ig9lgq.d(37):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpi5ig9lgq.d(39): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpi5ig9lgq.d(42): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi5ig9lgq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int tmp_distance = word.length - i;\n            if(tmp_distance\
    \ < min_distance)\n            {\n                min_distance = tmp_distance;\n\
    \                result = c;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp6lut4r8.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpp6lut4r8.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpp6lut4r8.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpp6lut4r8.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp6lut4r8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance\
    \ = -1;\n    foreach(i, char c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            int distance = word.length - i;\n            if(closest_vowel_distance\
    \ == -1 || distance < closest_vowel_distance)\n            {\n               \
    \ closest_vowel_distance = distance;\n                closest_vowel_index = i;\n\
    \                closest_vowel = c;\n            }\n        }\n    }\n    if(closest_vowel_index\
    \ == -1)\n        return \"\";\n    if(closest_vowel_index == 0)\n        return\
    \ \"\";\n    if(closest_vowel_index == word.length - 1)\n        return \"\";\n\
    \    if(vowels.canFind(word[closest_vowel_index - 1]))\n        return \"\";\n\
    \    if(vowels.canFind(word[closest_vowel_index + 1]))\n        return \"\";\n\
    \    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmy3cergr.d(31): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpmy3cergr.d(33): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpmy3cergr.d(37): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\n/tmp/tmpmy3cergr.d(38): Error:\
    \ cannot implicitly convert expression `c` of type `char` to `string`\\n/tmp/tmpmy3cergr.d(48):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpmy3cergr.d(50): Error:\
    \ no property `canFind` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpmy3cergr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = 0;\n    int distance = 0;\n \
    \   int index = 0;\n    foreach(i, vowel; word)\n    {\n        if(vowels.canFind(vowel))\n\
    \        {\n            distance = word.length - i;\n            if(distance >\
    \ min_distance)\n            {\n                min_distance = distance;\n   \
    \             result = vowel;\n                index = i;\n            }\n   \
    \     }\n    }\n    if(index == 0 || index == word.length - 1)\n    {\n      \
    \  return \"\";\n    }\n    else\n    {\n        return result;\n    }\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwpvevkc5.d(32): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpwpvevkc5.d(34): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpwpvevkc5.d(38): Error: cannot implicitly\
    \ convert expression `vowel` of type `immutable(char)` to `string`\\n/tmp/tmpwpvevkc5.d(39):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwpvevkc5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(v; word)\n\
    \    {\n        if(vowels.canFind(v))\n        {\n            int index = word.indexOf(v);\n\
    \            int distance = word.length - index;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = v;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuyir6sg4.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpuyir6sg4.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpuyir6sg4.d(33): Error: no property `indexOf` for\
    \ type `string`\\n/tmp/tmpuyir6sg4.d(34): Error: cannot implicitly convert expression\
    \ `word.length - cast(ulong)index` of type `ulong` to `int`\\n/tmp/tmpuyir6sg4.d(38):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuyir6sg4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            if (i > 0 && i < word.length - 1)\n            {\n   \
    \             if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) ==\
    \ -1)\n                {\n                    if (min_distance > abs(i - word.length))\n\
    \                    {\n                        min_distance = abs(i - word.length);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpshlo0_st.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpshlo0_st.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpshlo0_st.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpshlo0_st.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpshlo0_st.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmpshlo0_st.d(39): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpshlo0_st.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(consonants.find(c) != -1)\n        {\n            foreach(j,\
    \ v; vowels)\n            {\n                if(word.find(v, i) != -1)\n     \
    \           {\n                    int distance = word.find(v, i) - i;\n     \
    \               if(distance < min_distance)\n                    {\n         \
    \               min_distance = distance;\n                        result = v;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg6p74o80.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpg6p74o80.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpg6p74o80.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpg6p74o80.d(37): Error: no property `find` for type `string`\\\
    n/tmp/tmpg6p74o80.d(41): Error: cannot implicitly convert expression `v` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg6p74o80.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    foreach(i, vowel;\
    \ vowels)\n    {\n        int index = word.find(vowel);\n        if(index != -1)\n\
    \        {\n            if(index > 0 && index < word.length - 1)\n           \
    \ {\n                if(!isLetter(word[index - 1]) && !isLetter(word[index + 1]))\n\
    \                {\n                    if(index < distance)\n               \
    \     {\n                        distance = index;\n                        result\
    \ = vowel;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyk8gjl9f.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpyk8gjl9f.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpyk8gjl9f.d(35): Error: undefined identifier `isLetter`\\\
    n/tmp/tmpyk8gjl9f.d(35): Error: undefined identifier `isLetter`\\n/tmp/tmpyk8gjl9f.d(40):\
    \ Error: cannot implicitly convert expression `vowel` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyk8gjl9f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int closest = word.length;\n    string closest_vowel = \"\";\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int left\
    \ = i;\n            int right = word.length - i - 1;\n            if(left > 0\
    \ && right > 0)\n            {\n                if(vowels.canFind(word[i - 1])\
    \ || vowels.canFind(word[i + 1]))\n                    continue;\n           \
    \     if(left + right < closest)\n                {\n                    closest\
    \ = left + right;\n                    closest_vowel = c;\n                }\n\
    \            }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2irk3lt0.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2irk3lt0.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp2irk3lt0.d(32): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp2irk3lt0.d(33): Error: cannot\
    \ implicitly convert expression `word.length - i - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmp2irk3lt0.d(36): Error: no property `canFind` for type `string`\\n/tmp/tmp2irk3lt0.d(36):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp2irk3lt0.d(41): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2irk3lt0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int closest = 0;\n    int distance = 0;\n    int temp =\
    \ 0;\n    int temp2 = 0;\n    int temp3 = 0;\n    int temp4 = 0;\n    int temp5\
    \ = 0;\n    int temp6 = 0;\n    int temp7 = 0;\n    int temp8 = 0;\n    int temp9\
    \ = 0;\n    int temp10 = 0;\n    int temp11 = 0;\n    int temp12 = 0;\n    int\
    \ temp13 = 0;\n    int temp14 = 0;\n    int temp15 = 0;\n    int temp16 = 0;\n\
    \    int temp17 = 0;\n    int temp18 = 0;\n    int temp19 = 0;\n    int temp20\
    \ = 0;\n    int temp21 = 0;\n    int temp22 = 0;\n    int temp23 = 0;\n    int\
    \ temp24 = 0;\n    int temp25 = 0;\n    int temp26 = 0;\n    int temp27 = 0;\n\
    \    int temp28 = 0;\n    int temp29 = 0;\n    int temp30 = 0;\n    int temp31\
    \ = 0;\n    int temp32 = 0;\n    int temp33 = 0;\n    int temp34 = 0;\n    int\
    \ temp35 = 0;\n    int temp36 = 0;\n    int temp37 = 0;\n    int temp38 = 0;\n\
    \    int temp39 = 0;\n    int temp40 = 0;\n    int temp41 = 0;\n    int temp42\
    \ = 0;\n    int temp43 = 0;\n    int temp44 = 0;\n    int temp45 = 0;\n    int\
    \ temp46 = 0;\n    int temp47 = 0;\n    int temp48 = 0;\n    int temp49 = 0;\n\
    \    int temp50 = 0;\n    int temp51 = 0;\n    int temp52 = 0;\n    int temp53\
    \ = 0;\n    int temp54 = 0;\n    int temp55 = 0;\n\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpotiag5oe.d(86): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpotiag5oe.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, char c;\
    \ word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int left_consonant_index\
    \ = word[0..i].find_last_of(consonants);\n            int right_consonant_index\
    \ = word[i+1..$].find_first_of(consonants);\n            if(left_consonant_index\
    \ != -1 && right_consonant_index != -1)\n            {\n                int distance\
    \ = right_consonant_index;\n                if(distance < min_distance)\n    \
    \            {\n                    min_distance = distance;\n               \
    \     result = c;\n                }\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp0cn44o5.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpp0cn44o5.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpp0cn44o5.d(33): Error: no property `find_last_of`\
    \ for type `string`\\n/tmp/tmpp0cn44o5.d(34): Error: no property `find_first_of`\
    \ for type `string`\\n/tmp/tmpp0cn44o5.d(41): Error: cannot implicitly convert\
    \ expression `c` of type `char` to `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpp0cn44o5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl8otq9sw.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpl8otq9sw.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpl8otq9sw.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpl8otq9sw.d(38):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl8otq9sw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            if(i\
    \ > 0 && consonants.find(word[i-1]) != -1)\n            {\n                if(i\
    \ < word.length - 1 && consonants.find(word[i+1]) != -1)\n                {\n\
    \                    if(abs(word.length - i) < min)\n                    {\n \
    \                       min = abs(word.length - i);\n                        index\
    \ = i;\n                    }\n                }\n            }\n        }\n \
    \   }\n    if(index != 0)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuvc0dvnw.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpuvc0dvnw.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpuvc0dvnw.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpuvc0dvnw.d(36): Error: no property `find` for type `string`\\\
    n/tmp/tmpuvc0dvnw.d(40): Error: cannot implicitly convert expression `abs(word.length\
    \ - i)` of type `ulong` to `int`\\n/tmp/tmpuvc0dvnw.d(41): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\n/tmp/tmpuvc0dvnw.d(49): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuvc0dvnw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int j = i;\n   \
    \         while(j > 0 && vowels.canFind(word[j]))\n                j--;\n    \
    \        if(!vowels.canFind(word[j]))\n            {\n                j--;\n \
    \               while(j > 0 && vowels.canFind(word[j]))\n                    j--;\n\
    \                if(!vowels.canFind(word[j]))\n                {\n           \
    \         if(i - j < distance)\n                    {\n                      \
    \  distance = i - j;\n                        result = c;\n                  \
    \  }\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3da3gwr.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpu3da3gwr.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpu3da3gwr.d(32): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpu3da3gwr.d(33): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpu3da3gwr.d(35): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmpu3da3gwr.d(38): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpu3da3gwr.d(40): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpu3da3gwr.d(44): Error: cannot implicitly convert expression\
    \ `i - cast(ulong)j` of type `ulong` to `int`\\n/tmp/tmpu3da3gwr.d(45): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu3da3gwr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   if(i > 0 && consonants.canFind(word[i-1]))\n                {\n          \
    \          if(i < word.length - 1 && consonants.canFind(word[i+1]))\n        \
    \            {\n                        min_distance = distance;\n           \
    \             result = c;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkcjs6wyv.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkcjs6wyv.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpkcjs6wyv.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpkcjs6wyv.d(36):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpkcjs6wyv.d(38): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpkcjs6wyv.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkcjs6wyv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.find(word[index]) != -1)\n        {\n        \
    \    if (vowels.find(word[index - 1]) == -1)\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9gqjv0x3.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp9gqjv0x3.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp9gqjv0x3.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp9gqjv0x3.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9gqjv0x3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgj01s1uu.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgj01s1uu.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpgj01s1uu.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpgj01s1uu.d(38):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgj01s1uu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               index = i;\n            }\n        }\n    }\n    if(min_distance\
    \ != word.length)\n    {\n        result = word[index..$];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplcvwbzi5.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplcvwbzi5.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmplcvwbzi5.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmplcvwbzi5.d(38):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplcvwbzi5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min = word.length;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n     \
    \       int j = word.length - 1;\n            while(j > i)\n            {\n  \
    \              if(vowels.canFind(word[j]))\n                {\n              \
    \      j--;\n                }\n                else\n                {\n    \
    \                break;\n                }\n            }\n            if(j >\
    \ i)\n            {\n                if(j - i < min)\n                {\n    \
    \                min = j - i;\n                    index = i;\n              \
    \  }\n            }\n        }\n    }\n    if(min != word.length)\n    {\n   \
    \     result = word[index..index];\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp23aj3r0o.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp23aj3r0o.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp23aj3r0o.d(33): Error: cannot implicitly convert\
    \ expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp23aj3r0o.d(36):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp23aj3r0o.d(49): Error:\
    \ cannot implicitly convert expression `cast(ulong)j - i` of type `ulong` to `int`\\\
    n/tmp/tmp23aj3r0o.d(50): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp23aj3r0o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int left_distance\
    \ = i;\n            int right_distance = word.length - i - 1;\n            if(left_distance\
    \ > 0 && right_distance > 0)\n            {\n                if(consonants.canFind(word[i-1])\
    \ && consonants.canFind(word[i+1]))\n                {\n                    if(min_distance\
    \ > left_distance)\n                    {\n                        min_distance\
    \ = left_distance;\n                        result = c;\n                    }\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1lvtvyh7.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp1lvtvyh7.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp1lvtvyh7.d(33): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp1lvtvyh7.d(34): Error: cannot\
    \ implicitly convert expression `word.length - i - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmp1lvtvyh7.d(37): Error: no property `canFind` for type `string`\\n/tmp/tmp1lvtvyh7.d(37):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp1lvtvyh7.d(42): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1lvtvyh7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2hy8kpae.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2hy8kpae.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp2hy8kpae.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp2hy8kpae.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2hy8kpae.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = 0;\n            for(int j = i; j < word.length; j++)\n            {\n    \
    \            if(consonants.find(word[j]) != -1)\n                {\n         \
    \           distance = j - i;\n                    break;\n                }\n\
    \            }\n            if(distance < min_distance)\n            {\n     \
    \           min_distance = distance;\n                result = c;\n          \
    \  }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3tyr7t66.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3tyr7t66.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp3tyr7t66.d(34): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp3tyr7t66.d(36): Error: no\
    \ property `find` for type `string`\\n/tmp/tmp3tyr7t66.d(38): Error: cannot implicitly\
    \ convert expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmp3tyr7t66.d(45):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3tyr7t66.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int minDistance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            distance = word.length - i;\n            if(distance\
    \ < minDistance)\n            {\n                minDistance = distance;\n   \
    \             index = i;\n            }\n        }\n    }\n    if(index == 0)\n\
    \    {\n        return result;\n    }\n    else\n    {\n        if(consonants.find(word[index\
    \ - 1]) != -1 && consonants.find(word[index + 1]) != -1)\n        {\n        \
    \    result = word[index..index];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppbrmm3oa.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmppbrmm3oa.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmppbrmm3oa.d(35): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmppbrmm3oa.d(39):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmppbrmm3oa.d(49):\
    \ Error: no property `find` for type `string`\\n/tmp/tmppbrmm3oa.d(49): Error:\
    \ no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppbrmm3oa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, char c;\
    \ word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = -1;\n            int right_distance = -1;\n            for(int j = i - 1;\
    \ j >= 0; j--)\n            {\n                if(consonants.find(word[j]) !=\
    \ -1)\n                {\n                    left_distance = i - j;\n       \
    \             break;\n                }\n            }\n            for(int j\
    \ = i + 1; j < word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_distance = j - i;\n   \
    \                 break;\n                }\n            }\n            if(left_distance\
    \ != -1 && right_distance != -1)\n            {\n                int distance\
    \ = min(left_distance, right_distance);\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas0955fh.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpas0955fh.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpas0955fh.d(35): Error: cannot implicitly convert\
    \ expression `i - 1LU` of type `ulong` to `int`\\n/tmp/tmpas0955fh.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpas0955fh.d(39): Error: cannot\
    \ implicitly convert expression `i - cast(ulong)j` of type `ulong` to `int`\\\
    n/tmp/tmpas0955fh.d(43): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmpas0955fh.d(45): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpas0955fh.d(47): Error: cannot implicitly convert\
    \ expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmpas0955fh.d(53):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpas0955fh.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `char` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpas0955fh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int pos = word.length - 1;\n    while (pos > 0)\n\
    \    {\n        if (vowels.find(word[pos]) != -1)\n        {\n            if (vowels.find(word[pos-1])\
    \ == -1)\n            {\n                result = word[pos];\n               \
    \ break;\n            }\n        }\n        pos--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjfsf9qum.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpjfsf9qum.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpjfsf9qum.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpjfsf9qum.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)pos]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjfsf9qum.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min = int.max;\n    int index = 0;\n    foreach(i, c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int left\
    \ = i;\n            int right = i;\n            while(left >= 0 && consonants.canFind(word[left]))\n\
    \                left--;\n            while(right < word.length && consonants.canFind(word[right]))\n\
    \                right++;\n            if(left >= 0 && right < word.length)\n\
    \            {\n                if(right - left < min)\n                {\n  \
    \                  min = right - left;\n                    index = i;\n     \
    \           }\n            }\n        }\n    }\n    if(min != int.max)\n     \
    \   result = word[index..index];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpos2gxa8g.d(32): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpos2gxa8g.d(34): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmpos2gxa8g.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpos2gxa8g.d(36): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmpos2gxa8g.d(38): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmpos2gxa8g.d(45): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpos2gxa8g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    distance = word.length\
    \ - i;\n                    if (distance < min_distance)\n                   \
    \ {\n                        min_distance = distance;\n                      \
    \  result = word[i];\n                    }\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0v5egl6s.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0v5egl6s.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp0v5egl6s.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp0v5egl6s.d(35): Error: no property `find` for type `string`\\\
    n/tmp/tmp0v5egl6s.d(37): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmp0v5egl6s.d(41): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0v5egl6s.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(consonants.find(c) == -1)\n        {\n            continue;\n\
    \        }\n        int j = i + 1;\n        while(j < word.length)\n        {\n\
    \            if(vowels.find(word[j]) != -1)\n            {\n                if(j\
    \ - i < min_distance)\n                {\n                    min_distance = j\
    \ - i;\n                    result = word[j..$];\n                }\n        \
    \        break;\n            }\n            j++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphciyyxt7.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphciyyxt7.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmphciyyxt7.d(35): Error: cannot implicitly convert\
    \ expression `i + 1LU` of type `ulong` to `int`\\n/tmp/tmphciyyxt7.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmphciyyxt7.d(42): Error: cannot\
    \ implicitly convert expression `cast(ulong)j - i` of type `ulong` to `int`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphciyyxt7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(consonants.find(c) != -1)\n      \
    \  {\n            int j = i + 1;\n            while(j < word.length)\n       \
    \     {\n                if(vowels.find(word[j]) != -1)\n                {\n \
    \                   distance = j - i;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = word[j];\n                    }\n             \
    \       break;\n                }\n                j++;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg8zya1q5.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpg8zya1q5.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpg8zya1q5.d(34): Error: cannot implicitly convert\
    \ expression `i + 1LU` of type `ulong` to `int`\\n/tmp/tmpg8zya1q5.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpg8zya1q5.d(39): Error: cannot\
    \ implicitly convert expression `cast(ulong)j - i` of type `ulong` to `int`\\\
    n/tmp/tmpg8zya1q5.d(43): Error: cannot implicitly convert expression `word[cast(ulong)j]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpg8zya1q5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int closest = -1;\n    int distance = int.max;\n    for (int i = word.length\
    \ - 1; i >= 0; i--)\n    {\n        if (vowels.canFind(word[i]))\n        {\n\
    \            int d = word.length - i;\n            if (d < distance)\n       \
    \     {\n                distance = d;\n                closest = i;\n       \
    \     }\n        }\n    }\n    return closest == -1 ? \"\" : word[closest..closest];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ck8cefs.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp_ck8cefs.d(30): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmp_ck8cefs.d(32): Error: cannot implicitly\
    \ convert expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ck8cefs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int index_vowel = 0;\n    int index_consonant\
    \ = 0;\n    int index_vowel_temp = 0;\n    int index_consonant_temp = 0;\n   \
    \ int distance = 0;\n    int distance_temp = 0;\n    foreach(i; 0 .. word.length)\n\
    \    {\n        if(consonants.canFind(word[i]))\n        {\n            index_consonant_temp\
    \ = i;\n            foreach(j; i .. word.length)\n            {\n            \
    \    if(vowels.canFind(word[j]))\n                {\n                    index_vowel_temp\
    \ = j;\n                    distance_temp = index_vowel_temp - index_consonant_temp;\n\
    \                    if(distance_temp > distance)\n                    {\n   \
    \                     distance = distance_temp;\n                        index_vowel\
    \ = index_vowel_temp;\n                        index_consonant = index_consonant_temp;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if(distance > 0)\n    {\n        result = word[index_vowel];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl3tlgguh.d(37): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpl3tlgguh.d(39): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmpl3tlgguh.d(42): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpl3tlgguh.d(44): Error: cannot implicitly convert expression\
    \ `j` of type `ulong` to `int`\\n/tmp/tmpl3tlgguh.d(58): Error: cannot implicitly\
    \ convert expression `word[cast(ulong)index_vowel]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl3tlgguh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_dist = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ dist = word.length - i;\n            if(consonants.find(word[i-1]) != -1 &&\
    \ consonants.find(word[i+1]) != -1)\n            {\n                if(dist <\
    \ min_dist)\n                {\n                    min_dist = dist;\n       \
    \             index = i;\n                }\n            }\n        }\n    }\n\
    \    if(index != 0)\n    {\n        result = word[index];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd9q8s3fp.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpd9q8s3fp.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpd9q8s3fp.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpd9q8s3fp.d(35):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpd9q8s3fp.d(35): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpd9q8s3fp.d(40): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpd9q8s3fp.d(47):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpd9q8s3fp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int i = word.length - 1;\n    while (i >= 0)\n    {\n  \
    \      if (consonants.find(word[i]) != -1)\n        {\n            if (i == word.length\
    \ - 1)\n            {\n                i--;\n                continue;\n     \
    \       }\n            if (vowels.find(word[i + 1]) != -1)\n            {\n  \
    \              result = word[i + 1];\n                break;\n            }\n\
    \        }\n        i--;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpioqxfqz1.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpioqxfqz1.d(31): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpioqxfqz1.d(38): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpioqxfqz1.d(40): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)(i + 1)]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpioqxfqz1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, ch; word)\n    {\n        if(vowels.canFind(ch))\n\
    \        {\n            int j = i;\n            while(j >= 0 && consonants.canFind(word[j]))\n\
    \            {\n                j--;\n            }\n            if(j >= 0)\n\
    \            {\n                j = i;\n                while(j < word.length\
    \ && consonants.canFind(word[j]))\n                {\n                    j++;\n\
    \                }\n                if(j < word.length)\n                {\n \
    \                   distance = j - i;\n                    if(distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     index = i;\n                    }\n                }\n \
    \           }\n        }\n    }\n    if(index != 0)\n    {\n        result = word[index..$];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6o4e7mzm.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp6o4e7mzm.d(33): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp6o4e7mzm.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmp6o4e7mzm.d(36): Error: no\
    \ property `canFind` for type `string`\\n/tmp/tmp6o4e7mzm.d(42): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp6o4e7mzm.d(43):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmp6o4e7mzm.d(49): Error:\
    \ cannot implicitly convert expression `cast(ulong)j - i` of type `ulong` to `int`\\\
    n/tmp/tmp6o4e7mzm.d(53): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6o4e7mzm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (i < word.length - 1 && vowels.find(word[i +\
    \ 1]) == -1)\n            {\n                if (min_distance > i)\n         \
    \       {\n                    min_distance = i;\n                    result =\
    \ word[i];\n                }\n            }\n            if (i > 0 && vowels.find(word[i\
    \ - 1]) == -1)\n            {\n                if (min_distance > word.length\
    \ - i)\n                {\n                    min_distance = word.length - i;\n\
    \                    result = word[i];\n                }\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkyuw2z8x.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpkyuw2z8x.d(28): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpkyuw2z8x.d(30):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpkyuw2z8x.d(32): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpkyuw2z8x.d(37): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\n/tmp/tmpkyuw2z8x.d(40): Error: no property `find` for type `string`\\\
    n/tmp/tmpkyuw2z8x.d(44): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpkyuw2z8x.d(45): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkyuw2z8x.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    foreach(i, c; word)\n    {\n       \
    \ if(consonants.find(c) != -1)\n        {\n            index = i;\n          \
    \  break;\n        }\n    }\n    foreach(i, c; word[index..$])\n    {\n      \
    \  if(vowels.find(c) != -1)\n        {\n            result = c;\n            break;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9li72bo8.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmp9li72bo8.d(33): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmp9li72bo8.d(39): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp9li72bo8.d(41): Error: cannot implicitly convert expression\
    \ `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp9li72bo8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ res = \"\";\n    int min_dist = word.length;\n    foreach(i, v; word)\n    {\n\
    \        if(vowels.find(v) != -1)\n        {\n            int dist = word.length\
    \ - i;\n            if(dist < min_dist)\n            {\n                if(i ==\
    \ 0)\n                {\n                    if(consonants.find(word[i+1]) !=\
    \ -1)\n                    {\n                        res = v;\n             \
    \           min_dist = dist;\n                    }\n                }\n     \
    \           else if(i == word.length - 1)\n                {\n               \
    \     if(consonants.find(word[i-1]) != -1)\n                    {\n          \
    \              res = v;\n                        min_dist = dist;\n          \
    \          }\n                }\n                else\n                {\n   \
    \                 if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        res = v;\n          \
    \              min_dist = dist;\n                    }\n                }\n  \
    \          }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjlyd6fi6.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjlyd6fi6.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpjlyd6fi6.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpjlyd6fi6.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpjlyd6fi6.d(40): Error:\
    \ cannot implicitly convert expression `v` of type `immutable(char)` to `string`\\\
    n/tmp/tmpjlyd6fi6.d(46): Error: no property `find` for type `string`\\n/tmp/tmpjlyd6fi6.d(48):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\n/tmp/tmpjlyd6fi6.d(54): Error: no property `find` for type `string`\\\
    n/tmp/tmpjlyd6fi6.d(54): Error: no property `find` for type `string`\\n/tmp/tmpjlyd6fi6.d(56):\
    \ Error: cannot implicitly convert expression `v` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjlyd6fi6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq222rsoi.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpq222rsoi.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpq222rsoi.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpq222rsoi.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq222rsoi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = 0;\n    int closest_vowel_distance\
    \ = 0;\n    int word_length = word.length;\n    int word_index = 0;\n    int vowel_index\
    \ = 0;\n    int vowel_distance = 0;\n    int consonant_index = 0;\n    int consonant_distance\
    \ = 0;\n    int last_consonant_index = 0;\n    int last_consonant_distance = 0;\n\
    \    int last_vowel_index = 0;\n    int last_vowel_distance = 0;\n    int vowel_count\
    \ = 0;\n    int consonant_count = 0;\n    int last_consonant_count = 0;\n    int\
    \ last_vowel_count = 0;\n    bool found_vowel = false;\n    bool found_consonant\
    \ = false;\n    bool found_last_vowel = false;\n    bool found_last_consonant\
    \ = false;\n    bool found_closest_vowel = false;\n    bool found_closest_consonant\
    \ = false;\n    bool found_last_closest_vowel = false;\n    bool found_last_closest_consonant\
    \ = false;\n    bool found_last_closest_vowel_distance = false;\n    bool found_last_closest_consonant_distance\
    \ = false;\n    bool found_closest_vowel_distance = false;\n    bool found_closest_consonant_distance\
    \ = false;\n    bool found_last_vowel_distance = false;\n    bool found_last_consonant_distance\
    \ = false;\n    bool found_vowel_distance = false;\n    bool found_consonant_distance\
    \ = false;\n    bool found_last_vowel_index = false;\n    bool found_last_consonant_index\
    \ = false\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqec8xoip.d(62): Error: semicolon expected, not `unittest`\\n/tmp/tmpqec8xoip.d(62):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqec8xoip.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int closest_index = 0;\n    int closest_distance = 0;\n\
    \    int distance = 0;\n    int index = 0;\n    foreach(vowel; vowels)\n    {\n\
    \        index = word.find(vowel);\n        if(index != -1)\n        {\n     \
    \       distance = word.length - index;\n            if(distance > closest_distance)\n\
    \            {\n                closest_distance = distance;\n               \
    \ closest_index = index;\n                result = vowel;\n            }\n   \
    \     }\n    }\n    if(closest_index == 0)\n    {\n        return \"\";\n    }\n\
    \    else\n    {\n        if(consonants.find(word[closest_index - 1]) != -1 &&\
    \ consonants.find(word[closest_index + 1]) != -1)\n        {\n            return\
    \ result;\n        }\n        else\n        {\n            return \"\";\n    \
    \    }\n    }\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n  \
    \  assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd83xp1m7.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpd83xp1m7.d(37): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)index` of type `ulong` to `int`\\n/tmp/tmpd83xp1m7.d(42): Error:\
    \ cannot implicitly convert expression `vowel` of type `immutable(char)` to `string`\\\
    n/tmp/tmpd83xp1m7.d(52): Error: no property `find` for type `string`\\n/tmp/tmpd83xp1m7.d(52):\
    \ Error: no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpd83xp1m7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe_pfcxgh.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe_pfcxgh.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpe_pfcxgh.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpe_pfcxgh.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_pfcxgh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, char c; word)\n    {\n        if(consonants.find(c) != -1)\n   \
    \     {\n            foreach(j, char v; vowels)\n            {\n             \
    \   if(word.find(v, i) != -1)\n                {\n                    if(word.find(v,\
    \ i) - i < min_distance)\n                    {\n                        min_distance\
    \ = word.find(v, i) - i;\n                        index = word.find(v, i);\n \
    \                       result = v;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcf6v02ks.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpcf6v02ks.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpcf6v02ks.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpcf6v02ks.d(38): Error: no property `find` for type `string`\\\
    n/tmp/tmpcf6v02ks.d(40): Error: no property `find` for type `string`\\n/tmp/tmpcf6v02ks.d(41):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpcf6v02ks.d(42): Error:\
    \ cannot implicitly convert expression `v` of type `char` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcf6v02ks.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = -1;\n    int distance = 0;\n    int\
    \ min_distance = word.length;\n    for (int i = 0; i < word.length; i++)\n   \
    \ {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i > 0\
    \ && i < word.length - 1)\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            distance = word.length - i;\n                    if (distance < min_distance)\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     index = i;\n                    }\n                }\n \
    \           }\n        }\n    }\n    if (index != -1)\n    {\n        result =\
    \ word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpshl3itsx.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpshl3itsx.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpshl3itsx.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpshl3itsx.d(36): Error: no property `find` for type `string`\\\
    n/tmp/tmpshl3itsx.d(38): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpshl3itsx.d(50): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpshl3itsx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n \
    \           int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                if(i > 0 && consonants.find(word[i-1]) != -1)\n\
    \                {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        index = i;\n                    }\n                }\n\
    \            }\n        }\n    }\n    if(index != 0)\n    {\n        result =\
    \ word[index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9nr2wl_k.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9nr2wl_k.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp9nr2wl_k.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp9nr2wl_k.d(37):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp9nr2wl_k.d(39): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp9nr2wl_k.d(42): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp9nr2wl_k.d(50):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9nr2wl_k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            if(i > 0 && consonants.find(word[i-1]) != -1)\n            {\n  \
    \              if(i < word.length - 1 && consonants.find(word[i+1]) != -1)\n \
    \               {\n                    distance = i;\n                    if(distance\
    \ < minDistance)\n                    {\n                        minDistance =\
    \ distance;\n                        result = c;\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprn44hi9x.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprn44hi9x.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprn44hi9x.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmprn44hi9x.d(36): Error: no property `find` for type `string`\\\
    n/tmp/tmprn44hi9x.d(38): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmprn44hi9x.d(42): Error: cannot implicitly convert\
    \ expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmprn44hi9x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    bool found = false;\n\
    \    while (index >= 0 && !found)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (index == 0)\n            {\n            \
    \    result = \"\";\n                found = true;\n            }\n          \
    \  else if (vowels.find(word[index - 1]) == -1)\n            {\n             \
    \   result = word[index];\n                found = true;\n            }\n    \
    \    }\n        index--;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqu1h0y1c.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpqu1h0y1c.d(31): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpqu1h0y1c.d(38): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpqu1h0y1c.d(40): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqu1h0y1c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, vowel; word)\n\
    \    {\n        if(vowels.canFind(vowel))\n        {\n            int distance\
    \ = 0;\n            foreach(j, consonant; word[i..$])\n            {\n       \
    \         if(consonants.canFind(consonant))\n                {\n             \
    \       distance = j;\n                    break;\n                }\n       \
    \     }\n            if(distance < min_distance)\n            {\n            \
    \    min_distance = distance;\n                result = vowel;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa2ce9446.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpa2ce9446.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpa2ce9446.d(36): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpa2ce9446.d(38): Error: cannot implicitly convert expression\
    \ `j` of type `ulong` to `int`\\n/tmp/tmpa2ce9446.d(45): Error: cannot implicitly\
    \ convert expression `vowel` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa2ce9446.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min = word.length;\n    foreach(i,\
    \ ch; word)\n    {\n        if(vowels.canFind(ch))\n        {\n            if(i\
    \ > 0 && consonants.canFind(word[i-1]) && i < word.length-1 && consonants.canFind(word[i+1]))\n\
    \            {\n                if(i < min)\n                {\n             \
    \       min = i;\n                    result = ch;\n                }\n      \
    \      }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdrjqccni.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpdrjqccni.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpdrjqccni.d(34): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpdrjqccni.d(34): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmpdrjqccni.d(38): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmpdrjqccni.d(39): Error: cannot implicitly\
    \ convert expression `ch` of type `immutable(char)` to `string`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdrjqccni.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ distance = word.length - i;\n            if(distance > min_distance)\n     \
    \       {\n                index = i;\n                min_distance = distance;\n\
    \            }\n        }\n    }\n    if(min_distance > 1)\n    {\n        if(consonants.find(word[index-1])\
    \ != -1 && consonants.find(word[index+1]) != -1)\n        {\n            result\
    \ = word[index..index];\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv8nu5e6q.d(32): Error: no property `find` for type `string`\\\
    n/tmp/tmpv8nu5e6q.d(34): Error: cannot implicitly convert expression `word.length\
    \ - i` of type `ulong` to `int`\\n/tmp/tmpv8nu5e6q.d(37): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\n/tmp/tmpv8nu5e6q.d(44): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpv8nu5e6q.d(44): Error: no property\
    \ `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpv8nu5e6q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    auto vowels = \"aeiouAEIOU\";\n    auto\
    \ consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    auto closest_vowel\
    \ = \"\";\n    auto closest_vowel_distance = word.length;\n    auto word_length\
    \ = word.length;\n    auto word_reverse = word.dup.reverse;\n    foreach(i, c;\
    \ word_reverse)\n    {\n        if(consonants.canFind(c))\n        {\n       \
    \     foreach(j, v; word_reverse[i..$])\n            {\n                if(vowels.canFind(v))\n\
    \                {\n                    if(j < closest_vowel_distance)\n     \
    \               {\n                        closest_vowel_distance = j;\n     \
    \                   closest_vowel = v;\n                    }\n              \
    \      break;\n                }\n            }\n        }\n    }\n    return\
    \ closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf4sp99g1.d(30): Error: template `std.typecons.reverse` cannot\
    \ deduce function from argument types `!()(char[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpf4sp99g1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i == 0)\n                {\n                    if(consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \                else if(i == word.length - 1)\n                {\n          \
    \          if(consonants.find(word[i-1]) != -1)\n                    {\n     \
    \                   min_distance = distance;\n                        result =\
    \ c;\n                    }\n                }\n                else\n       \
    \         {\n                    if(consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp347xjkin.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp347xjkin.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp347xjkin.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp347xjkin.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp347xjkin.d(41): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    n/tmp/tmp347xjkin.d(46): Error: no property `find` for type `string`\\n/tmp/tmp347xjkin.d(49):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\n/tmp/tmp347xjkin.d(54): Error: no property `find` for type `string`\\\
    n/tmp/tmp347xjkin.d(54): Error: no property `find` for type `string`\\n/tmp/tmp347xjkin.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp347xjkin.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int closest_vowel_index = -1;\n    int closest_vowel_distance = -1;\n    int\
    \ word_length = word.length;\n    for (int i = 0; i < word_length; i++)\n    {\n\
    \        if (vowels.find(word[i]) != -1)\n        {\n            if (i == 0 ||\
    \ i == word_length - 1)\n            {\n                continue;\n          \
    \  }\n            else\n            {\n                if (vowels.find(word[i\
    \ - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n                {\n        \
    \            if (closest_vowel_distance == -1 || abs(word_length - i) < closest_vowel_distance)\n\
    \                    {\n                        closest_vowel_distance = abs(word_length\
    \ - i);\n                        closest_vowel_index = i;\n                  \
    \  }\n                }\n            }\n        }\n    }\n    if (closest_vowel_index\
    \ == -1)\n    {\n        return \"\";\n    }\n    else\n    {\n        return\
    \ word[closest_vowel_index..closest_vowel_index];\n    }\n}\nunittest\n{\n   \
    \ alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2lvzmyp0.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp2lvzmyp0.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp2lvzmyp0.d(39): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp2lvzmyp0.d(39): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2lvzmyp0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8herg16f.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp8herg16f.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp8herg16f.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp8herg16f.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8herg16f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = int.max;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.canFind(c))\n        {\n            int distance = 0;\n\
    \            int j = i;\n            while(j >= 0 && consonants.canFind(word[j]))\n\
    \            {\n                j--;\n                distance++;\n          \
    \  }\n            j = i;\n            while(j < word.length && consonants.canFind(word[j]))\n\
    \            {\n                j++;\n                distance++;\n          \
    \  }\n            if(distance < min_distance)\n            {\n               \
    \ min_distance = distance;\n                result = c;\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbafo0mtn.d(31): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpbafo0mtn.d(34): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmpbafo0mtn.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpbafo0mtn.d(40): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmpbafo0mtn.d(41): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpbafo0mtn.d(49): Error: cannot implicitly convert\
    \ expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpbafo0mtn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpymx0s6g6.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpymx0s6g6.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpymx0s6g6.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpymx0s6g6.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpymx0s6g6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int index = -1;\n    int min_distance = word.length;\n    foreach(i, c; word)\
    \ {\n        if(vowels.canFind(c)) {\n            int distance = word.length -\
    \ i;\n            if(distance < min_distance) {\n                min_distance\
    \ = distance;\n                index = i;\n            }\n        }\n    }\n \
    \   if(index == -1) {\n        return \"\";\n    }\n    return word[index..$];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp41njzoki.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp41njzoki.d(29): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp41njzoki.d(30): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp41njzoki.d(33):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp41njzoki.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int distance = 0;\n    int minDistance\
    \ = word.length;\n    for (int i = 0; i < word.length; i++)\n    {\n        if\
    \ (vowels.find(word[i]) != -1)\n        {\n            if (i > 0 && i < word.length\
    \ - 1)\n            {\n                if (vowels.find(word[i-1]) == -1 && vowels.find(word[i+1])\
    \ == -1)\n                {\n                    distance = word.length - i;\n\
    \                    if (distance < minDistance)\n                    {\n    \
    \                    minDistance = distance;\n                        index =\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    if (index != 0)\n    {\n        result = word[index];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgwkr0g3k.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgwkr0g3k.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpgwkr0g3k.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpgwkr0g3k.d(36): Error: no property `find` for type `string`\\\
    n/tmp/tmpgwkr0g3k.d(38): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpgwkr0g3k.d(50): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgwkr0g3k.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int distance = 0;\n    int min_distance\
    \ = word.length;\n    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n\
    \        {\n            if(consonants.canFind(word[i - 1]) && consonants.canFind(word[i\
    \ + 1]))\n            {\n                distance = abs(i - word.length / 2);\n\
    \                if(distance < min_distance)\n                {\n            \
    \        min_distance = distance;\n                    index = i;\n          \
    \      }\n            }\n        }\n    }\n    if(index != 0)\n    {\n       \
    \ result = word[index..index];\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3cdugro8.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp3cdugro8.d(33): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp3cdugro8.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmp3cdugro8.d(35): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmp3cdugro8.d(37): Error: cannot implicitly convert expression\
    \ `abs(i - word.length / 2LU)` of type `ulong` to `int`\\n/tmp/tmp3cdugro8.d(41):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3cdugro8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_dist = word.length;\n    int dist;\n   \
    \ foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n     \
    \       dist = word.length - i;\n            if(dist < min_dist)\n           \
    \ {\n                min_dist = dist;\n                result = c;\n         \
    \   }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprcgywv0v.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprcgywv0v.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmprcgywv0v.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmprcgywv0v.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprcgywv0v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int minDistance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n\
    \            int left = i;\n            int right = i;\n            while(left\
    \ >= 0 && consonants.find(word[left]) != -1)\n            {\n                left--;\n\
    \            }\n            while(right < word.length && consonants.find(word[right])\
    \ != -1)\n            {\n                right++;\n            }\n           \
    \ if(left >= 0 && right < word.length)\n            {\n                distance\
    \ = right - left - 1;\n                if(distance < minDistance)\n          \
    \      {\n                    minDistance = distance;\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjg2siqf.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmphjg2siqf.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmphjg2siqf.d(34): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmphjg2siqf.d(35): Error: cannot\
    \ implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmphjg2siqf.d(36):\
    \ Error: no property `find` for type `string`\\n/tmp/tmphjg2siqf.d(40): Error:\
    \ no property `find` for type `string`\\n/tmp/tmphjg2siqf.d(50): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjg2siqf.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp55rtzp4y.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp55rtzp4y.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp55rtzp4y.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp55rtzp4y.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55rtzp4y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length;\n    while(index > 0)\n\
    \    {\n        if(vowels.canFind(word[index]))\n        {\n            if(index\
    \ == word.length-1)\n            {\n                if(vowels.canFind(word[index-1]))\n\
    \                {\n                    index--;\n                    continue;\n\
    \                }\n                else\n                {\n                \
    \    result = word[index];\n                    break;\n                }\n  \
    \          }\n            else\n            {\n                if(vowels.canFind(word[index-1]))\n\
    \                {\n                    index--;\n                    continue;\n\
    \                }\n                else\n                {\n                \
    \    result = word[index];\n                    break;\n                }\n  \
    \          }\n        }\n        index--;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzce7wt0q.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpzce7wt0q.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpzce7wt0q.d(34): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmpzce7wt0q.d(41): Error: cannot implicitly convert expression\
    \ `word[cast(ulong)index]` of type `immutable(char)` to `string`\\n/tmp/tmpzce7wt0q.d(47):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpzce7wt0q.d(54): Error:\
    \ cannot implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzce7wt0q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp0eiyqr3.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpp0eiyqr3.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpp0eiyqr3.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpp0eiyqr3.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp0eiyqr3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   if(i == 0)\n                {\n                    if(consonants.canFind(word[i+1]))\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \                else if(i == word.length - 1)\n                {\n          \
    \          if(consonants.canFind(word[i-1]))\n                    {\n        \
    \                min_distance = distance;\n                        result = c;\n\
    \                    }\n                }\n                else\n            \
    \    {\n                    if(consonants.canFind(word[i-1]) && consonants.canFind(word[i+1]))\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcjgi2_8o.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpcjgi2_8o.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpcjgi2_8o.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpcjgi2_8o.d(38):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpcjgi2_8o.d(41): Error:\
    \ cannot implicitly convert expression `c` of type `immutable(char)` to `string`\\\
    n/tmp/tmpcjgi2_8o.d(46): Error: no property `canFind` for type `string`\\n/tmp/tmpcjgi2_8o.d(49):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\n/tmp/tmpcjgi2_8o.d(54): Error: no property `canFind` for type `string`\\\
    n/tmp/tmpcjgi2_8o.d(54): Error: no property `canFind` for type `string`\\n/tmp/tmpcjgi2_8o.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcjgi2_8o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    int\
    \ n = word.length;\n    int min_dist = n;\n    string closest_vowel = \"\";\n\
    \    for (int i = 0; i < n; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n\
    \        {\n            int dist = n - i;\n            if (dist < min_dist)\n\
    \            {\n                min_dist = dist;\n                closest_vowel\
    \ = word[i..$];\n            }\n        }\n    }\n    return closest_vowel;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgt87dcmu.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpgt87dcmu.d(31): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgt87dcmu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int closest = word.length;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n    \
    \    {\n            if (i > 0 && i < word.length - 1)\n            {\n       \
    \         if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n\
    \                {\n                    if (abs(i - word.length) < closest)\n\
    \                    {\n                        closest = abs(i - word.length);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7zb2sgq3.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp7zb2sgq3.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp7zb2sgq3.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp7zb2sgq3.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmp7zb2sgq3.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmp7zb2sgq3.d(39): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7zb2sgq3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    int distance\
    \ = 0;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            distance = word.length - i;\n            if (distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = word[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk9224rb8.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpk9224rb8.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpk9224rb8.d(33): Error: cannot implicitly convert\
    \ expression `word.length - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpk9224rb8.d(37):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk9224rb8.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = 0;\n            int right_distance = 0;\n            int j = i;\n        \
    \    while(j >= 0 && consonants.find(word[j]) != -1)\n            {\n        \
    \        left_distance++;\n                j--;\n            }\n            j\
    \ = i;\n            while(j < word.length && consonants.find(word[j]) != -1)\n\
    \            {\n                right_distance++;\n                j++;\n    \
    \        }\n            if(left_distance != 0 && right_distance != 0)\n      \
    \      {\n                if(min_distance > min(left_distance, right_distance))\n\
    \                {\n                    min_distance = min(left_distance, right_distance);\n\
    \                    result = c;\n                }\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeleqpwuy.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpeleqpwuy.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpeleqpwuy.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `ulong` to `int`\\n/tmp/tmpeleqpwuy.d(36): Error: no\
    \ property `find` for type `string`\\n/tmp/tmpeleqpwuy.d(41): Error: cannot implicitly\
    \ convert expression `i` of type `ulong` to `int`\\n/tmp/tmpeleqpwuy.d(42): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpeleqpwuy.d(49): Error: undefined\
    \ identifier `min`, did you mean function `main`?\\n/tmp/tmpeleqpwuy.d(51): Error:\
    \ undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpeleqpwuy.d(52):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeleqpwuy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length;\n    bool found_vowel = false;\n\
    \    bool found_consonant = false;\n    while (index > 0)\n    {\n        if (found_vowel\
    \ && found_consonant)\n        {\n            return result;\n        }\n    \
    \    if (vowels.find(word[index]) != -1)\n        {\n            found_vowel =\
    \ true;\n            result = word[index];\n        }\n        else if (consonants.find(word[index])\
    \ != -1)\n        {\n            found_consonant = true;\n        }\n        index--;\n\
    \    }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0zr4wqdb.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0zr4wqdb.d(37): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp0zr4wqdb.d(40): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    n/tmp/tmp0zr4wqdb.d(42): Error: no property `find` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0zr4wqdb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   if(i > 0 && consonants.canFind(word[i-1]))\n                {\n          \
    \          if(i < word.length - 1 && consonants.canFind(word[i+1]))\n        \
    \            {\n                        min_distance = distance;\n           \
    \             result = c;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwdyr7yz7.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpwdyr7yz7.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpwdyr7yz7.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpwdyr7yz7.d(36):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpwdyr7yz7.d(38): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpwdyr7yz7.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwdyr7yz7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance\
    \ = -1;\n    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            int distance = word.length - i;\n           \
    \ if (closest_vowel_distance == -1 || distance < closest_vowel_distance)\n   \
    \         {\n                closest_vowel_distance = distance;\n            \
    \    closest_vowel_index = i;\n                closest_vowel = word[i..$];\n \
    \           }\n        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb7_7w0ix.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpb7_7w0ix.d(33): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpb7_7w0ix.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && consonants.find(word[i-1]) != -1)\n\
    \            {\n                distance = 1;\n                while (i+distance\
    \ < word.length && consonants.find(word[i+distance]) != -1)\n                {\n\
    \                    distance++;\n                }\n                if (distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i..$];\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8es054s3.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp8es054s3.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp8es054s3.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp8es054s3.d(37): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8es054s3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          int distance = word.length - i;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                index\
    \ = i;\n            }\n        }\n    }\n    if(min_distance != word.length)\n\
    \    {\n        result = word[index..$];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaqg4dda9.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpaqg4dda9.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpaqg4dda9.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpaqg4dda9.d(37):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaqg4dda9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i == 0 || i == word.length - 1)\n       \
    \     {\n                continue;\n            }\n            else\n        \
    \    {\n                if (consonants.find(word[i-1]) != -1 && consonants.find(word[i+1])\
    \ != -1)\n                {\n                    distance = word.length - i;\n\
    \                    if (distance < min_distance)\n                    {\n   \
    \                     min_distance = distance;\n                        result\
    \ = word[i];\n                    }\n                }\n            }\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprslouqxf.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmprslouqxf.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmprslouqxf.d(40): Error: no property `find` for type\
    \ `string`\\n/tmp/tmprslouqxf.d(40): Error: no property `find` for type `string`\\\
    n/tmp/tmprslouqxf.d(42): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmprslouqxf.d(46): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprslouqxf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9me_i0t0.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp9me_i0t0.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp9me_i0t0.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp9me_i0t0.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9me_i0t0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int last_vowel_index = -1;\n    int last_consonant_index\
    \ = -1;\n    int min_distance = word.length;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  last_vowel_index = i;\n            if (last_consonant_index != -1)\n      \
    \      {\n                if (last_vowel_index - last_consonant_index < min_distance)\n\
    \                {\n                    min_distance = last_vowel_index - last_consonant_index;\n\
    \                    result = word[last_vowel_index];\n                }\n   \
    \         }\n        }\n        else\n        {\n            last_consonant_index\
    \ = i;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptqouyvlg.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmptqouyvlg.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmptqouyvlg.d(40): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)last_vowel_index]` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptqouyvlg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_dist = word.length;\n    foreach(i, c; word)\n \
    \   {\n        if(vowels.find(c) != -1)\n        {\n            int dist_left\
    \ = 0;\n            int dist_right = 0;\n            for(int j = i - 1; j >= 0;\
    \ j--)\n            {\n                if(consonants.find(word[j]) != -1)\n  \
    \              {\n                    dist_left = i - j;\n                   \
    \ break;\n                }\n            }\n            for(int j = i + 1; j <\
    \ word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    dist_right = j - i;\n       \
    \             break;\n                }\n            }\n            if(dist_left\
    \ != 0 && dist_right != 0)\n            {\n                int dist = min(dist_left,\
    \ dist_right);\n                if(dist < min_dist)\n                {\n     \
    \               min_dist = dist;\n                    result = c;\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj9ntfut5.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpj9ntfut5.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpj9ntfut5.d(35): Error: cannot implicitly convert\
    \ expression `i - 1LU` of type `ulong` to `int`\\n/tmp/tmpj9ntfut5.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpj9ntfut5.d(39): Error: cannot\
    \ implicitly convert expression `i - cast(ulong)j` of type `ulong` to `int`\\\
    n/tmp/tmpj9ntfut5.d(43): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmpj9ntfut5.d(45): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpj9ntfut5.d(47): Error: cannot implicitly convert\
    \ expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmpj9ntfut5.d(53):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpj9ntfut5.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj9ntfut5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    for (int i = 0; i <\
    \ word.length; i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n\
    \            if (i > 0 && i < word.length - 1)\n            {\n              \
    \  if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i + 1]) == -1)\n   \
    \             {\n                    if (min_distance > abs(i - word.length))\n\
    \                    {\n                        min_distance = abs(i - word.length);\n\
    \                        result = word[i];\n                    }\n          \
    \      }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyd76qix7.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpyd76qix7.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpyd76qix7.d(34): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpyd76qix7.d(34): Error: no property `find` for type `string`\\\
    n/tmp/tmpyd76qix7.d(38): Error: cannot implicitly convert expression `abs(cast(ulong)i\
    \ - word.length)` of type `ulong` to `int`\\n/tmp/tmpyd76qix7.d(39): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)i]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyd76qix7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsubqz5y6.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpsubqz5y6.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpsubqz5y6.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpsubqz5y6.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsubqz5y6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int min_dist = word.length;\n    string closest_vowel = \"\";\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int dist\
    \ = word.length - i;\n            if(dist < min_dist)\n            {\n       \
    \         min_dist = dist;\n                closest_vowel = c;\n            }\n\
    \        }\n    }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6qsub86u.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp6qsub86u.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp6qsub86u.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp6qsub86u.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6qsub86u.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.indexOf(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                int left = i - 1;\n                int right = i + 1;\n     \
    \           if(left >= 0 && right < word.length)\n                {\n        \
    \            if(consonants.indexOf(word[left]) != -1 && consonants.indexOf(word[right])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5n7v7_6h.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5n7v7_6h.d(31): Error: no property `indexOf`\
    \ for type `string`\\n/tmp/tmp5n7v7_6h.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp5n7v7_6h.d(36):\
    \ Error: cannot implicitly convert expression `i - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmp5n7v7_6h.d(37): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmp5n7v7_6h.d(40): Error: no property `indexOf`\
    \ for type `string`\\n/tmp/tmp5n7v7_6h.d(40): Error: no property `indexOf` for\
    \ type `string`\\n/tmp/tmp5n7v7_6h.d(43): Error: cannot implicitly convert expression\
    \ `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5n7v7_6h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int word_len = word.length;\n    string result = \"\";\n    int distance =\
    \ 0;\n    int min_distance = word_len;\n    for (int i = 0; i < word_len; i++)\n\
    \    {\n        if (vowels.find(word[i]) != -1)\n        {\n            if (i\
    \ == 0)\n            {\n                continue;\n            }\n           \
    \ else if (i == word_len - 1)\n            {\n                continue;\n    \
    \        }\n            else if (vowels.find(word[i-1]) != -1)\n            {\n\
    \                continue;\n            }\n            else if (vowels.find(word[i+1])\
    \ != -1)\n            {\n                continue;\n            }\n          \
    \  else\n            {\n                distance = word_len - i;\n           \
    \     if (distance < min_distance)\n                {\n                    min_distance\
    \ = distance;\n                    result = word[i];\n                }\n    \
    \        }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpav8uosfo.d(26): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpav8uosfo.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpav8uosfo.d(42): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpav8uosfo.d(46): Error: no property `find` for type `string`\\\
    n/tmp/tmpav8uosfo.d(56): Error: cannot implicitly convert expression `word[cast(ulong)i]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpav8uosfo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = word.length;\n    int index = 0;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && i < word.length - 1)\n            {\n                if(!vowels.canFind(word[i\
    \ - 1]) && !vowels.canFind(word[i + 1]))\n                {\n                \
    \    if(abs(i - word.length) < distance)\n                    {\n            \
    \            distance = abs(i - word.length);\n                        index =\
    \ i;\n                    }\n                }\n            }\n        }\n   \
    \ }\n    if(index != 0)\n    {\n        result = word[index .. index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1es9wps1.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp1es9wps1.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp1es9wps1.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmp1es9wps1.d(35): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmp1es9wps1.d(39): Error: cannot implicitly convert expression\
    \ `abs(i - word.length)` of type `ulong` to `int`\\n/tmp/tmp1es9wps1.d(40): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1es9wps1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    for (int i\
    \ = word.length - 1; i >= 0; i--)\n    {\n        if (vowels.find(word[i]) !=\
    \ -1)\n        {\n            if (i + 1 < word.length && vowels.find(word[i +\
    \ 1]) == -1)\n            {\n                if (i + 1 < min_distance)\n     \
    \           {\n                    min_distance = i + 1;\n                   \
    \ result = word[i..$];\n                }\n            }\n            if (i -\
    \ 1 >= 0 && vowels.find(word[i - 1]) == -1)\n            {\n                if\
    \ (word.length - i < min_distance)\n                {\n                    min_distance\
    \ = word.length - i;\n                    result = word[i..$];\n             \
    \   }\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8495n5pa.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp8495n5pa.d(28): Error: cannot implicitly\
    \ convert expression `word.length - 1LU` of type `ulong` to `int`\\n/tmp/tmp8495n5pa.d(30):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp8495n5pa.d(32): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp8495n5pa.d(40): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp8495n5pa.d(44): Error: cannot implicitly\
    \ convert expression `word.length - cast(ulong)i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8495n5pa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int\
    \ index = word.length - 1;\n    int vowel_index = -1;\n    while (index >= 0)\n\
    \    {\n        if (consonants.find(word[index]) != -1)\n        {\n         \
    \   if (vowel_index != -1)\n            {\n                return word[vowel_index..$];\n\
    \            }\n        }\n        else if (vowels.find(word[index]) != -1)\n\
    \        {\n            vowel_index = index;\n        }\n        index--;\n  \
    \  }\n    return \"\";\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7z6l9kt_.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp7z6l9kt_.d(31): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp7z6l9kt_.d(38): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7z6l9kt_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.find(c) != -1)\n        {\n            int\
    \ distance = word.length - i;\n            if(distance < min_distance)\n     \
    \       {\n                min_distance = distance;\n                result =\
    \ c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") ==\
    \ \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0i2eu8iv.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp0i2eu8iv.d(30): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp0i2eu8iv.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp0i2eu8iv.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0i2eu8iv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    int distance =\
    \ word.length;\n    int temp = 0;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            temp = index;\n            while (temp >= 0)\n\
    \            {\n                if (vowels.find(word[temp]) == -1)\n         \
    \       {\n                    if (distance > index - temp)\n                \
    \    {\n                        distance = index - temp;\n                   \
    \     result = word[index];\n                    }\n                    break;\n\
    \                }\n                temp--;\n            }\n        }\n      \
    \  index--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprby1rj8w.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmprby1rj8w.d(28): Error: cannot implicitly\
    \ convert expression `word.length` of type `ulong` to `int`\\n/tmp/tmprby1rj8w.d(32):\
    \ Error: no property `find` for type `string`\\n/tmp/tmprby1rj8w.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmprby1rj8w.d(42): Error: cannot\
    \ implicitly convert expression `word[cast(ulong)index]` of type `immutable(char)`\
    \ to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprby1rj8w.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && i < word.length - 1)\n            {\n                if(!vowels.canFind(word[i\
    \ - 1]) && !vowels.canFind(word[i + 1]))\n                {\n                \
    \    if(abs(i - word.length) < min_distance)\n                    {\n        \
    \                min_distance = abs(i - word.length);\n                      \
    \  index = i;\n                    }\n                }\n            }\n     \
    \   }\n    }\n    if(index != 0)\n    {\n        result = word[index];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7dtz3_yf.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp7dtz3_yf.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp7dtz3_yf.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmp7dtz3_yf.d(35): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmp7dtz3_yf.d(39): Error: cannot implicitly convert expression\
    \ `abs(i - word.length)` of type `ulong` to `int`\\n/tmp/tmp7dtz3_yf.d(40): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmp7dtz3_yf.d(48):\
    \ Error: cannot implicitly convert expression `word[cast(ulong)index]` of type\
    \ `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp7dtz3_yf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfwd8jcr5.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfwd8jcr5.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpfwd8jcr5.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpfwd8jcr5.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfwd8jcr5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   min_distance = distance;\n                result = c;\n            }\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmijfjw5k.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpmijfjw5k.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpmijfjw5k.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpmijfjw5k.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmijfjw5k.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int distance = int.max;\n    int index = 0;\n    foreach(i,\
    \ c; word)\n    {\n        if(consonants.find(c) != -1)\n        {\n         \
    \   foreach(j, v; vowels)\n            {\n                if(word.find(v, i) !=\
    \ -1)\n                {\n                    if(word.find(v, i) - i < distance)\n\
    \                    {\n                        distance = word.find(v, i) - i;\n\
    \                        index = word.find(v, i);\n                        result\
    \ = v;\n                    }\n                }\n            }\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjrvpk0ad.d(32): Error: no property `find` for type `string`\\\
    n/tmp/tmpjrvpk0ad.d(36): Error: no property `find` for type `string`\\n/tmp/tmpjrvpk0ad.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpjrvpk0ad.d(40): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpjrvpk0ad.d(41): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpjrvpk0ad.d(42): Error: cannot implicitly\
    \ convert expression `v` of type `immutable(char)` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjrvpk0ad.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          distance = word.length - i - 1;\n            if(distance < min_distance)\n\
    \            {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7_9e818f.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp7_9e818f.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp7_9e818f.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmp7_9e818f.d(37):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7_9e818f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  int index = word.length - 1;\n    while (index > 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            if (vowels.find(word[index - 1]) == -1)\n   \
    \         {\n                return word[index..$];\n            }\n        }\n\
    \        index--;\n    }\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg256_0xj.d(26): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpg256_0xj.d(29): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpg256_0xj.d(31): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg256_0xj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    int\
    \ index = -1;\n    int min_distance = -1;\n    for (int i = 0; i < word.length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int distance = word.length - i;\n            if (consonants.find(word[i-1])\
    \ != -1 && consonants.find(word[i+1]) != -1)\n            {\n                if\
    \ (min_distance == -1 || distance < min_distance)\n                {\n       \
    \             min_distance = distance;\n                    index = i;\n     \
    \           }\n            }\n        }\n    }\n    if (index == -1)\n       \
    \ return \"\";\n    return word[index..$];\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpngd87x90.d(31): Error: no property `find` for type `string`\\\
    n/tmp/tmpngd87x90.d(33): Error: cannot implicitly convert expression `word.length\
    \ - cast(ulong)i` of type `ulong` to `int`\\n/tmp/tmpngd87x90.d(34): Error: no\
    \ property `find` for type `string`\\n/tmp/tmpngd87x90.d(34): Error: no property\
    \ `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpngd87x90.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    int index = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c)\
    \ != -1)\n        {\n            distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               result = c;\n                index = i;\n            }\n     \
    \   }\n    }\n    if(index == 0 || index == word.length - 1)\n        return \"\
    \";\n    else\n        return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp21m097t2.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp21m097t2.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp21m097t2.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp21m097t2.d(38):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\n/tmp/tmp21m097t2.d(39): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp21m097t2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiou\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_index = 0;\n    int min_distance\
    \ = 0;\n    int distance = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n\
    \    int f = 0;\n    int g = 0;\n    int h = 0;\n    int ii = 0;\n    int jj =\
    \ 0;\n    int kk = 0;\n    int ll = 0;\n    int mm = 0;\n    int nn = 0;\n   \
    \ int oo = 0;\n    int pp = 0;\n    int qq = 0;\n    int rr = 0;\n    int ss =\
    \ 0;\n    int tt = 0;\n    int uu = 0;\n    int vv = 0;\n    int ww = 0;\n   \
    \ int xx = 0;\n    int yy = 0;\n    int zz = 0;\n    int aa = 0;\n    int bb =\
    \ 0;\n    int cc = 0;\n    int dd = 0;\n    int ee = 0;\n    int ff = 0;\n   \
    \ int gg = 0;\n    int hh = 0;\n    int iii = 0;\n    int jjj = 0;\n    int kkk\
    \ = 0;\n    int lll = 0;\n    int mmm = 0;\n    int nnn = 0;\n    int ooo = 0;\n\
    \    int ppp = 0;\n    int qqq = 0;\n    int rrr = 0;\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp97l_knkj.d(93): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp97l_knkj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    foreach(i, c; word)\n    {\n        if(vowels.canFind(c))\n        {\n  \
    \          if(i > 0 && i < word.length - 1)\n            {\n                if(!vowels.canFind(word[i-1])\
    \ && !vowels.canFind(word[i+1]))\n                {\n                    if(abs(word.length\
    \ - i) < min_distance)\n                    {\n                        min_distance\
    \ = abs(word.length - i);\n                        index = i;\n              \
    \      }\n                }\n            }\n        }\n    }\n    if(index !=\
    \ 0)\n    {\n        result = word[index..$];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp65krlo76.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp65krlo76.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp65krlo76.d(35): Error: no property `canFind` for\
    \ type `string`\\n/tmp/tmp65krlo76.d(35): Error: no property `canFind` for type\
    \ `string`\\n/tmp/tmp65krlo76.d(39): Error: cannot implicitly convert expression\
    \ `abs(word.length - i)` of type `ulong` to `int`\\n/tmp/tmp65krlo76.d(40): Error:\
    \ cannot implicitly convert expression `i` of type `ulong` to `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp65krlo76.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int distance = 0;\n    int minDistance = 0;\n  \
    \  int index = 0;\n    foreach(i, c; word)\n    {\n        if(vowels.find(c) !=\
    \ -1)\n        {\n            if(i != 0 && i != word.length - 1)\n           \
    \ {\n                if(vowels.find(word[i - 1]) == -1 && vowels.find(word[i +\
    \ 1]) == -1)\n                {\n                    distance = abs(i - word.length);\n\
    \                    if(minDistance == 0 || distance < minDistance)\n        \
    \            {\n                        minDistance = distance;\n            \
    \            index = i;\n                    }\n                }\n          \
    \  }\n        }\n    }\n    if(index != 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp9b3ye8h.d(32): Error: no property `find` for type `string`\\\
    n/tmp/tmpp9b3ye8h.d(36): Error: no property `find` for type `string`\\n/tmp/tmpp9b3ye8h.d(36):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpp9b3ye8h.d(38): Error:\
    \ cannot implicitly convert expression `abs(i - word.length)` of type `ulong`\
    \ to `int`\\n/tmp/tmpp9b3ye8h.d(42): Error: cannot implicitly convert expression\
    \ `i` of type `ulong` to `int`\\n/tmp/tmpp9b3ye8h.d(50): Error: cannot implicitly\
    \ convert expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp9b3ye8h.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ closest_vowel = \"\";\n    int closest_vowel_index = -1;\n    int closest_vowel_distance\
    \ = -1;\n    int word_length = word.length;\n    for (int i = 0; i < word_length;\
    \ i++)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n          \
    \  int j = i + 1;\n            while (j < word_length && consonants.find(word[j])\
    \ != -1)\n            {\n                j++;\n            }\n            if (j\
    \ < word_length && vowels.find(word[j]) == -1)\n            {\n              \
    \  int distance = j - i;\n                if (closest_vowel_distance == -1 ||\
    \ distance < closest_vowel_distance)\n                {\n                    closest_vowel_distance\
    \ = distance;\n                    closest_vowel_index = i;\n                }\n\
    \            }\n        }\n    }\n    if (closest_vowel_index != -1)\n    {\n\
    \        closest_vowel = word[closest_vowel_index..closest_vowel_index];\n   \
    \ }\n    return closest_vowel;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwisi32_1.d(30): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpwisi32_1.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpwisi32_1.d(36): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpwisi32_1.d(40): Error: no property `find` for type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwisi32_1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n\
    \    for (int i = 0; i < word.length; i++)\n    {\n        if (vowels.find(word[i])\
    \ != -1)\n        {\n            if (i > 0 && i < word.length - 1)\n         \
    \   {\n                if (vowels.find(word[i - 1]) == -1 && vowels.find(word[i\
    \ + 1]) == -1)\n                {\n                    if (i < min_distance)\n\
    \                    {\n                        min_distance = i;\n          \
    \              index = i;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    if (index != 0)\n    {\n        result = word[index];\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6wiv1nn9.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp6wiv1nn9.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp6wiv1nn9.d(35): Error: no property `find` for type\
    \ `string`\\n/tmp/tmp6wiv1nn9.d(35): Error: no property `find` for type `string`\\\
    n/tmp/tmp6wiv1nn9.d(48): Error: cannot implicitly convert expression `word[cast(ulong)index]`\
    \ of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp6wiv1nn9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    int vowel_index\
    \ = -1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index]) !=\
    \ -1)\n        {\n            vowel_index = index;\n            break;\n     \
    \   }\n        index--;\n    }\n    if (vowel_index == -1)\n        return result;\n\
    \    index = vowel_index - 1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ == -1)\n        {\n            result = word[vowel_index];\n            break;\n\
    \        }\n        index--;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0jfnzb5o.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp0jfnzb5o.d(31): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp0jfnzb5o.d(43): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp0jfnzb5o.d(45): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)vowel_index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0jfnzb5o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, char c;\
    \ word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i == 0)\n                {\n                    if(consonants.canFind(word[i+1]))\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \                else if(i == word.length - 1)\n                {\n          \
    \          if(consonants.canFind(word[i-1]))\n                    {\n        \
    \                min_distance = distance;\n                        result = c;\n\
    \                    }\n                }\n                else\n            \
    \    {\n                    if(consonants.canFind(word[i-1]) && consonants.canFind(word[i+1]))\n\
    \                    {\n                        min_distance = distance;\n   \
    \                     result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe9jndo4x.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpe9jndo4x.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpe9jndo4x.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpe9jndo4x.d(38):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpe9jndo4x.d(41): Error:\
    \ cannot implicitly convert expression `c` of type `char` to `string`\\n/tmp/tmpe9jndo4x.d(46):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpe9jndo4x.d(49): Error:\
    \ cannot implicitly convert expression `c` of type `char` to `string`\\n/tmp/tmpe9jndo4x.d(54):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpe9jndo4x.d(54): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpe9jndo4x.d(57): Error: cannot\
    \ implicitly convert expression `c` of type `char` to `string`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9jndo4x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ char c; word)\n    {\n        if(vowels.canFind(c))\n        {\n           \
    \ int distance = word.length - i;\n            if(distance < min_distance)\n \
    \           {\n                min_distance = distance;\n                result\
    \ = c;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\")\
    \ == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp856iqzlu.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp856iqzlu.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp856iqzlu.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp856iqzlu.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `char` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp856iqzlu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = 0;\n    int min_distance = word.length;\n  \
    \  foreach(i, letter; word)\n    {\n        if(vowels.find(letter) != -1)\n  \
    \      {\n            int distance = word.length - i;\n            if(distance\
    \ < min_distance)\n            {\n                min_distance = distance;\n \
    \               index = i;\n            }\n        }\n    }\n    if(index == 0)\n\
    \    {\n        return result;\n    }\n    else\n    {\n        if(consonants.find(word[index\
    \ - 1]) != -1 && consonants.find(word[index + 1]) != -1)\n        {\n        \
    \    result = word[index..index];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaixc1qjx.d(29): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpaixc1qjx.d(32): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpaixc1qjx.d(34): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpaixc1qjx.d(38):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpaixc1qjx.d(48):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpaixc1qjx.d(48): Error:\
    \ no property `find` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpaixc1qjx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    while (index > 0)\n  \
    \  {\n        if (consonants.find(word[index]) != -1)\n        {\n           \
    \ if (vowels.find(word[index - 1]) != -1)\n            {\n                result\
    \ = word[index - 1];\n                break;\n            }\n        }\n     \
    \   index--;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9ukrgcuh.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp9ukrgcuh.d(31): Error: no property\
    \ `find` for type `string`\\n/tmp/tmp9ukrgcuh.d(33): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp9ukrgcuh.d(35): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)(index - 1)]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ukrgcuh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int index = word.length - 1;\n    int vowel_index = -1;\n\
    \    int consonant_index = -1;\n    while (index >= 0)\n    {\n        if (vowels.find(word[index])\
    \ != -1)\n        {\n            vowel_index = index;\n            break;\n  \
    \      }\n        index--;\n    }\n    if (vowel_index == -1)\n        return\
    \ result;\n    index = vowel_index - 1;\n    while (index >= 0)\n    {\n     \
    \   if (consonants.find(word[index]) != -1)\n        {\n            consonant_index\
    \ = index;\n            break;\n        }\n        index--;\n    }\n    if (consonant_index\
    \ == -1)\n        return result;\n    return word[vowel_index..vowel_index];\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfrp_bans.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpfrp_bans.d(33): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpfrp_bans.d(45): Error: no property `find`\
    \ for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfrp_bans.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.canFind(c))\n        {\n            int distance = word.length\
    \ - i;\n            if(distance < min_distance)\n            {\n             \
    \   if(i > 0 && consonants.canFind(word[i-1]))\n                {\n          \
    \          if(i < word.length - 1 && consonants.canFind(word[i+1]))\n        \
    \            {\n                        min_distance = distance;\n           \
    \             result = c;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqvd5uf7v.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpqvd5uf7v.d(31): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpqvd5uf7v.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmpqvd5uf7v.d(36):\
    \ Error: no property `canFind` for type `string`\\n/tmp/tmpqvd5uf7v.d(38): Error:\
    \ no property `canFind` for type `string`\\n/tmp/tmpqvd5uf7v.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqvd5uf7v.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    bool found_vowel = false;\n    bool found_consonant = false;\n\
    \    int index = 0;\n    int distance = 0;\n    int min_distance = word.length;\n\
    \    foreach(c; word)\n    {\n        if(found_vowel && found_consonant)\n   \
    \     {\n            if(distance < min_distance)\n            {\n            \
    \    min_distance = distance;\n                result = c;\n            }\n  \
    \          found_vowel = false;\n            found_consonant = false;\n      \
    \      distance = 0;\n        }\n        if(vowels.indexOf(c) != -1)\n       \
    \ {\n            found_vowel = true;\n        }\n        else if(consonants.indexOf(c)\
    \ != -1)\n        {\n            found_consonant = true;\n        }\n        distance++;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfjxvxtks.d(32): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfjxvxtks.d(40): Error: cannot implicitly\
    \ convert expression `c` of type `immutable(char)` to `string`\\n/tmp/tmpfjxvxtks.d(46):\
    \ Error: no property `indexOf` for type `string`\\n/tmp/tmpfjxvxtks.d(50): Error:\
    \ no property `indexOf` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpfjxvxtks.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i != 0 && i != word.length - 1)\n                {\n     \
    \               if(consonants.find(word[i - 1]) != -1 && consonants.find(word[i\
    \ + 1]) != -1)\n                    {\n                        min_distance =\
    \ distance;\n                        result = c;\n                    }\n    \
    \            }\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\"\
    ) == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5gvv08wz.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5gvv08wz.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5gvv08wz.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp5gvv08wz.d(38):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp5gvv08wz.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp5gvv08wz.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5gvv08wz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                if(i > 0 && consonants.find(word[i-1]) != -1)\n             \
    \   {\n                    if(i < word.length - 1 && consonants.find(word[i+1])\
    \ != -1)\n                    {\n                        min_distance = distance;\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5wbs2vih.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp5wbs2vih.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmp5wbs2vih.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp5wbs2vih.d(36):\
    \ Error: no property `find` for type `string`\\n/tmp/tmp5wbs2vih.d(38): Error:\
    \ no property `find` for type `string`\\n/tmp/tmp5wbs2vih.d(41): Error: cannot\
    \ implicitly convert expression `c` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5wbs2vih.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = int.max;\n    for (int i = 0;\
    \ i < word.length; i++)\n    {\n        if (vowels.canFind(word[i]))\n       \
    \ {\n            int j = i + 1;\n            while (j < word.length && vowels.canFind(word[j]))\n\
    \            {\n                j++;\n            }\n            if (j < word.length)\n\
    \            {\n                int distance = j - i;\n                if (distance\
    \ < min_distance)\n                {\n                    min_distance = distance;\n\
    \                    result = word[i..i+1];\n                }\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5eeo1yu4.d(30): Error: no property `canFind` for type `string`\\\
    n/tmp/tmp5eeo1yu4.d(33): Error: no property `canFind` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5eeo1yu4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = 0;\n    for (int i = word.length - 1;\
    \ i >= 0; i--)\n    {\n        if (vowels.find(word[i]) != -1)\n        {\n  \
    \          index = i;\n            break;\n        }\n    }\n    if (index ==\
    \ 0)\n    {\n        return result;\n    }\n    else\n    {\n        for (int\
    \ i = index; i >= 0; i--)\n        {\n            if (vowels.find(word[i]) ==\
    \ -1)\n            {\n                result = word[index];\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy8i6wl26.d(28): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpy8i6wl26.d(30): Error: no property\
    \ `find` for type `string`\\n/tmp/tmpy8i6wl26.d(44): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpy8i6wl26.d(46): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy8i6wl26.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int left_distance\
    \ = -1;\n            int right_distance = -1;\n            for(int j = i - 1;\
    \ j >= 0; j--)\n            {\n                if(consonants.find(word[j]) !=\
    \ -1)\n                {\n                    left_distance = i - j;\n       \
    \             break;\n                }\n            }\n            for(int j\
    \ = i + 1; j < word.length; j++)\n            {\n                if(consonants.find(word[j])\
    \ != -1)\n                {\n                    right_distance = j - i;\n   \
    \                 break;\n                }\n            }\n            if(left_distance\
    \ != -1 && right_distance != -1)\n            {\n                int distance\
    \ = min(left_distance, right_distance);\n                if(distance < min_distance)\n\
    \                {\n                    min_distance = distance;\n           \
    \         result = c;\n                }\n            }\n        }\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n\
    \    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\") ==\
    \ \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"eAsy\"\
    ) == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpss7r9jjo.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpss7r9jjo.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpss7r9jjo.d(35): Error: cannot implicitly convert\
    \ expression `i - 1LU` of type `ulong` to `int`\\n/tmp/tmpss7r9jjo.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpss7r9jjo.d(39): Error: cannot\
    \ implicitly convert expression `i - cast(ulong)j` of type `ulong` to `int`\\\
    n/tmp/tmpss7r9jjo.d(43): Error: cannot implicitly convert expression `i + 1LU`\
    \ of type `ulong` to `int`\\n/tmp/tmpss7r9jjo.d(45): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpss7r9jjo.d(47): Error: cannot implicitly convert\
    \ expression `cast(ulong)j - i` of type `ulong` to `int`\\n/tmp/tmpss7r9jjo.d(53):\
    \ Error: undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpss7r9jjo.d(57):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpss7r9jjo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            int right_distance\
    \ = word.length - i - 1;\n            int left_distance = i;\n            if(left_distance\
    \ > 0 && right_distance > 0)\n            {\n                if(consonants.find(word[i\
    \ - 1]) != -1 && consonants.find(word[i + 1]) != -1)\n                {\n    \
    \                if(min_distance > min(left_distance, right_distance))\n     \
    \               {\n                        min_distance = min(left_distance, right_distance);\n\
    \                        result = c;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\"\
    );\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"easy\")\
    \ == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj7f6ar6a.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpj7f6ar6a.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpj7f6ar6a.d(33): Error: cannot implicitly convert\
    \ expression `word.length - i - 1LU` of type `ulong` to `int`\\n/tmp/tmpj7f6ar6a.d(34):\
    \ Error: cannot implicitly convert expression `i` of type `ulong` to `int`\\n/tmp/tmpj7f6ar6a.d(37):\
    \ Error: no property `find` for type `string`\\n/tmp/tmpj7f6ar6a.d(37): Error:\
    \ no property `find` for type `string`\\n/tmp/tmpj7f6ar6a.d(39): Error: undefined\
    \ identifier `min`, did you mean function `main`?\\n/tmp/tmpj7f6ar6a.d(41): Error:\
    \ undefined identifier `min`, did you mean function `main`?\\n/tmp/tmpj7f6ar6a.d(42):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj7f6ar6a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int index = word.length - 1;\n    while (index >\
    \ 0)\n    {\n        if (vowels.canFind(word[index]))\n        {\n           \
    \ if (!vowels.canFind(word[index - 1]))\n            {\n                result\
    \ = word[index];\n                break;\n            }\n        }\n        index--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_closest_vowel;\n\
    \n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"full\")\
    \ == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd8pm0l7z.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpd8pm0l7z.d(30): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmpd8pm0l7z.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpd8pm0l7z.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)index]` of type `immutable(char)` to `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd8pm0l7z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string consonants = \"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\";\n    string\
    \ result = \"\";\n    int min_distance = word.length;\n    foreach(i, c; word)\n\
    \    {\n        if(vowels.find(c) != -1)\n        {\n            if(i == 0)\n\
    \                continue;\n            if(i == word.length - 1)\n           \
    \     continue;\n            if(consonants.find(word[i - 1]) != -1 && consonants.find(word[i\
    \ + 1]) != -1)\n            {\n                if(i < min_distance)\n        \
    \        {\n                    min_distance = i;\n                    result\
    \ = c;\n                }\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj3yy8oz3.d(28): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpj3yy8oz3.d(31): Error: no property `find`\
    \ for type `string`\\n/tmp/tmpj3yy8oz3.d(37): Error: no property `find` for type\
    \ `string`\\n/tmp/tmpj3yy8oz3.d(37): Error: no property `find` for type `string`\\\
    n/tmp/tmpj3yy8oz3.d(41): Error: cannot implicitly convert expression `i` of type\
    \ `ulong` to `int`\\n/tmp/tmpj3yy8oz3.d(42): Error: cannot implicitly convert\
    \ expression `c` of type `immutable(char)` to `string`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpj3yy8oz3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int min_distance = word.length;\n    foreach(i,\
    \ c; word)\n    {\n        if(vowels.canFind(c))\n        {\n            int distance\
    \ = word.length - i;\n            if(distance < min_distance)\n            {\n\
    \                min_distance = distance;\n                result = c;\n     \
    \       }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_closest_vowel;\n\n    assert(candidate(\"yogurt\") == \"u\");\n    assert(candidate(\"\
    full\") == \"u\");\n    assert(candidate(\"easy\") == \"\");\n    assert(candidate(\"\
    eAsy\") == \"\");\n    assert(candidate(\"ali\") == \"\");\n    assert(candidate(\"\
    bad\") == \"a\");\n    assert(candidate(\"most\") == \"o\");\n    assert(candidate(\"\
    ab\") == \"\");\n    assert(candidate(\"ba\") == \"\");\n    assert(candidate(\"\
    quick\") == \"\");\n    assert(candidate(\"anime\") == \"i\");\n    assert(candidate(\"\
    Asia\") == \"\");\n    assert(candidate(\"Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp988ae8zl.d(27): Error: cannot implicitly convert expression `word.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp988ae8zl.d(30): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmp988ae8zl.d(32): Error: cannot implicitly convert\
    \ expression `word.length - i` of type `ulong` to `int`\\n/tmp/tmp988ae8zl.d(36):\
    \ Error: cannot implicitly convert expression `c` of type `immutable(char)` to\
    \ `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp988ae8zl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nYou are given a word. Your\
    \ task is to find the closest vowel that stands between \n    two consonants from\
    \ the right side of the word (case sensitive).\n    \n    Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n    find any vowel\
    \ met the above condition. \n\n    You may assume that the given string contains\
    \ English letter only.\n\n    Example:\n    >>> get_closest_vowel(\"yogurt\")\n\
    \    \"u\"\n    >>> get_closest_vowel(\"FULL\")\n    \"U\"\n    >>> get_closest_vowel(\"\
    quick\")\n    \"\"\n    >>> get_closest_vowel(\"ab\")\n    \"\"\n    \n*/\nstring\
    \ get_closest_vowel(string word) \n{\n    string vowels = \"aeiouAEIOU\";\n  \
    \  string result = \"\";\n    int pos = word.length - 1;\n    while (pos > 0)\n\
    \    {\n        if (vowels.canFind(word[pos]))\n        {\n            if (!vowels.canFind(word[pos\
    \ - 1]))\n            {\n                result = word[pos];\n               \
    \ break;\n            }\n        }\n        pos--;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_closest_vowel;\n\n    assert(candidate(\"\
    yogurt\") == \"u\");\n    assert(candidate(\"full\") == \"u\");\n    assert(candidate(\"\
    easy\") == \"\");\n    assert(candidate(\"eAsy\") == \"\");\n    assert(candidate(\"\
    ali\") == \"\");\n    assert(candidate(\"bad\") == \"a\");\n    assert(candidate(\"\
    most\") == \"o\");\n    assert(candidate(\"ab\") == \"\");\n    assert(candidate(\"\
    ba\") == \"\");\n    assert(candidate(\"quick\") == \"\");\n    assert(candidate(\"\
    anime\") == \"i\");\n    assert(candidate(\"Asia\") == \"\");\n    assert(candidate(\"\
    Above\") == \"o\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpun2kiv1y.d(27): Error: cannot implicitly convert expression `word.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpun2kiv1y.d(30): Error: no property\
    \ `canFind` for type `string`\\n/tmp/tmpun2kiv1y.d(32): Error: no property `canFind`\
    \ for type `string`\\n/tmp/tmpun2kiv1y.d(34): Error: cannot implicitly convert\
    \ expression `word[cast(ulong)pos]` of type `immutable(char)` to `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpun2kiv1y.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
