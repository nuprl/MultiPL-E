name: HumanEval_70_strange_sort_list
language: d
prompt: "import std.math;\n/*\n\n    Given array of integers, return array in strange\
  \ order.\n    Strange sorting, is when you start with the minimum value,\n    then\
  \ maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n\
  \    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L,\
  \ 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n  \
  \  \n*/\nlong[] strange_sort_list(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n  \
    \  int i = 0;\n    int j = sorted.length - 1;\n    bool is_min = true;\n    foreach\
    \ (el; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n\
    \    int index = 0;\n    int min = 0;\n    int max = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (index < lst.length)\n    {\n        if (is_min)\n\
    \        {\n            res[index] = lst[min];\n            min++;\n        }\n\
    \        else\n        {\n            res[index] = lst[max];\n            max--;\n\
    \        }\n        is_min = !is_min;\n        index++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (i <= j)\n    {\n        if (is_min)\n        {\n            res[i] = lst[i];\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n\
    \        if (lst_copy.length == 0)\n            break;\n        res[i+1] = lst_copy[$-1];\n\
    \        lst_copy = lst_copy[0..$-1];\n        i += 2;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = min(lst[i], lst[j]);\n        res[k++] = max(lst[i],\
    \ lst[j]);\n        i++;\n        j--;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    int k = 0;\n    while (k < result.length)\n    {\n        if (i <=\
    \ j)\n        {\n            result[k] = sorted[i];\n            i++;\n      \
    \  }\n        if (i <= j)\n        {\n            result[k] = sorted[j];\n   \
    \         j--;\n        }\n        k++;\n    }\n    return result;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int[] idx = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n\
    \        idx[i] = i;\n    sort(idx, (a, b) => lst[a] < lst[b]);\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n    \
    \    res[k++] = lst[idx[i++]];\n        if (i <= j)\n            res[k++] = lst[idx[j--]];\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0) return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] lst_sorted = lst.dup;\n    lst_sorted.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j) {\n        res[k++] = lst_sorted[i++];\n        if (i <= j) res[k++] = lst_sorted[j--];\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    bool is_min\
    \ = true;\n    foreach (el; lst)\n    {\n        if (is_min)\n        {\n    \
    \        result[i] = sorted[i];\n            i++;\n        }\n        else\n \
    \       {\n            result[j] = sorted[j];\n            j--;\n        }\n \
    \       is_min = !is_min;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n      \
    \      result[i] = lst[i];\n            i++;\n        }\n        else\n      \
    \  {\n            result[j] = lst[i];\n            j--;\n        }\n        asc\
    \ = !asc;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n     \
    \   return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy =\
    \ lst.dup;\n    sort(lst_copy);\n    int i = 0;\n    int j = lst_copy.length -\
    \ 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst_copy[i++];\n\
    \        if (i <= j)\n            res[k++] = lst_copy[j--];\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long[] tmp = lst.dup;\n    sort(tmp);\n    int\
    \ i = 0;\n    int j = tmp.length - 1;\n    int k = 0;\n    while (i <= j)\n  \
    \  {\n        res[k++] = tmp[i++];\n        if (i <= j)\n            res[k++]\
    \ = tmp[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n   \
    \ int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n       \
    \ res[k++] = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n\
    \        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    sort(lst_copy);\n    int i = 0;\n    int j = lst_copy.length\
    \ - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n        if (flag)\n\
    \        {\n            res[i] = lst_copy[i];\n            i++;\n        }\n \
    \       else\n        {\n            res[i] = lst_copy[j];\n            j--;\n\
    \        }\n        flag = !flag;\n    }\n    return res;\n}", "{\n    long[]\
    \ result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n\
    \    int k = 0;\n    while (i <= j) {\n        result[k++] = lst[i++];\n     \
    \   if (i <= j) {\n            result[k++] = lst[j--];\n        }\n    }\n   \
    \ return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n\
    \    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst[i++];\n\
    \        if (i <= j)\n            result[k++] = lst[j--];\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n   \
    \ int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n       \
    \ res[k++] = min(lst[i], lst[j]);\n        if (lst[i] < lst[j])\n            i++;\n\
    \        else\n            j--;\n        if (i <= j)\n            res[k++] = max(lst[i],\
    \ lst[j]);\n        if (lst[i] > lst[j])\n            i++;\n        else\n   \
    \         j--;\n    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
