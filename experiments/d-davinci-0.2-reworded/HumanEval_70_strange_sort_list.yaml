name: HumanEval_70_strange_sort_list
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers,\
  \ return array in strange order.\n    Strange sorting, is when you start with the\
  \ minimum value,\n    then maximum of the remaining integers, then minimum and so\
  \ on.\n\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n   \
  \ >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n\
  \    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n"
tests: "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
  \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
  \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
  \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
  \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
  \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
  \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
  \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
  \ == [111111L]);\n}\nvoid main(){}"
completions: ["{\n    if (lst.length == 0)\n        return lst;\n    long[] res =\
    \ new long[lst.length];\n    long[] lst_copy = lst.dup;\n    lst_copy.sort;\n\
    \    int i = 0;\n    int j = lst_copy.length - 1;\n    bool flag = true;\n   \
    \ foreach (elem; lst_copy)\n    {\n        if (flag)\n        {\n            res[i]\
    \ = elem;\n            i++;\n        }\n        else\n        {\n            res[j]\
    \ = elem;\n            j--;\n        }\n        flag = !flag;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res\
    \ = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n  \
    \  while (lst_copy.length > 0)\n    {\n        res[i] = lst_copy[0];\n       \
    \ lst_copy = lst_copy[1..$];\n        if (lst_copy.length == 0)\n            break;\n\
    \        res[i+1] = lst_copy[$-1];\n        lst_copy = lst_copy[0..$-1];\n   \
    \     i += 2;\n    }\n    return res;\n}", "{\n    auto lst_len = lst.length;\n\
    \    if (lst_len == 0) return [];\n    auto result = new long[](lst_len);\n  \
    \  auto min_max_tuple = minMax(lst);\n    auto min_val = min_max_tuple[0];\n \
    \   auto max_val = min_max_tuple[1];\n    auto min_max_lst = [min_val, max_val];\n\
    \    auto min_max_lst_len = min_max_lst.length;\n    auto min_max_lst_idx = 0;\n\
    \    foreach (i, val; lst)\n    {\n        if (val == min_val || val == max_val)\n\
    \        {\n            result[i] = min_max_lst[min_max_lst_idx];\n          \
    \  min_max_lst_idx++;\n            if (min_max_lst_idx == min_max_lst_len)\n \
    \           {\n                min_max_lst_idx = 0;\n            }\n        }\n\
    \        else\n        {\n            result[i] = val;\n        }\n    }\n   \
    \ return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n    \
    \    if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}\n/*", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n    \
    \    res[k++] = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n\
    \    }\n    return res;\n}\n/*", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j =\
    \ lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        if (k %\
    \ 2 == 0)\n        {\n            result[k] = min(lst[i], lst[j]);\n         \
    \   if (lst[i] < lst[j])\n                i++;\n            else\n           \
    \     j--;\n        }\n        else\n        {\n            result[k] = max(lst[i],\
    \ lst[j]);\n            if (lst[i] > lst[j])\n                i++;\n         \
    \   else\n                j--;\n        }\n        k++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    int\
    \ i = 0;\n    foreach (e; sorted)\n    {\n        res[i] = e;\n        i += asc\
    \ ? 1 : -1;\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto sorted = lst.dup;\n    sorted.sort;\n \
    \   long[] result = new long[lst.length];\n    bool is_min = true;\n    size_t\
    \ i = 0;\n    size_t j = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = sorted[j];\n            j++;\n        }\n\
    \        else\n        {\n            result[i] = sorted[sorted.length - j - 1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    auto sorted = lst.dup;\n\
    \    sorted.sort;\n    auto min = sorted[0];\n    auto max = sorted[$ - 1];\n\
    \    auto res = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    while\
    \ (i < lst.length)\n    {\n        res[i] = min;\n        i += 2;\n        if\
    \ (i < lst.length)\n        {\n            res[i] = max;\n            i += 2;\n\
    \        }\n        j += 1;\n        if (j < sorted.length)\n        {\n     \
    \       min = sorted[j];\n            max = sorted[$ - j - 1];\n        }\n  \
    \  }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n\
    \        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n\
    }\n/*", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result =\
    \ new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int\
    \ i = 0;\n    int j = sorted.length - 1;\n    foreach (e; lst)\n    {\n      \
    \  if (i % 2 == 0)\n        {\n            result[i] = sorted[i / 2];\n      \
    \  }\n        else\n        {\n            result[i] = sorted[j];\n          \
    \  j--;\n        }\n        i++;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    int i =\
    \ 0;\n    while (sorted.length > 0)\n    {\n        if (is_min)\n        {\n \
    \           result[i] = sorted[0];\n            sorted = sorted[1..$];\n     \
    \   }\n        else\n        {\n            result[i] = sorted[$-1];\n       \
    \     sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n       \
    \ i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup;\n\
    \    sorted.sort;\n    long[] reversed = sorted.dup;\n    reversed.reverse;\n\
    \    bool is_even = true;\n    foreach (i, e; lst)\n    {\n        if (is_even)\n\
    \        {\n            res[i] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            res[i] = reversed[0];\n     \
    \       reversed = reversed[1..$];\n        }\n        is_even = !is_even;\n \
    \   }\n    return res;\n}", "{\n    if (lst.length == 0) return lst;\n    long[]\
    \ result = new long[lst.length];\n    auto min_max = minmax(lst);\n    long min\
    \ = min_max[0];\n    long max = min_max[1];\n    bool is_min = true;\n    foreach\
    \ (i, e; lst)\n    {\n        if (is_min)\n        {\n            result[i] =\
    \ min;\n            min = min_max[1];\n            is_min = false;\n        }\n\
    \        else\n        {\n            result[i] = max;\n            max = min_max[0];\n\
    \            is_min = true;\n        }\n    }\n    return result;\n}", "{\n  \
    \  if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    for (int i = 0; i < lst_copy.length; i++)\n    {\n        if (lst_copy[i]\
    \ < min)\n            min = lst_copy[i];\n        if (lst_copy[i] > max)\n   \
    \         max = lst_copy[i];\n    }\n    int j = 0;\n    while (lst_copy.length\
    \ > 0)\n    {\n        res[j] = min;\n        lst_copy = lst_copy.remove(min);\n\
    \        j++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[j] = max;\n        lst_copy = lst_copy.remove(max);\n        j++;\n    \
    \    if (lst_copy.length == 0)\n            break;\n        min = lst_copy[0];\n\
    \        max = lst_copy[0];\n        for (int i = 0; i < lst_copy.length; i++)\n\
    \        {\n            if (lst_copy[i] < min)\n                min = lst_copy[i];\n\
    \            if (lst_copy[i] > max)\n                max = lst_copy[i];\n    \
    \    }\n    }\n    return res;\n}", "{\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while(lst_copy.length > 0)\n\
    \    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n  \
    \      if(lst_copy.length > 0)\n        {\n            res[i+1] = lst_copy[$-1];\n\
    \            lst_copy = lst_copy[0..$-2];\n        }\n        i += 2;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    foreach\
    \ (el; lst)\n    {\n        if (flag)\n        {\n            res[i] = sorted[i];\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = sorted[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] ret = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        ret[k++] = lst[i++];\n        if (i <= j)\n            ret[k++]\
    \ = lst[j--];\n    }\n    return ret;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    auto min_max = minmax(lst);\n\
    \    long min = min_max[0];\n    long max = min_max[1];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            res[i] = min;\n            min = minElement(lst,\
    \ min);\n            i++;\n        }\n        else\n        {\n            res[j]\
    \ = max;\n            max = maxElement(lst, max);\n            j--;\n        }\n\
    \        is_min = !is_min;\n    }\n    return res;\n}", "{\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k =\
    \ 0;\n    while (i <= j) {\n        res[k++] = lst[i++];\n        if (i <= j)\
    \ {\n            res[k++] = lst[j--];\n        }\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n   \
    \ foreach (i, e; lst)\n    {\n        if (is_min)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    long[] sorted =\
    \ lst.dup;\n    sorted.sort;\n    bool asc = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (asc)\n        {\n            res[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i += 1;\n        asc = !asc;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] ret = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (elem; lst_copy)\n    {\n        if (elem < min)\n            min\
    \ = elem;\n        if (elem > max)\n            max = elem;\n    }\n    long[]\
    \ min_max = [min, max];\n    long[] min_max_copy = min_max.dup;\n    long[] min_max_copy_copy\
    \ = min_max_copy.dup;\n    long[] min_max_copy_copy_copy = min_max_copy_copy.dup;\n\
    \    long[] min_max_copy_copy_copy_copy = min_max_copy_copy_copy.dup;\n    long[]\
    \ min_max_copy_copy_copy_copy_copy = min_max_copy_copy_copy_copy.dup;\n    long[]\
    \ min_max_copy_copy_copy_copy_copy_copy = min_max_copy_copy_copy_copy_copy.dup;\n\
    \    long[] min_max_copy_copy_copy_copy_copy_copy_copy = min_max_copy_copy_copy_copy_copy_copy.dup;\n\
    \    long[] min_max_copy_copy_copy_copy_copy_copy_copy_copy = min_max_copy_copy_copy_copy_copy_copy_copy.dup;\n\
    \    long[] min_max_copy_copy_copy_copy_copy_copy_copy_copy_copy = min_max_copy_copy_copy_copy_copy_copy_copy_copy.dup;\n\
    \    long[] min_max_copy_copy_copy_copy_copy_copy_copy_copy_copy_copy = min_max_copy_copy_copy_copy_copy_copy_copy_copy_copy.dup;\n\
    \    long[] min_max_copy_copy_copy_copy_copy_copy_copy_copy_copy_", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    auto lst_copy = lst.dup;\n    lst_copy.sort;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    while (lst_copy.length\
    \ > 0)\n    {\n        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n\
    \        if (lst_copy.length > 0)\n        {\n            res[i+1] = lst_copy[$-1];\n\
    \            lst_copy = lst_copy[0..$-1];\n        }\n        i += 2;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    sort(lst_copy);\n\
    \    long[] min_max = new long[2];\n    min_max[0] = lst_copy[0];\n    min_max[1]\
    \ = lst_copy[lst_copy.length - 1];\n    int i = 0;\n    int j = 0;\n    while\
    \ (i < lst.length)\n    {\n        res[i] = min_max[j];\n        i++;\n      \
    \  j = (j + 1) % 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n    \
    \    if (k % 2 == 0)\n        {\n            res[k] = min(lst[i], lst[j]);\n \
    \           if (lst[i] < lst[j])\n                i++;\n            else\n   \
    \             j--;\n        }\n        else\n        {\n            res[k] = max(lst[i],\
    \ lst[j]);\n            if (lst[i] > lst[j])\n                i++;\n         \
    \   else\n                j--;\n        }\n        k++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long[] lst_copy = lst.dup;\n    int i = 0;\n    while\
    \ (lst_copy.length != 0)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        if (lst_copy.length == 0)\n            break;\n        result[i+1] =\
    \ lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i += 2;\n   \
    \ }\n    return result;\n}", "{\n    if (lst.length == 0) return lst;\n    long[]\
    \ res = new long[lst.length];\n    int[] idx = new int[lst.length];\n    int[]\
    \ idx_res = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n \
    \   {\n        idx[i] = i;\n        idx_res[i] = i;\n    }\n    sort(idx, (a,\
    \ b) => lst[a] < lst[b]);\n    int i = 0;\n    int j = lst.length - 1;\n    while\
    \ (i <= j)\n    {\n        res[idx_res[i]] = lst[idx[i]];\n        i++;\n    \
    \    if (i <= j)\n        {\n            res[idx_res[j]] = lst[idx[j]];\n    \
    \        j--;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long[] lst_copy_sorted = lst_copy.sort;\n    long min\
    \ = lst_copy_sorted[0];\n    long max = lst_copy_sorted[$ - 1];\n    long[] lst_copy_sorted_min\
    \ = lst_copy_sorted.filter!(a => a == min);\n    long[] lst_copy_sorted_max =\
    \ lst_copy_sorted.filter!(a => a == max);\n    long[] lst_copy_sorted_other =\
    \ lst_copy_sorted.filter!(a => a != min && a != max);\n    long[] lst_copy_sorted_other_sorted\
    \ = lst_copy_sorted_other.sort;\n    long[] lst_copy_sorted_other_sorted_min =\
    \ lst_copy_sorted_other_sorted.filter!(a => a == lst_copy_sorted_other_sorted[0]);\n\
    \    long[] lst_copy_sorted_other_sorted_max = lst_copy_sorted_other_sorted.filter!(a\
    \ => a == lst_copy_sorted_other_sorted[$ - 1]);\n    long[] lst_copy_sorted_other_sorted_other\
    \ = lst_copy_sorted_other_sorted.filter!(a => a != lst_copy_sorted_other_sorted[0]\
    \ && a != lst_copy_sorted_other_sorted[$ - 1]);\n    long[] lst_copy_sorted_other_sorted_other_sorted\
    \ = lst_copy_sorted_other_sorted_other.sort;\n    long[] lst_copy_sorted_other_sorted_other_sorted_min\
    \ = lst_copy_sorted_other_sorted_other_sorted.filter!(a => a == lst_copy_sorted_other_sorted_other_",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] temp = lst.dup;\n    int i = 0;\n    while (temp.length > 0)\n   \
    \ {\n        result[i] = temp.min;\n        temp.remove(temp.min);\n        i++;\n\
    \        if (temp.length == 0)\n            break;\n        result[i] = temp.max;\n\
    \        temp.remove(temp.max);\n        i++;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = sorted[i++];\n\
    \        if (i <= j)\n            result[k++] = sorted[j--];\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto min\
    \ = min(lst);\n    auto max = max(lst);\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    while (i < lst.length)\n    {\n        if (i % 2 == 0)\n\
    \        {\n            result[i] = min;\n            min = min(lst);\n      \
    \  }\n        else\n        {\n            result[i] = max;\n            max =\
    \ max(lst);\n        }\n        i++;\n    }\n    return result;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    else if (lst.length == 1)\n    \
    \    return lst;\n    else\n    {\n        long[] new_lst = new long[lst.length];\n\
    \        long[] sorted_lst = lst.dup;\n        sorted_lst.sort();\n        long[]\
    \ sorted_lst_rev = sorted_lst.dup;\n        sorted_lst_rev.reverse();\n      \
    \  bool is_even = true;\n        foreach (i, e; lst)\n        {\n            if\
    \ (is_even)\n            {\n                new_lst[i] = sorted_lst[0];\n    \
    \            sorted_lst = sorted_lst[1..$];\n            }\n            else\n\
    \            {\n                new_lst[i] = sorted_lst_rev[0];\n            \
    \    sorted_lst_rev = sorted_lst_rev[1..$];\n            }\n            is_even\
    \ = !is_even;\n        }\n        return new_lst;\n    }\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto sorted = lst.dup;\n    sorted.sort;\n \
    \   long[] res = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    int\
    \ k = lst.length - 1;\n    while (i < lst.length)\n    {\n        res[i] = sorted[j];\n\
    \        i++;\n        j++;\n        if (i < lst.length)\n        {\n        \
    \    res[i] = sorted[k];\n            i++;\n            k--;\n        }\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    long[] min_max\
    \ = minMax(lst_copy);\n    long min = min_max[0];\n    long max = min_max[1];\n\
    \    int i = 0;\n    while (lst_copy.length > 0)\n    {\n        if (i % 2 ==\
    \ 0)\n        {\n            result[i] = min;\n            lst_copy = lst_copy.filter!(x\
    \ => x != min);\n            if (lst_copy.length > 0)\n            {\n       \
    \         min_max = minMax(lst_copy);\n                min = min_max[0];\n   \
    \             max = min_max[1];\n            }\n        }\n        else\n    \
    \    {\n            result[i] = max;\n            lst_copy = lst_copy.filter!(x\
    \ => x != max);\n            if (lst_copy.length > 0)\n            {\n       \
    \         min_max = minMax(lst_copy);\n                min = min_max[0];\n   \
    \             max = min_max[1];\n            }\n        }\n        i++;\n    }\n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = min(lst);\n            lst.remove(min(lst));\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = min(lst);\n\
    \            lst.remove(min(lst));\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n     \
    \   return lst;\n    \n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort;\n    bool asc = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (asc)\n        {\n            res[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int[] idx = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n\
    \        idx[i] = i;\n    idx.sort!((a, b) => lst[a] > lst[b]);\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    while (i <= j)\n    {\n        res[idx[i]] =\
    \ lst[idx[j]];\n        i++;\n        if (i <= j)\n        {\n            res[idx[j]]\
    \ = lst[idx[i]];\n            j--;\n        }\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k] = sorted[i];\n\
    \        k++;\n        if (i != j)\n        {\n            res[k] = sorted[j];\n\
    \            k++;\n        }\n        i++;\n        j--;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long[] lst_min = lst_copy.dup;\n    long[]\
    \ lst_max = lst_copy.dup;\n    lst_min.sort;\n    lst_max.sort;\n    lst_max.reverse;\n\
    \    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n    {\n        if\
    \ (is_min)\n        {\n            res[i] = lst_min[0];\n            lst_min =\
    \ lst_min[1 .. $];\n        }\n        else\n        {\n            res[i] = lst_max[0];\n\
    \            lst_max = lst_max[1 .. $];\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort;\n    bool is_min = true;\n    foreach (i, e; sorted)\n    {\n \
    \       if (is_min)\n        {\n            result[i] = e;\n            is_min\
    \ = false;\n        }\n        else\n        {\n            result[lst.length\
    \ - i - 1] = e;\n            is_min = true;\n        }\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    bool\
    \ is_min = true;\n    int j = 0;\n    foreach (i; 0 .. lst.length)\n    {\n  \
    \      if (is_min)\n        {\n            result[i] = sorted[j];\n          \
    \  j++;\n        }\n        else\n        {\n            result[i] = sorted[sorted.length\
    \ - j];\n        }\n        is_min = !is_min;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while\
    \ (i <= j)\n    {\n        if (asc)\n        {\n            res[i] = lst[i];\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\n\
    /*", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new\
    \ long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n    int i\
    \ = 0;\n    while (sorted.length > 0)\n    {\n        result[i] = sorted[0];\n\
    \        sorted = sorted[1..$];\n        if (sorted.length > 0)\n        {\n \
    \           result[i+1] = sorted[$-1];\n            sorted = sorted[0..$-2];\n\
    \        }\n        i += 2;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (lst_copy.length\
    \ != 0)\n    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    auto minmax = minmaxElement(lst);\n    int min = minmax[0];\n    int max\
    \ = minmax[1];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min =\
    \ true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n         \
    \   res[i] = lst[min];\n            min++;\n        }\n        else\n        {\n\
    \            res[i] = lst[max];\n            max--;\n        }\n        is_min\
    \ = !is_min;\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    int i = 0;\n    while\
    \ (lst_copy.length != 0)\n    {\n        if (i % 2 == 0)\n        {\n        \
    \    res[i] = min;\n            lst_copy = lst_copy.remove(min);\n           \
    \ if (lst_copy.length == 0)\n                break;\n            min = lst_copy[0];\n\
    \            foreach (el; lst_copy)\n            {\n                if (el < min)\n\
    \                    min = el;\n            }\n        }\n        else\n     \
    \   {\n            res[i] = max;\n            lst_copy = lst_copy.remove(max);\n\
    \            if (lst_copy.length == 0)\n                break;\n            max\
    \ = lst_copy[0];\n            foreach (el; lst_copy)\n            {\n        \
    \        if (el > max)\n                    max = el;\n            }\n       \
    \ }\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    auto sorted = lst.dup;\n    sorted.sort;\n    long[]\
    \ result = new long[lst.length];\n    bool asc = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (asc)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    while (lst.length > 0)\n    {\n        long min = lst[0];\n\
    \        long max = lst[0];\n        foreach (elem; lst)\n        {\n        \
    \    if (elem < min)\n                min = elem;\n            if (elem > max)\n\
    \                max = elem;\n        }\n        result[i] = min;\n        result[i\
    \ + 1] = max;\n        lst = lst.filter!(e => e != min && e != max);\n       \
    \ i += 2;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n     \
    \   return lst;\n    auto sorted = lst.dup;\n    sorted.sort;\n    long[] result\
    \ = new long[lst.length];\n    bool is_min = true;\n    size_t i = 0;\n    size_t\
    \ j = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = sorted[j];\n            j++;\n        }\n        else\n\
    \        {\n            result[i] = sorted[lst.length - j];\n        }\n     \
    \   is_min = !is_min;\n        i++;\n    }\n    return result;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int[] idx = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n\
    \        idx[i] = i;\n    idx.sort!((a, b) => lst[a] < lst[b]);\n    int i = 0;\n\
    \    while (i < lst.length)\n    {\n        res[i] = lst[idx[i]];\n        i +=\
    \ 2;\n    }\n    i = 1;\n    while (i < lst.length)\n    {\n        res[i] = lst[idx[lst.length\
    \ - i]];\n        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n  \
    \  {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0) return\
    \ lst;\n    auto min = minElement(lst);\n    auto max = maxElement(lst);\n   \
    \ long[] res = new long[lst.length];\n    int i = 0;\n    while (lst.length >\
    \ 0) \n    {\n        res[i] = min;\n        lst = lst.remove(min);\n        if\
    \ (lst.length == 0) break;\n        res[i+1] = max;\n        lst = lst.remove(max);\n\
    \        i += 2;\n        min = minElement(lst);\n        max = maxElement(lst);\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort();\n    bool is_min = true;\n    size_t i = 0;\n    size_t j = 0;\n\
    \    while (i < lst.length)\n    {\n        if (is_min)\n        {\n         \
    \   result[i] = sorted[j];\n            j++;\n        }\n        else\n      \
    \  {\n            result[i] = sorted[lst.length - j];\n        }\n        is_min\
    \ = !is_min;\n        i++;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_sorted = lst.dup;\n    lst_sorted.sort;\n    long[] lst_sorted_rev = lst_sorted.dup;\n\
    \    lst_sorted_rev.reverse;\n    int i = 0;\n    int j = 0;\n    while (i < lst.length)\n\
    \    {\n        res[i] = lst_sorted[j];\n        i++;\n        if (i < lst.length)\n\
    \        {\n            res[i] = lst_sorted_rev[j];\n            i++;\n      \
    \  }\n        j++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n       \
    \ res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n        i++;\n\
    \        if (lst_copy.length == 0)\n            break;\n        res[i] = lst_copy.max;\n\
    \        lst_copy.remove(lst_copy.max);\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    auto sorted = lst.dup;\n\
    \    sorted.sort;\n    auto min = sorted[0];\n    auto max = sorted[$ - 1];\n\
    \    auto result = new long[lst.length];\n    auto i = 0;\n    while (i < lst.length)\n\
    \    {\n        result[i] = min;\n        i++;\n        if (i < lst.length)\n\
    \        {\n            result[i] = max;\n            i++;\n        }\n    }\n\
    \    return result;\n}", "{\n    if (lst.length == 0) return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n    \
    \    {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst[i];\n            j--;\n        }\n      \
    \  is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n    \
    \    res[k++] = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort();\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach\
    \ (e; lst)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] =\
    \ sorted[i / 2];\n        }\n        else\n        {\n            result[i] =\
    \ sorted[j];\n            j--;\n        }\n        i++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    sort(lst_copy);\n    bool min_first = true;\n\
    \    foreach (i, v; lst_copy)\n    {\n        if (min_first)\n        {\n    \
    \        res[0] = v;\n            min_first = false;\n        }\n        else\n\
    \        {\n            res[$ - 1] = v;\n            min_first = true;\n     \
    \   }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup;\n\
    \    sorted.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    int k =\
    \ 0;\n    while (i <= j)\n    {\n        res[k] = sorted[i];\n        k++;\n \
    \       if (i != j)\n        {\n            res[k] = sorted[j];\n            k++;\n\
    \        }\n        i++;\n        j--;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long min = min(lst);\n    long max = max(lst);\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n       \
    \ if (asc)\n        {\n            res[i] = min;\n            min = min(lst.filter!(a\
    \ => a != min));\n        }\n        else\n        {\n            res[i] = max;\n\
    \            max = max(lst.filter!(a => a != max));\n        }\n        i++;\n\
    \        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (is_min)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (i; lst_copy)\n    {\n        if (i < min)\n            min = i;\n\
    \        if (i > max)\n            max = i;\n    }\n    int i = 0;\n    while\
    \ (lst_copy.length != 0)\n    {\n        if (i % 2 == 0)\n        {\n        \
    \    res[i] = min;\n            lst_copy = lst_copy.remove(min);\n           \
    \ min = lst_copy[0];\n            foreach (i; lst_copy)\n            {\n     \
    \           if (i < min)\n                    min = i;\n            }\n      \
    \  }\n        else\n        {\n            res[i] = max;\n            lst_copy\
    \ = lst_copy.remove(max);\n            max = lst_copy[0];\n            foreach\
    \ (i; lst_copy)\n            {\n                if (i > max)\n               \
    \     max = i;\n            }\n        }\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    auto min_max = minMax(lst);\n    res[0] = min_max[0];\n    res[1] = min_max[1];\n\
    \    int i = 2;\n    int j = 0;\n    while (i < lst.length)\n    {\n        if\
    \ (i % 2 == 0)\n        {\n            res[i] = lst[j];\n            j++;\n  \
    \      }\n        else\n        {\n            res[i] = lst[lst.length - j - 1];\n\
    \        }\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while (lst_copy.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    auto min = lst[0];\n    auto\
    \ max = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n         \
    \   min = i;\n        if (i > max)\n            max = i;\n    }\n    auto res\
    \ = new long[lst.length];\n    auto i = 0;\n    auto j = lst.length - 1;\n   \
    \ auto k = 0;\n    while (k < lst.length)\n    {\n        if (k % 2 == 0)\n  \
    \      {\n            res[k] = min;\n            i++;\n        }\n        else\n\
    \        {\n            res[k] = max;\n            j--;\n        }\n        k++;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n  \
    \      {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst[i];\n            j--;\n        }\n      \
    \  asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0) return\
    \ lst;\n    auto min_max = minmax(lst);\n    long min = min_max[0];\n    long\
    \ max = min_max[1];\n    long[] result = new long[lst.length];\n    int i = 0;\n\
    \    while (i < lst.length)\n    {\n        result[i] = min;\n        i++;\n \
    \       if (i < lst.length)\n        {\n            result[i] = max;\n       \
    \     i++;\n        }\n    }\n    return result;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    else\n    {\n        long[] sorted = new long[lst.length];\n\
    \        int i = 0;\n        int j = lst.length - 1;\n        bool is_min = true;\n\
    \        while (i <= j)\n        {\n            if (is_min)\n            {\n \
    \               sorted[i] = lst[i];\n                i++;\n            }\n   \
    \         else\n            {\n                sorted[j] = lst[i];\n         \
    \       j--;\n            }\n            is_min = !is_min;\n        }\n      \
    \  return sorted;\n    }\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort;\n    bool is_min = true;\n    int i = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    bool[] used = new bool[lst.length];\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    foreach (i; lst)\n    {\n        if (i < min)\n            min\
    \ = i;\n        if (i > max)\n            max = i;\n    }\n    long[] sorted =\
    \ lst.dup;\n    sort(sorted);\n    bool is_min = true;\n    foreach (i; 0..lst.length)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = min;\n       \
    \     used[sorted.indexOf(min)] = true;\n            min = max;\n            foreach\
    \ (j; 0..lst.length)\n            {\n                if (!used[j] && sorted[j]\
    \ < min)\n                    min = sorted[j];\n            }\n        }\n   \
    \     else\n        {\n            result[i] = max;\n            used[sorted.indexOf(max)]\
    \ = true;\n            max = min;\n            foreach (j; 0..lst.length)\n  \
    \          {\n                if (!used[j] && sorted[j] > max)\n             \
    \       max = sorted[j];\n            }\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0) return lst;\n   \
    \ long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort;\n    bool\
    \ asc = true;\n    int i = 0;\n    while (sorted.length > 0) {\n        if (asc)\
    \ {\n            res[i] = sorted[0];\n            sorted = sorted[1..$];\n   \
    \     } else {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0) return lst;\n    long[] sorted = lst.dup;\n    sorted.sort;\n\
    \    long[] result = new long[lst.length];\n    int i = 0;\n    int j = 0;\n \
    \   int k = lst.length - 1;\n    while (i < lst.length) \n    {\n        if (i\
    \ % 2 == 0) \n        {\n            result[i] = sorted[j];\n            j++;\n\
    \        }\n        else \n        {\n            result[i] = sorted[k];\n   \
    \         k--;\n        }\n        i++;\n    }\n    return result;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] res = new long[lst.length];\n   \
    \ int i = 0;\n    while (i < lst.length)\n    {\n        res[i] = min;\n     \
    \   i++;\n        if (i < lst.length)\n        {\n            res[i] = max;\n\
    \            i++;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    auto\
    \ min_max = minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n\
    \    int i = 0;\n    while (i < lst.length) \n    {\n        if (i % 2 == 0) \n\
    \        {\n            result[i] = min;\n            min = max;\n        }\n\
    \        else \n        {\n            result[i] = max;\n            max = min;\n\
    \        }\n        i++;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_ =\
    \ lst.dup;\n    long min = lst_.min;\n    long max = lst_.max;\n    int i = 0;\n\
    \    while (lst_.length > 0)\n    {\n        if (i % 2 == 0)\n        {\n    \
    \        res[i] = min;\n            lst_.remove(min);\n            min = lst_.min;\n\
    \        }\n        else\n        {\n            res[i] = max;\n            lst_.remove(max);\n\
    \            max = lst_.max;\n        }\n        i++;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    bool asc = true;\n    int\
    \ i = 0;\n    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n\
    \            res[i] = sorted[0];\n            sorted = sorted[1..$];\n       \
    \ }\n        else\n        {\n            res[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        i++;\n        asc = !asc;\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n    \
    \    if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\n\
    /*", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    bool asc = true;\n    int\
    \ i = 0;\n    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n\
    \            res[i] = sorted[0];\n            sorted = sorted[1..$];\n       \
    \ }\n        else\n        {\n            res[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        i++;\n        asc = !asc;\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0) \n    {\n        return lst;\n\
    \    }\n    auto min_max = minmax(lst);\n    long min = min_max[0];\n    long\
    \ max = min_max[1];\n    long[] res = new long[lst.length];\n    bool is_min =\
    \ true;\n    int i = 0;\n    while (lst.length > 0) \n    {\n        if (is_min)\
    \ \n        {\n            res[i] = min;\n            lst = lst.filter!(x => x\
    \ != min);\n            if (lst.length == 0) \n            {\n               \
    \ break;\n            }\n            min_max = minmax(lst);\n            min =\
    \ min_max[0];\n            max = min_max[1];\n        } \n        else \n    \
    \    {\n            res[i] = max;\n            lst = lst.filter!(x => x != max);\n\
    \            if (lst.length == 0) \n            {\n                break;\n  \
    \          }\n            min_max = minmax(lst);\n            min = min_max[0];\n\
    \            max = min_max[1];\n        }\n        is_min = !is_min;\n       \
    \ i++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    int i = 0;\n    while (lst_copy.length != 0)\n    {\n        res[i] = lst_copy.min;\n\
    \        lst_copy = lst_copy.remove(lst_copy.min);\n        i++;\n        if (lst_copy.length\
    \ == 0)\n            break;\n        res[i] = lst_copy.max;\n        lst_copy\
    \ = lst_copy.remove(lst_copy.max);\n        i++;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n \
    \   foreach (i, ref e; result)\n    {\n        if (is_min)\n        {\n      \
    \      e = sorted[0];\n            sorted = sorted[1 .. $];\n        }\n     \
    \   else\n        {\n            e = sorted[$ - 1];\n            sorted = sorted[0\
    \ .. $ - 1];\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j =\
    \ sorted.length - 1;\n    while (i < j)\n    {\n        res[i] = sorted[i];\n\
    \        res[j] = sorted[j];\n        i++;\n        j--;\n    }\n    if (i ==\
    \ j)\n        res[i] = sorted[i];\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = sorted[i++];\n\
    \        if (i <= j)\n            res[k++] = sorted[j--];\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    sort(lst_copy);\n    auto min_max = tuple(lst_copy[0],\
    \ lst_copy[$ - 1]);\n    res[0] = min_max[0];\n    res[$ - 1] = min_max[1];\n\
    \    int i = 1;\n    int j = $ - 2;\n    int k = 1;\n    while (k < lst.length\
    \ - 1)\n    {\n        if (k % 2 == 1)\n        {\n            res[i] = lst_copy[j];\n\
    \            i++;\n            j--;\n        }\n        else\n        {\n    \
    \        res[j] = lst_copy[i];\n            i++;\n            j--;\n        }\n\
    \        k++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    long[] lst_copy_sorted = lst_copy.dup;\n    lst_copy_sorted.sort;\n\
    \    long[] lst_copy_sorted_rev = lst_copy_sorted.dup;\n    lst_copy_sorted_rev.reverse;\n\
    \    long[] lst_copy_sorted_rev_copy = lst_copy_sorted_rev.dup;\n    long[] lst_copy_sorted_copy\
    \ = lst_copy_sorted.dup;\n    bool is_even = true;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (is_even)\n        {\n            res[i] = lst_copy_sorted[0];\n\
    \            lst_copy_sorted.remove(0);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy_sorted_rev[0];\n            lst_copy_sorted_rev.remove(0);\n\
    \        }\n        is_even = !is_even;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n   \
    \ int j = lst.length - 1;\n    int k = 0;\n    bool flag = true;\n    long[] lst_copy\
    \ = lst.dup;\n    lst_copy.sort;\n    while (i <= j)\n    {\n        if (flag)\n\
    \        {\n            res[k] = lst_copy[i];\n            i++;\n        }\n \
    \       else\n        {\n            res[k] = lst_copy[j];\n            j--;\n\
    \        }\n        flag = !flag;\n        k++;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    auto sorted = lst.sort();\n\
    \    auto min = sorted[0];\n    auto max = sorted[$ - 1];\n    long[] result =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    foreach (el; lst)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = min;\n            i++;\n        }\n        else\n   \
    \     {\n            result[j] = max;\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n  \
    \      return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n \
    \   int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n\
    \        if (asc)\n        {\n            res[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = lst[i];\n          \
    \  j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}", "{\n    if\
    \ (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    long min = lst[0];\n    long max = lst[0];\n    foreach (elem;\
    \ lst)\n    {\n        if (elem < min)\n            min = elem;\n        if (elem\
    \ > max)\n            max = elem;\n    }\n    result[i++] = min;\n    result[i++]\
    \ = max;\n    lst.remove(min);\n    lst.remove(max);\n    while (lst.length !=\
    \ 0)\n    {\n        min = lst[0];\n        max = lst[0];\n        foreach (elem;\
    \ lst)\n        {\n            if (elem < min)\n                min = elem;\n\
    \            if (elem > max)\n                max = elem;\n        }\n       \
    \ result[i++] = min;\n        result[i++] = max;\n        lst.remove(min);\n \
    \       lst.remove(max);\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto sorted = lst.dup;\n    sorted.sort;\n \
    \   auto result = new long[](lst.length);\n    auto min_max = tuple(0, lst.length\
    \ - 1);\n    foreach (i, _; lst)\n    {\n        if (i % 2 == 0)\n        {\n\
    \            result[i] = sorted[min_max.front];\n            min_max.front++;\n\
    \        }\n        else\n        {\n            result[i] = sorted[min_max.back];\n\
    \            min_max.back--;\n        }\n    }\n    return result;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    bool is_min = true;\n    foreach (e; lst)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = sorted[i];\n            i++;\n        }\n   \
    \     else\n        {\n            res[j] = sorted[j];\n            j--;\n   \
    \     }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n\
    \        if (flag)\n        {\n            res[i] = lst[i];\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = lst[i];\n          \
    \  j--;\n        }\n        flag = !flag;\n    }\n    return res;\n}", "{\n  \
    \  if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (i; lst_copy)\n    {\n        if (i < min)\n            min = i;\n\
    \        if (i > max)\n            max = i;\n    }\n    int index = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        if (index % 2 == 0)\n        {\n     \
    \       res[index] = min;\n            lst_copy = lst_copy.filter!(x => x != min);\n\
    \            if (lst_copy.length > 0)\n                min = lst_copy[0];\n  \
    \          foreach (i; lst_copy)\n            {\n                if (i < min)\n\
    \                    min = i;\n            }\n        }\n        else\n      \
    \  {\n            res[index] = max;\n            lst_copy = lst_copy.filter!(x\
    \ => x != max);\n            if (lst_copy.length > 0)\n                max = lst_copy[0];\n\
    \            foreach (i; lst_copy)\n            {\n                if (i > max)\n\
    \                    max = i;\n            }\n        }\n        index++;\n  \
    \  }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool flag = true;\n    while (i <= j)\n    {\n        if (flag)\n\
    \        {\n            res[i] = lst[i];\n            i++;\n        }\n      \
    \  else\n        {\n            res[j] = lst[i];\n            j--;\n        }\n\
    \        flag = !flag;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int[]\
    \ index = new int[lst.length];\n    int[] index_res = new int[lst.length];\n \
    \   int i = 0;\n    foreach (elem; lst)\n    {\n        index[i] = i;\n      \
    \  i++;\n    }\n    i = 0;\n    while (index.length > 0)\n    {\n        int min\
    \ = index[0];\n        int max = index[0];\n        foreach (elem; index)\n  \
    \      {\n            if (lst[elem] < lst[min])\n                min = elem;\n\
    \            if (lst[elem] > lst[max])\n                max = elem;\n        }\n\
    \        if (i % 2 == 0)\n        {\n            result[i] = lst[min];\n     \
    \       index_res[i] = min;\n            index = index.remove(min);\n        }\n\
    \        else\n        {\n            result[i] = lst[max];\n            index_res[i]\
    \ = max;\n            index = index.remove(max);\n        }\n        i++;\n  \
    \  }\n    return result;\n}", "{\n    if (lst.length == 0) return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n\
    \            res[i] = lst[i];\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst[i];\n            j--;\n        }\n        asc\
    \ = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n\
    \    sorted.sort();\n    long min = sorted[0];\n    long max = sorted[$ - 1];\n\
    \    int i = 0;\n    while (i < lst.length)\n    {\n        result[i] = min;\n\
    \        i++;\n        if (i == lst.length)\n            break;\n        result[i]\
    \ = max;\n        i++;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while (lst_copy.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n\
    \            lst_copy = lst_copy.remove(lst_copy.min);\n        }\n        else\n\
    \        {\n            res[i] = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted_lst = lst.dup;\n    sorted_lst.sort;\n    bool is_min = true;\n\
    \    foreach (i, e; lst)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = sorted_lst[0];\n            sorted_lst = sorted_lst[1..$];\n        }\n  \
    \      else\n        {\n            res[i] = sorted_lst[$-1];\n            sorted_lst\
    \ = sorted_lst[0..$-1];\n        }\n        is_min = !is_min;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto min =\
    \ minElement(lst);\n    auto max = maxElement(lst);\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    while (i < lst.length)\n    {\n        res[i] = min;\n  \
    \      i++;\n        if (i < lst.length)\n        {\n            res[i] = max;\n\
    \            i++;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long[] reversed = sorted.dup;\n \
    \   reversed.reverse();\n    bool is_reversed = false;\n    foreach (i, e; lst)\n\
    \    {\n        if (is_reversed)\n            res[i] = reversed.front;\n     \
    \   else\n            res[i] = sorted.front;\n        is_reversed = !is_reversed;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int[] index = new int[lst.length];\n\
    \    int[] index_res = new int[lst.length];\n    int min = 0;\n    int max = 0;\n\
    \    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] > lst[max])\n\
    \            max = i;\n        if (lst[i] < lst[min])\n            min = i;\n\
    \    }\n    index[0] = min;\n    index_res[0] = 0;\n    index[1] = max;\n    index_res[1]\
    \ = 1;\n    int j = 2;\n    for (int i = 0; i < lst.length; i++)\n    {\n    \
    \    if (i != min && i != max)\n        {\n            index[j] = i;\n       \
    \     index_res[j] = j;\n            j++;\n        }\n    }\n    for (int i =\
    \ 0; i < lst.length; i++)\n    {\n        res[i] = lst[index[i]];\n    }\n   \
    \ return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto\
    \ min_max_list = lst.map!(a => tuple(a, a)).reduce!minmax;\n    long min = min_max_list[0];\n\
    \    long max = min_max_list[1];\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    while (i < lst.length)\n    {\n        if (i % 2 == 0)\n\
    \        {\n            result[i] = min;\n            min = lst.filter!(a => a\
    \ != min).reduce!min;\n        }\n        else\n        {\n            result[i]\
    \ = max;\n            max = lst.filter!(a => a != max).reduce!max;\n        }\n\
    \        i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long[] res = new long[lst.length];\n    long[] tmp =\
    \ lst.dup;\n    int i = 0;\n    while (tmp.length > 0)\n    {\n        res[i]\
    \ = tmp.min;\n        tmp = tmp.remove(tmp.min);\n        i++;\n        if (tmp.length\
    \ == 0)\n            break;\n        res[i] = tmp.max;\n        tmp = tmp.remove(tmp.max);\n\
    \        i++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n       \
    \ res[i] = lst_copy.min;\n        lst_copy = lst_copy.remove(lst_copy.min);\n\
    \        i += 1;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy = lst_copy.remove(lst_copy.max);\n   \
    \         i += 1;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) \n    {\n        return lst;\n    }\n    auto min_max = minmax(lst);\n\
    \    long min = min_max[0];\n    long max = min_max[1];\n    long[] result = new\
    \ long[lst.length];\n    bool is_min = true;\n    long i = 0;\n    while (i <\
    \ lst.length) \n    {\n        if (is_min) \n        {\n            if (lst[i]\
    \ == min) \n            {\n                result[i] = min;\n                is_min\
    \ = false;\n            }\n        } \n        else \n        {\n            if\
    \ (lst[i] == max) \n            {\n                result[i] = max;\n        \
    \        is_min = true;\n            }\n        }\n        i++;\n    }\n    i\
    \ = 0;\n    while (i < lst.length) \n    {\n        if (result[i] == 0) \n   \
    \     {\n            if (is_min) \n            {\n                result[i] =\
    \ min;\n                is_min = false;\n            } \n            else \n \
    \           {\n                result[i] = max;\n                is_min = true;\n\
    \            }\n        }\n        i++;\n    }\n    return result;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    bool is_min = true;\n    long min = lst[0];\n    long max = lst[0];\n   \
    \ int min_index = 0;\n    int max_index = 0;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n        {\n            min = lst[i];\n\
    \            min_index = i;\n        }\n        if (lst[i] > max)\n        {\n\
    \            max = lst[i];\n            max_index = i;\n        }\n    }\n   \
    \ result[0] = min;\n    if (min_index == max_index)\n    {\n        for (int i\
    \ = 1; i < lst.length; i++)\n            result[i] = lst[i];\n        return result;\n\
    \    }\n    result[1] = max;\n    int index = 2;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (i == min_index || i == max_index)\n            continue;\n\
    \        if (is_min)\n        {\n            result[index] = lst[i];\n       \
    \     is_min = false;\n        }\n        else\n        {\n            result[index]\
    \ = lst[i];\n            is_min = true;\n        }\n        index++;\n    }\n\
    \    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n \
    \   long[] result = new long[lst.length];\n    long[] lst_copy = lst.dup;\n  \
    \  sort(lst_copy);\n    bool is_min = true;\n    foreach (i, ref elem; lst)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = lst_copy[0];\n\
    \            lst_copy = lst_copy[1..$];\n        }\n        else\n        {\n\
    \            result[i] = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0) \n    {\n        return lst;\n    }\n    auto min = min(lst);\n\
    \    auto max = max(lst);\n    auto min_index = indexOf(lst, min);\n    auto max_index\
    \ = indexOf(lst, max);\n    long[] result = new long[lst.length];\n    result[0]\
    \ = min;\n    result[1] = max;\n    long[] lst_without_min_max = lst[min_index..max_index]\
    \ ~ lst[max_index+1..$];\n    long[] lst_without_min_max_sorted = sort(lst_without_min_max);\n\
    \    for (int i = 2; i < lst.length; i++) \n    {\n        if (i % 2 == 0) \n\
    \        {\n            result[i] = lst_without_min_max_sorted[i/2-1];\n     \
    \   }\n        else \n        {\n            result[i] = lst_without_min_max_sorted[lst_without_min_max_sorted.length\
    \ - i/2 - 1];\n        }\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    bool asc = true;\n    int i = 0;\n    foreach (e; sorted)\n\
    \    {\n        res[i] = e;\n        i += asc ? 1 : -1;\n        asc = !asc;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] tmp = lst.dup;\n    int i\
    \ = 0;\n    while (tmp.length > 0)\n    {\n        res[i] = tmp[0];\n        tmp\
    \ = tmp[1..$];\n        if (tmp.length == 0)\n            break;\n        res[i+1]\
    \ = tmp[$-1];\n        tmp = tmp[0..$-1];\n        i += 2;\n    }\n    return\
    \ res;\n}\n/*\n    Given array of integers, return array in strange order.\n \
    \   Strange sorting, is when you start with the minimum value,\n    then maximum\
    \ of the remaining integers, then minimum and so on.", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto res = new long[](lst.length);\n\
    \    auto i = 0;\n    auto j = lst.length - 1;\n    while (i <= j)\n    {\n  \
    \      res[i] = min;\n        res[j] = max;\n        i++;\n        j--;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    long min = sorted[0];\n    long max = sorted[$ - 1];\n    long i = 0;\n \
    \   while (i < lst.length)\n    {\n        res[i] = min;\n        i++;\n     \
    \   if (i < lst.length)\n        {\n            res[i] = max;\n            i++;\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++]\
    \ = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n    \
    \    {\n            res[i] = lst[i];\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst[i];\n            j--;\n        }\n      \
    \  is_min = !is_min;\n    }\n    return res;\n}", "{\n    auto lst_sorted = lst.dup;\n\
    \    lst_sorted.sort;\n    lst_sorted.reverse;\n    long[] result = new long[lst.length];\n\
    \    foreach (i, e; lst)\n    {\n        if (i % 2 == 0)\n        {\n        \
    \    result[i] = lst_sorted[0];\n            lst_sorted = lst_sorted[1..$];\n\
    \        }\n        else\n        {\n            result[i] = lst_sorted[$-1];\n\
    \            lst_sorted = lst_sorted[0..$-1];\n        }\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length == 0)\n            break;\n       \
    \ res[i] = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    auto min = minElement(lst);\n    auto max = maxElement(lst);\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    while (i < lst.length)\n  \
    \  {\n        if (i % 2 == 0)\n        {\n            res[i] = min;\n        \
    \    min = minElement(lst[lst != min]);\n        }\n        else\n        {\n\
    \            res[i] = max;\n            max = maxElement(lst[lst != max]);\n \
    \       }\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int[] idx\
    \ = new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n        idx[i]\
    \ = i;\n    idx.sort!((a, b) => lst[a] < lst[b]);\n    int i = 0;\n    while (i\
    \ < lst.length)\n    {\n        res[i] = lst[idx[i]];\n        i += 2;\n    }\n\
    \    i = 1;\n    while (i < lst.length)\n    {\n        res[i] = lst[idx[lst.length\
    \ - i]];\n        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        res[i] = lst_copy[0];\n        lst_copy = lst_copy[1..$];\n        if\
    \ (lst_copy.length > 0)\n        {\n            res[i+1] = lst_copy[$-1];\n  \
    \          lst_copy = lst_copy[0..$-2];\n        }\n        i += 2;\n    }\n \
    \   return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto\
    \ min_max = minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n\
    \    long[] result = new long[lst.length];\n    bool is_min = true;\n    int i\
    \ = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n        {\n  \
    \          if (lst[i] == min)\n            {\n                result[i] = min;\n\
    \                is_min = false;\n                i++;\n            }\n      \
    \  }\n        else\n        {\n            if (lst[i] == max)\n            {\n\
    \                result[i] = max;\n                is_min = true;\n          \
    \      i++;\n            }\n        }\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n   \
    \ foreach (i, e; lst)\n    {\n        if (is_min)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0) return lst;\n    long[] res = new long[lst.length];\n \
    \   int i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i\
    \ <= j) {\n        if (asc) {\n            res[i] = lst[i];\n            i++;\n\
    \        } else {\n            res[j] = lst[i];\n            j--;\n        }\n\
    \        asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    foreach (i, ref\
    \ e; result)\n    {\n        if (is_min)\n        {\n            e = sorted[0];\n\
    \            sorted = sorted[1 .. $];\n        }\n        else\n        {\n  \
    \          e = sorted[$ - 1];\n            sorted = sorted[0 .. $ - 1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            auto min = minElement(lst);\n\
    \            res[i] = min;\n            lst = lst[0..$-1];\n            i++;\n\
    \        }\n        else\n        {\n            auto max = maxElement(lst);\n\
    \            res[j] = max;\n            lst = lst[1..$];\n            j--;\n \
    \       }\n        is_min = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ tmp = lst.dup;\n    int i = 0;\n    while (tmp.length != 0)\n    {\n       \
    \ res[i] = tmp[0];\n        tmp = tmp[1..$];\n        if (tmp.length == 0)\n \
    \           break;\n        res[i + 1] = tmp[$ - 1];\n        tmp = tmp[0..$ -\
    \ 2];\n        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length ==\
    \ 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            result[i] = min(lst);\n\
    \            lst.remove(result[i]);\n            i++;\n        }\n        else\n\
    \        {\n            result[j] = max(lst);\n            lst.remove(result[j]);\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while\
    \ (i <= j)\n    {\n        if (is_min)\n        {\n            res[i] = lst[minIndex(lst)];\n\
    \            lst[minIndex(lst)] = long.max;\n            i++;\n        }\n   \
    \     else\n        {\n            res[j] = lst[maxIndex(lst)];\n            lst[maxIndex(lst)]\
    \ = long.min;\n            j--;\n        }\n        is_min = !is_min;\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0) return lst;\n    long[] res\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ asc = true;\n    while (i <= j)\n    {\n        if (asc)\n        {\n      \
    \      res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\n/*", "{\n    if (lst.length == 0) return lst;\n  \
    \  long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n    bool\
    \ asc = true;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n      \
    \  if (asc)\n        {\n            res[i] = lst_copy.min;\n            lst_copy.remove(lst_copy.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy.max;\n    \
    \        lst_copy.remove(lst_copy.max);\n        }\n        i++;\n        asc\
    \ = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ [];\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n\
    \    bool asc = true;\n    size_t i = 0;\n    while (i < lst.length)\n    {\n\
    \        if (asc)\n        {\n            res[i] = sorted[0];\n            sorted\
    \ = sorted[1..$];\n        }\n        else\n        {\n            res[i] = sorted[$-1];\n\
    \            sorted = sorted[0..$-1];\n        }\n        i++;\n        asc =\
    \ !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n\
    \    sorted.sort();\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach\
    \ (e; lst)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] =\
    \ sorted[i / 2];\n        }\n        else\n        {\n            result[i] =\
    \ sorted[j];\n            j--;\n        }\n        i++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    long[] res = new long[lst.length];\n   \
    \ int i = 0;\n    while (i < lst.length)\n    {\n        if (i % 2 == 0)\n   \
    \     {\n            res[i] = min;\n            min = minElement(lst[i..$]);\n\
    \        }\n        else\n        {\n            res[i] = max;\n            max\
    \ = maxElement(lst[i..$]);\n        }\n        i++;\n    }\n    return res;\n}",
  "{\n    long[] result;\n    if (lst.length == 0)\n        return lst;\n    result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n  \
    \  bool is_min = true;\n    size_t i = 0;\n    size_t j = 0;\n    while (i < lst.length)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = sorted[j];\n \
    \           j++;\n        }\n        else\n        {\n            result[i] =\
    \ sorted[sorted.length - j];\n        }\n        is_min = !is_min;\n        i++;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    auto minMax = minMaxElement(lst);\n\
    \    res[0] = minMax[0];\n    res[1] = minMax[1];\n    long[] rem = lst[2..$];\n\
    \    int i = 2;\n    while (rem.length > 0)\n    {\n        auto minMax = minMaxElement(rem);\n\
    \        res[i] = minMax[0];\n        res[i+1] = minMax[1];\n        rem = rem[2..$];\n\
    \        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n \
    \       return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j = sorted.length -\
    \ 1;\n    foreach (e; lst)\n    {\n        if (i % 2 == 0)\n        {\n      \
    \      result[i] = sorted[i / 2];\n        }\n        else\n        {\n      \
    \      result[i] = sorted[j];\n            j--;\n        }\n        i++;\n   \
    \ }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    auto min = minElement(lst);\n    auto max = maxElement(lst);\n    long[]\
    \ res = new long[lst.length];\n    res[0] = min;\n    res[1] = max;\n    int i\
    \ = 2;\n    int j = 1;\n    while (i < lst.length)\n    {\n        if (i % 2 ==\
    \ 0)\n        {\n            res[i] = minElement(lst[j..$]);\n            ++j;\n\
    \        }\n        else\n        {\n            res[i] = maxElement(lst[j..$]);\n\
    \            ++j;\n        }\n        ++i;\n    }\n    return res;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k] = sorted[i];\n\
    \        k++;\n        if (i != j)\n        {\n            res[k] = sorted[j];\n\
    \            k++;\n        }\n        i++;\n        j--;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k] = sorted[i];\n\
    \        k++;\n        if (i != j)\n        {\n            res[k] = sorted[j];\n\
    \            k++;\n        }\n        i++;\n        j--;\n    }\n    return res;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_sorted = lst.dup;\n    lst_sorted.sort;\n    int i = 0;\n    int\
    \ j = lst_sorted.length - 1;\n    bool is_min = true;\n    foreach (el; lst_sorted)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = el;\n           \
    \ i++;\n        }\n        else\n        {\n            res[j] = el;\n       \
    \     j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    int i = 0;\n    while (lst.length > 0)\n    {\n        result[i] = lst[0];\n\
    \        lst = lst[1..$];\n        if (lst.length == 0)\n            break;\n\
    \        result[i+1] = lst[$-1];\n        lst = lst[0..$-1];\n        i += 2;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    int k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n\
    \        if (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n\
    }\n/*", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new\
    \ long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n       \
    \     res[i] = lst[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = lst[i];\n            j--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    auto min_max = minmax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n\
    \    long[] result = new long[lst.length];\n    bool is_min = true;\n    int i\
    \ = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n        {\n  \
    \          if (min != max)\n            {\n                result[i] = min;\n\
    \                min++;\n                i++;\n            }\n            else\n\
    \            {\n                result[i] = min;\n                i++;\n     \
    \       }\n        }\n        else\n        {\n            if (min != max)\n \
    \           {\n                result[i] = max;\n                max--;\n    \
    \            i++;\n            }\n            else\n            {\n          \
    \      result[i] = max;\n                i++;\n            }\n        }\n    \
    \    is_min = !is_min;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_max = true;\n    int index\
    \ = 0;\n    while (sorted.length != 0)\n    {\n        if (is_max)\n        {\n\
    \            result[index] = sorted[sorted.length - 1];\n            sorted =\
    \ sorted[0..$-1];\n        }\n        else\n        {\n            result[index]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        is_max\
    \ = !is_max;\n        index++;\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n       \
    \ if (e < min)\n            min = e;\n        if (e > max)\n            max =\
    \ e;\n    }\n    int i = 0;\n    int j = lst.length - 1;\n    while (i <= j)\n\
    \    {\n        res[i] = min;\n        res[j] = max;\n        i++;\n        j--;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    auto min_max = minMax(lst);\n    long min = min_max[0];\n    long max = min_max[1];\n\
    \    long[] result = new long[lst.length];\n    bool is_min = true;\n    long[]\
    \ remaining = lst;\n    foreach (i; 0 .. lst.length)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = min;\n            remaining = remaining.filter!(x\
    \ => x != min);\n        }\n        else\n        {\n            result[i] = max;\n\
    \            remaining = remaining.filter!(x => x != max);\n        }\n      \
    \  if (remaining.length == 0)\n            break;\n        min_max = minMax(remaining);\n\
    \        min = min_max[0];\n        max = min_max[1];\n        is_min = !is_min;\n\
    \    }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort;\n    bool ascending = true;\n    int index = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        if (ascending)\n        {\n            result[index] =\
    \ sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n  \
    \      {\n            result[index] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        index++;\n        ascending = !ascending;\n    }\n    return\
    \ result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n  \
    \  bool is_min = true;\n    foreach (i, e; lst)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = sorted[0];\n            sorted = sorted[1..$];\n\
    \        }\n        else\n        {\n            result[i] = sorted[$-1];\n  \
    \          sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n  \
    \  }\n    return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    \n    long[] result = new long[lst.length];\n    long[] copy = lst.dup;\n\
    \    sort(copy);\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n\
    \    while (i <= j)\n    {\n        result[k++] = copy[i++];\n        if (i <=\
    \ j)\n            result[k++] = copy[j--];\n    }\n    return result;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_sorted = lst.dup;\n    lst_sorted.sort;\n    int i = 0;\n    int\
    \ j = lst_sorted.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n    \
    \    res[k] = lst_sorted[i];\n        i++;\n        k++;\n        if (i <= j)\n\
    \        {\n            res[k] = lst_sorted[j];\n            j--;\n          \
    \  k++;\n        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    foreach (idx, ref\
    \ elem; lst)\n    {\n        if (is_min)\n        {\n            result[idx] =\
    \ sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n  \
    \      {\n            result[idx] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}", "{\n   \
    \ if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length >\
    \ 0)\n    {\n        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        i++;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i++;\n\
    \        }\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    else\n    {\n        long[] sorted = new long[lst.length];\n\
    \        long[] sorted_lst = lst.dup;\n        sorted_lst.sort;\n        long[]\
    \ reversed_lst = sorted_lst.dup;\n        reversed_lst.reverse;\n        bool\
    \ is_reversed = false;\n        foreach (i, e; lst)\n        {\n            if\
    \ (is_reversed)\n            {\n                sorted[i] = reversed_lst.front;\n\
    \                reversed_lst.popFront;\n            }\n            else\n   \
    \         {\n                sorted[i] = sorted_lst.front;\n                sorted_lst.popFront;\n\
    \            }\n            is_reversed = !is_reversed;\n        }\n        return\
    \ sorted;\n    }\n}", "{\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    long[] reversed = sorted.dup.reverse;\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    while (i < lst.length)\n    {\n        if\
    \ (k % 2 == 0)\n        {\n            res[i] = sorted[j];\n            j++;\n\
    \        }\n        else\n        {\n            res[i] = reversed[j];\n     \
    \       j++;\n        }\n        i++;\n        k++;\n    }\n    return res;\n}",
  "{\n    if (lst.length == 0)\n        return lst;\n    auto min_max = minmax(lst);\n\
    \    long min = min_max[0];\n    long max = min_max[1];\n    long[] res = new\
    \ long[lst.length];\n    bool is_min = true;\n    int i = 0;\n    while (i < lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = min;\n          \
    \  min = lst[i];\n        }\n        else\n        {\n            res[i] = max;\n\
    \            max = lst[i];\n        }\n        is_min = !is_min;\n        i++;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n   \
    \ sorted.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    foreach (el;\
    \ lst)\n    {\n        if (i % 2 == 0)\n        {\n            result[i] = sorted[i\
    \ / 2];\n        }\n        else\n        {\n            result[i] = sorted[j];\n\
    \            j--;\n        }\n        i++;\n    }\n    return result;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j =\
    \ lst.length - 1;\n    bool is_min = true;\n    foreach (elem; lst)\n    {\n \
    \       if (is_min)\n        {\n            res[i] = sorted[0];\n            sorted\
    \ = sorted[1..$];\n        }\n        else\n        {\n            res[i] = sorted[$-1];\n\
    \            sorted = sorted[0..$-1];\n        }\n        i++;\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n     \
    \   return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    foreach (i, ref e;\
    \ result)\n    {\n        if (asc)\n        {\n            e = sorted[0];\n  \
    \          sorted = sorted[1..$];\n        }\n        else\n        {\n      \
    \      e = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n   \
    \     asc = !asc;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\
    \ return lst;\n    long[] res = new long[lst.length];\n    long[] sorted = lst.dup.sort();\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j)\n    {\n        res[k++] = sorted[i++];\n        if (i <= j) res[k++]\
    \ = sorted[j--];\n    }\n    return res;\n}\n/*\n    Given array of integers,\
    \ return array in strange order.\n    Strange sorting, is when you start with\
    \ the minimum value,\n    then maximum of the remaining integers, then minimum\
    \ and so on.", "{\n    if (lst.length == 0)\n        return lst;\n    long[] result\
    \ = new long[lst.length];\n    int[] indexes = new int[lst.length];\n    for (int\
    \ i = 0; i < lst.length; i++)\n        indexes[i] = i;\n    indexes.sort!((a,\
    \ b) => lst[a] < lst[b]);\n    int i = 0;\n    int j = lst.length - 1;\n    int\
    \ k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst[indexes[i++]];\n\
    \        if (i <= j)\n            result[k++] = lst[indexes[j--]];\n    }\n  \
    \  return result;\n}", "{\n    if (lst.length == 0)\n        return lst;\n   \
    \ long[] result = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort();\n\
    \    bool asc = true;\n    int i = 0;\n    while (sorted.length > 0)\n    {\n\
    \        if (asc)\n        {\n            result[i] = sorted[0];\n           \
    \ sorted = sorted[1..$];\n        }\n        else\n        {\n            result[i]\
    \ = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n        i++;\n\
    \        asc = !asc;\n    }\n    return result;\n}", "{\n    if (lst.length ==\
    \ 0) \n    {\n        return lst;\n    }\n    auto min_max = minMax(lst);\n  \
    \  long[] result = new long[lst.length];\n    bool is_min = true;\n    foreach\
    \ (i, val; lst) \n    {\n        if (is_min) \n        {\n            result[i]\
    \ = min_max.min;\n            is_min = false;\n        } \n        else \n   \
    \     {\n            result[i] = min_max.max;\n            is_min = true;\n  \
    \      }\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n      \
    \  return lst;\n    long[] res = new long[lst.length];\n    long[] lst2 = lst.dup;\n\
    \    int i = 0;\n    while (lst2.length > 0)\n    {\n        res[i] = lst2.min;\n\
    \        lst2 = lst2.remove(lst2.min);\n        if (lst2.length > 0)\n       \
    \ {\n            res[i+1] = lst2.max;\n            lst2 = lst2.remove(lst2.max);\n\
    \        }\n        i += 2;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0) \n    {\n        return lst;\n    }\n    auto sorted_list = lst.dup;\n\
    \    sorted_list.sort;\n    auto min_max_list = new long[](lst.length);\n    for\
    \ (int i = 0; i < lst.length; i++) \n    {\n        if (i % 2 == 0) \n       \
    \ {\n            min_max_list[i] = sorted_list[i / 2];\n        } \n        else\
    \ \n        {\n            min_max_list[i] = sorted_list[lst.length - (i / 2)\
    \ - 1];\n        }\n    }\n    return min_max_list;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto res = new long[lst.length];\n\
    \    auto i = 0;\n    auto j = lst.length - 1;\n    auto k = 0;\n    while (i\
    \ <= j)\n    {\n        res[k++] = min;\n        res[k++] = max;\n        i++;\n\
    \        j--;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n    \
    \    return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    lst_copy.sort;\n    long[] lst_copy_rev = lst_copy.dup;\n  \
    \  lst_copy_rev.reverse;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n   \
    \ while (i < lst.length)\n    {\n        if (i % 2 == 0)\n        {\n        \
    \    res[i] = lst_copy[j];\n            j++;\n        }\n        else\n      \
    \  {\n            res[i] = lst_copy_rev[k];\n            k++;\n        }\n   \
    \     i++;\n    }\n    return res;\n}\n/*", "{\n    if (lst.length == 0)\n   \
    \     return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    long[] lst_copy_sorted = lst_copy.sort;\n    int i = 0;\n  \
    \  int j = lst_copy_sorted.length - 1;\n    bool flag = true;\n    foreach (elem;\
    \ lst_copy_sorted)\n    {\n        if (flag)\n        {\n            res[i] =\
    \ elem;\n            i++;\n        }\n        else\n        {\n            res[j]\
    \ = elem;\n            j--;\n        }\n        flag = !flag;\n    }\n    return\
    \ res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[] ret\
    \ = new long[lst.length];\n    long[] tmp = lst.dup;\n    int i = 0;\n    while\
    \ (tmp.length > 0)\n    {\n        ret[i] = tmp.min;\n        tmp = tmp.remove(tmp.min);\n\
    \        if (tmp.length > 0)\n        {\n            ret[i + 1] = tmp.max;\n \
    \           tmp = tmp.remove(tmp.max);\n        }\n        i += 2;\n    }\n  \
    \  return ret;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    auto\
    \ min = lst[0];\n    auto max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    while (i <= j)\n    {\n        res[i] = min;\n      \
    \  res[j] = max;\n        i++;\n        j--;\n    }\n    return res;\n}", "{\n\
    \    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j =\
    \ sorted.length - 1;\n    bool is_min = true;\n    foreach (elem; lst)\n    {\n\
    \        if (is_min)\n        {\n            result[i] = sorted[i];\n        \
    \    i++;\n        }\n        else\n        {\n            result[j] = sorted[j];\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    auto min_max = minmax(lst);\n\
    \    long min = min_max[0];\n    long max = min_max[1];\n    long[] result = new\
    \ long[lst.length];\n    bool is_min = true;\n    int index = 0;\n    while (index\
    \ < lst.length)\n    {\n        if (is_min)\n        {\n            result[index]\
    \ = min;\n            min++;\n        }\n        else\n        {\n           \
    \ result[index] = max;\n            max--;\n        }\n        is_min = !is_min;\n\
    \        index++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n}",
  "{\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool asc = true;\n    foreach(e; lst)\n    {\n        if(asc)\n  \
    \      {\n            res[i] = e;\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = e;\n            j--;\n        }\n        asc\
    \ = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return\
    \ lst;\n    auto lst_sorted = lst.dup;\n    lst_sorted.sort;\n    auto lst_sorted_reversed\
    \ = lst_sorted.dup;\n    lst_sorted_reversed.reverse;\n    auto result = new long[lst.length];\n\
    \    foreach (index, value; lst_sorted)\n    {\n        if (index % 2 == 0)\n\
    \            result[index] = value;\n        else\n            result[index] =\
    \ lst_sorted_reversed[index];\n    }\n    return result;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    long min = lst[0];\n    long max = lst[0];\n    foreach (el; lst)\n\
    \    {\n        if (el < min)\n            min = el;\n        if (el > max)\n\
    \            max = el;\n    }\n    int min_i = 0;\n    int max_i = lst.length\
    \ - 1;\n    while (min_i <= max_i)\n    {\n        res[i++] = min;\n        if\
    \ (min_i < max_i)\n            res[i++] = max;\n        min_i++;\n        max_i--;\n\
    \    }\n    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n\
    \    long[] res = new long[lst.length];\n    long[] sorted = lst.dup;\n    sorted.sort;\n\
    \    int i = 0;\n    int j = sorted.length - 1;\n    int k = 0;\n    while (i\
    \ <= j)\n    {\n        res[k++] = sorted[i++];\n        if (i <= j)\n       \
    \     res[k++] = sorted[j--];\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int\
    \ i = 0;\n    while (lst.length > 0)\n    {\n        long min = lst[0];\n    \
    \    long max = lst[0];\n        foreach (elem; lst)\n        {\n            if\
    \ (elem < min)\n                min = elem;\n            if (elem > max)\n   \
    \             max = elem;\n        }\n        result[i] = min;\n        result[i\
    \ + 1] = max;\n        i += 2;\n        lst = lst.filter!(e => e != min && e !=\
    \ max);\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    lst_copy.sort;\n    int i = 0;\n    int j = lst_copy.length - 1;\n    while\
    \ (i <= j)\n    {\n        res[i] = lst_copy[i];\n        i++;\n        if (i\
    \ <= j)\n        {\n            res[i] = lst_copy[j];\n            j--;\n    \
    \    }\n        i++;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool flag = true;\n    foreach (e; lst)\n  \
    \  {\n        if (flag)\n        {\n            res[i] = e;\n            i++;\n\
    \        }\n        else\n        {\n            res[j] = e;\n            j--;\n\
    \        }\n        flag = !flag;\n    }\n    return res;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_sorted = lst.dup;\n    lst_sorted.sort;\n    bool asc = true;\n    int i\
    \ = 0;\n    while (lst_sorted.length > 0)\n    {\n        if (asc)\n        {\n\
    \            res[i] = lst_sorted[0];\n            lst_sorted = lst_sorted[1..$];\n\
    \        }\n        else\n        {\n            res[i] = lst_sorted[$-1];\n \
    \           lst_sorted = lst_sorted[0..$-1];\n        }\n        i++;\n      \
    \  asc = !asc;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n   \
    \     return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j = sorted.length -\
    \ 1;\n    while (i < j)\n    {\n        result[i] = sorted[i];\n        result[j]\
    \ = sorted[j];\n        i++;\n        j--;\n    }\n    if (i == j)\n        result[i]\
    \ = sorted[i];\n    return result;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach (i;\
    \ lst)\n    {\n        if (i < min)\n            min = i;\n        if (i > max)\n\
    \            max = i;\n    }\n    auto res = new long[lst.length];\n    auto i\
    \ = 0;\n    auto j = lst.length - 1;\n    auto k = 0;\n    while (k < lst.length)\n\
    \    {\n        if (k % 2 == 0)\n        {\n            res[k] = min;\n      \
    \      i++;\n        }\n        else\n        {\n            res[k] = max;\n \
    \           j--;\n        }\n        k++;\n    }\n    return res;\n}", "{\n  \
    \  if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    long[] tmp = lst.dup;\n    tmp.sort;\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool flag = true;\n    foreach (e; tmp)\n    {\n        if (flag)\n\
    \        {\n            res[i] = e;\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = e;\n            j--;\n        }\n        flag\
    \ = !flag;\n    }\n    return res;\n}", "{\n    auto lst_len = lst.length;\n \
    \   if (lst_len == 0)\n        return lst;\n    auto min_max_tuple = minmax(lst);\n\
    \    auto min_val = min_max_tuple[0];\n    auto max_val = min_max_tuple[1];\n\
    \    auto min_idx = lst.indexOf(min_val);\n    auto max_idx = lst.indexOf(max_val);\n\
    \    auto new_lst = new long[lst_len];\n    new_lst[0] = min_val;\n    new_lst[1]\
    \ = max_val;\n    auto lst_without_min_max = lst.dup;\n    lst_without_min_max.remove(min_idx);\n\
    \    lst_without_min_max.remove(max_idx);\n    auto lst_without_min_max_len =\
    \ lst_without_min_max.length;\n    auto i = 2;\n    while (i < lst_len)\n    {\n\
    \        auto min_max_tuple = minmax(lst_without_min_max);\n        auto min_val\
    \ = min_max_tuple[0];\n        auto max_val = min_max_tuple[1];\n        auto\
    \ min_idx = lst_without_min_max.indexOf(min_val);\n        auto max_idx = lst_without_min_max.indexOf(max_val);\n\
    \        new_lst[i] = min_val;\n        new_lst[i+1] = max_val;\n        lst_without_min_max.remove(min_idx);\n\
    \        lst_without_min_max.remove(max_idx);\n        i += 2;\n    }\n    return\
    \ new_lst;\n}", "{\n    if (lst.length == 0) \n    {\n        return lst;\n  \
    \  }\n    long[] sorted = new long[lst.length];\n    long[] lst_copy = lst.dup;\n\
    \    long min = lst_copy[0];\n    long max = lst_copy[0];\n    foreach (i; lst_copy)\
    \ \n    {\n        if (i < min) \n        {\n            min = i;\n        }\n\
    \        if (i > max) \n        {\n            max = i;\n        }\n    }\n  \
    \  int i = 0;\n    while (lst_copy.length > 0) \n    {\n        sorted[i] = min;\n\
    \        lst_copy = lst_copy.remove(min);\n        i++;\n        if (lst_copy.length\
    \ > 0) \n        {\n            sorted[i] = max;\n            lst_copy = lst_copy.remove(max);\n\
    \            i++;\n        }\n        if (lst_copy.length > 0) \n        {\n \
    \           min = lst_copy[0];\n            max = lst_copy[0];\n            foreach\
    \ (i; lst_copy) \n            {\n                if (i < min) \n             \
    \   {\n                    min = i;\n                }\n                if (i\
    \ > max) \n                {\n                    max = i;\n                }\n\
    \            }\n        }\n    }\n    return sorted;\n}", "{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto sorted = lst.dup;\n    sorted.sort;\n \
    \   long[] result = new long[lst.length];\n    bool is_min = true;\n    int i\
    \ = 0;\n    while (sorted.length != 0)\n    {\n        if (is_min)\n        {\n\
    \            result[i] = sorted[0];\n            sorted = sorted[1..$];\n    \
    \    }\n        else\n        {\n            result[i] = sorted[$-1];\n      \
    \      sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n      \
    \  i++;\n    }\n    return result;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] res = new long[lst.length];\n    auto min = minElement(lst);\n\
    \    auto max = maxElement(lst);\n    int i = 0;\n    while (i < lst.length)\n\
    \    {\n        res[i] = min;\n        min = minElement(lst[i .. $]);\n      \
    \  i++;\n        if (i < lst.length)\n        {\n            res[i] = max;\n \
    \           max = maxElement(lst[i .. $]);\n            i++;\n        }\n    }\n\
    \    return res;\n}", "{\n    if (lst.length == 0)\n        return lst;\n    long[]\
    \ res = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n \
    \   bool flag = true;\n    foreach (long x; lst)\n    {\n        if (flag)\n \
    \       {\n            res[i] = x;\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = x;\n            j--;\n        }\n        flag\
    \ = !flag;\n    }\n    return res;\n}", "{\n    if (lst.length == 0)\n       \
    \ return lst;\n    long[] result = new long[lst.length];\n    long[] sorted =\
    \ lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    int i = 0;\n    while\
    \ (sorted.length > 0)\n    {\n        if (is_min)\n        {\n            result[i]\
    \ = sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n\
    \        {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }", "{\n    if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    auto minmax = minmaxElement(lst);\n    res[0] = minmax[0];\n    res[1] =\
    \ minmax[1];\n    long[] remaining = lst[2..$];\n    long[] remaining_sorted =\
    \ sort(remaining);\n    long[] remaining_sorted_reversed = remaining_sorted[$-1..0];\n\
    \    long[] res_remaining = res[2..$];\n    res_remaining[] = remaining_sorted;\n\
    \    res_remaining[] = remaining_sorted_reversed;\n    return res;\n}", "{\n \
    \   if (lst.length == 0)\n        return lst;\n    long[] res = new long[lst.length];\n\
    \    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <=\
    \ j)\n    {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}\n/*", "{\n    if (lst.length == 0)\n\
    \        return lst;\n    long[] res = new long[lst.length];\n    int[] idx =\
    \ new int[lst.length];\n    for (int i = 0; i < lst.length; i++)\n        idx[i]\
    \ = i;\n    idx.sort!((a, b) => lst[a] < lst[b]);\n    int i = 0;\n    int j =\
    \ lst.length - 1;\n    bool inc = true;\n    foreach (k; idx)\n    {\n       \
    \ if (inc)\n            res[i++] = lst[k];\n        else\n            res[j--]\
    \ = lst[k];\n        inc = !inc;\n    }\n    return res;\n}", "{\n    long[] res\
    \ = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    bool\
    \ is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n        {\n\
    \            res[i] = lst[i];\n            i++;\n        }\n        else\n   \
    \     {\n            res[j] = lst[i];\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
