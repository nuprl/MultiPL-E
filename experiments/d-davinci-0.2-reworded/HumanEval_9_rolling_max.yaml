name: HumanEval_9_rolling_max
language: d
prompt: "import std.typecons;\nimport std.math;\n/*\n From a given array of integers,\
  \ generate an array of rolling maximum element found until given moment\n    in\
  \ the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
  \ 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n"
tests: "unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([])\
  \ == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L,\
  \ 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L])\
  \ == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  if (number > max) \n        {\n            max = number;\n        }\n     \
    \   result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers)\n    {\n        if(number > max)\n        {\n            max = number;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        if (number > max) \n\
    \        {\n            max = number;\n        }\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++) \n    {\n        sum += numbers[i];\n        result[i] = sum;\n    }\n\
    \    return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling mean of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_mean([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1.5L, 2L, 2L, 2.5L,\
    \ 3L, 3L]\n*/\nlong[] rolling_mean(long[]", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (long i = 0; i < numbers.length; i++)\n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (long i = 0; i < numbers.length; i++)\n \
    \   {\n        min = min(min, numbers[i]);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    for (long i = 0; i <\
    \ numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i] =\
    \ sum;\n    }\n    return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling product of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers)\
    \ \n{\n   ", "{\n    long[] result = new long[numbers.length];\n    long max_so_far\
    \ = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max_so_far = max(max_so_far, number);\n        result[i + 1]\
    \ = max_so_far;\n    }\n    return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min_so_far = numbers[0];\n    result[0]\
    \ = min_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n        min_so_far\
    \ = min(min_so_far, number);\n        result[i + 1] = min_so_far;\n    }\n   \
    \ return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum_so_far = numbers[0];\n    result[0] = sum_so_far;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        sum_so_far += number;\n\
    \        result[i + 1] = sum_so_far;\n    }\n    return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling product of elements",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if\
    \ (n > max) \n        {\n            max = n;\n        }\n        result[i + 1]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long current_max =\
    \ numbers[0];\n    result[0] = current_max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        current_max = max(current_max, number);\n        result[i +\
    \ 1] = current_max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        if (numbers[i] > max) \n        {\n\
    \            max = numbers[i];\n        }\n        result[i] = max;\n    }\n \
    \   return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        if (numbers[i] < min) \n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling average of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, e; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, e);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling minimum element found until\
    \ given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n    \
    \    result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i+1] = max(result[i], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n \
    \   From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min\
    \ = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n    From a given array of integers, generate an array of rolling sum of\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \    From a given array of integers, generate an array of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[]\
    \ rolling_product(long[] numbers) \n", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ if (number > max) \n        {\n            max = number;\n        }\n      \
    \  result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i],\
    \ number);\n    }\n    return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, number; numbers[1..$]) \n    {\n        result[i + 1] = min(result[i], number);\n\
    \    }\n    return result;\n}\n/*\n    From a given array of integers, generate\
    \ an array of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n\
    \    return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n  \
    \      max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}\n/*\n    From a given array of integers, generate an array of rolling\
    \ minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min\
    \ = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n    From a given array of integers, generate an array of rolling sum of\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \    From a given array of integers, generate an array of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[]\
    \ rolling_product(long[] numbers) \n", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, num; numbers) \n    {\n        max = max(max, num);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (idx, val; numbers[1\
    \ .. $]) \n    {\n        if (val > max) \n        {\n            max = val;\n\
    \        }\n        result[idx + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, v);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i],\
    \ number);\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, number; numbers[1..$]) \n    {\n        result[i + 1] = min(result[i], number);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max_so_far = numbers[0];\n    foreach(i,\
    \ n; numbers) \n    {\n        max_so_far = max(max_so_far, n);\n        result[i]\
    \ = max_so_far;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] >\
    \ max)\n        {\n            max = numbers[i];\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    for (int i = 0; i < numbers.length;\
    \ i++)\n    {\n        if (numbers[i] < min)\n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \ From a given array of integers, generate an array of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        if (n > max) \n        {\n\
    \            max = n;\n        }\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min,\
    \ number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    foreach(i, number; numbers)\n    {\n \
    \       max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, e; numbers[1\
    \ .. $]) \n    {\n        if (e > max) \n        {\n            max = e;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for\
    \ (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n       \
    \ result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers)\n\
    \    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n\
    \    {\n        max = max(max, n);\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, e; numbers[1 .. $])\n \
    \   {\n        if (e > max)\n        {\n            max = e;\n        }\n    \
    \    result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $])\n    {\n        if (n > max)\n          \
    \  max = n;\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n     \
    \   if (number > max) \n        {\n            max = number;\n        }\n    \
    \    result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, n; numbers[1 .. $]) \n    {\n        max = max(max, n);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}\n/*\n    From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long min = numbers[0];\n \
    \   for (int i = 0; i < numbers.length; i++) \n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n    From a given\
    \ array of integers, generate an array of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \    From a given array of integers, generate an array of rolling average of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L, 2L, 2L, 2L, 2L]\n*/\nlong[] rolling_avg(long[]\
    \ numbers)", "{\n    long[] result = new long[numbers.length];\n    long max =\
    \ numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1 .. $])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ if (number > max) \n        {\n            max = number;\n        }\n      \
    \  result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    foreach(i, n; numbers)\n\
    \    {\n        max = max(max, n);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n\
    \    {\n        if (n > max)\n            max = n;\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    result[0] = max_so_far;\n    foreach (i, number; numbers[1 .. $]) \n    {\n\
    \        max_so_far = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        if (numbers[i] > max)\n        {\n            max = numbers[i];\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        if (number\
    \ > max) \n        {\n            max = number;\n        }\n        result[i +\
    \ 1] = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\
    \ \n    {\n        max_so_far = max(max_so_far, numbers[i]);\n        result[i]\
    \ = max_so_far;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1 .. $]) \n    {\n\
    \        result[i + 1] = max(result[i], number);\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n    \
    \    max = max(max, number);\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    foreach(i, e; numbers) \n    {\n        if (e > max) \n \
    \       {\n            max = e;\n        }\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i+1] = max;\n    }\n    return result;\n}", "{\n  \
    \  long[] result = new long[numbers.length];\n    long max = numbers[0];\n   \
    \ result[0] = max;\n    for (int i = 1; i < numbers.length; i++) \n    {\n   \
    \     max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n      \
    \  max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, v; numbers[1 .. $])\n    {\n        max\
    \ = max(max, v);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n       \
    \ max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$])\n    {\n       \
    \ if (number > max)\n        {\n            max = number;\n        }\n       \
    \ result[i+1] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\
    \ \n    {\n        max = max(max, number);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n   \
    \ {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n  \
    \  return result;\n}", "{\n    long[] result = new long[numbers.length];\n   \
    \ long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1..$]) \n\
    \    {\n        min = min(min, number);\n        result[i + 1] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n  \
    \  foreach (i, number; numbers[1..$]) \n    {\n        sum += number;\n      \
    \  result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L,", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i],\
    \ number);\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    foreach(i, number; numbers) \n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ number; numbers)\n    {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long min = numbers[0];\n    foreach(i,\
    \ number; numbers)\n    {\n        min = min(min, number);\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n    From a given array of integers,\
    \ generate an array of rolling sum of elements found until given moment\n    in\
    \ the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L,\
    \ 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i,\
    \ number; numbers)\n    {\n        sum += number;\n        result[i] = sum;\n\
    \    }\n    return result;\n}\n/*\n    From a given array of integers, generate\
    \ an array of rolling product of elements found until given moment\n    in the\
    \ sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L,\
    \ 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long product = numbers[0];\n\
    \    fore", "{\n    long[] result = new long[numbers.length];\n    long max =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n        max\
    \ = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $])\n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1..$]) \n    {\n      \
    \  if (number > max) \n        {\n            max = number;\n        }\n     \
    \   result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\
    \ \n    {\n        if (number > max) \n        {\n            max = number;\n\
    \        }\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i], number);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = min(result[i], number);\n  \
    \  }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n   \
    \ long[] result", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        max_so_far = max(max_so_far, number);\n    \
    \    result[i + 1] = max_so_far;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    result[0] = min;\n    foreach (i, number; numbers[1 .. $])\
    \ \n    {\n        min = min(min, number);\n        result[i + 1] = min;\n   \
    \ }\n    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    result[0] = sum;\n\
    \    foreach (i, number; numbers[1 .. $]) \n    {\n        sum += number;\n  \
    \      result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = 0;\n    foreach(i, number; numbers)\n    {\n        max = max(max,\
    \ number);\n        result[i] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        result[i + 1] = max(result[i],\
    \ number);\n    }\n    return result;\n}\n/*\n From a given array of integers,\
    \ generate an array of rolling minimum element found until given moment\n    in\
    \ the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L,\
    \ 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[]\
    \ result = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach\
    \ (i, number; numbers[1..$]) \n    {\n        result[i + 1] = min(result[i], number);\n\
    \    }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1..$]) \n    {\n        result[i + 1] = result[i] + number;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n   \
    \ long[] result", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers)\n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1..$]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        max = max(max, numbers[i]);\n    \
    \    result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result =\
    \ new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i\
    \ < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n       \
    \ result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number; numbers)\n\
    \    {\n        max = max(max, number);\n        result[i] = max;\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling minimum element found until given moment\n    in the sequence.\n   \
    \ >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    foreach(i, number; numbers)\n    {\n        min\
    \ = min(min, number);\n        result[i] = min;\n    }\n    return result;\n}\n\
    /*\n From a given array of integers, generate an array of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    foreach(i, number; numbers)\n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers[0];\n    foreach(i", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}\n/*\n From a given array of integers, generate an\
    \ array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    result[0] = min;\n  \
    \  foreach (i, n; numbers[1 .. $]) \n    {\n        min = min(min, n);\n     \
    \   result[i + 1] = min;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    result[0] = sum;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        sum\
    \ += n;\n        result[i + 1] = sum;\n    }\n    return result;\n}\n/*\n From\
    \ a given array of integers, generate an array of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, v; numbers[1 .. $]) \n    {\n        max = max(max, v);\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n     \
    \   result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array of\
    \ integers, generate an array of rolling minimum element found until given moment\n\
    \    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n \
    \   long[] result = new long[numbers.length];\n    long min = numbers[0];\n  \
    \  for (int i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n\
    {\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    result[0] = max_so_far;\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        max_so_far = max(max_so_far, number);\n        result[i+1] = max_so_far;\n\
    \    }\n    return result;\n}\n/*\n    From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min_so_far = numbers[0];\n    result[0] = min_so_far;\n    foreach (i,\
    \ number; numbers[1..$]) \n    {\n        min_so_far = min(min_so_far, number);\n\
    \        result[i+1] = min_so_far;\n    }\n    return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum_so_far\
    \ = numbers[0];\n    result[0] = sum_so_far;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        sum_so_far += number;\n        result[i+1] = sum_so_far;\n\
    \    }\n    return result;\n}\n/*\n    From a given array of integers, generate\
    \ an array of rolling product of elements", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    foreach(i, number; numbers)\n    {\n \
    \       max_so_far = max(max_so_far, number);\n        result[i] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1\
    \ .. $]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, val; numbers) \n    {\n        max = max(max, val);\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    foreach(i, val; numbers)\
    \ \n    {\n        min = min(min, val);\n        result[i] = min;\n    }\n   \
    \ return result;\n}\n/*\n From a given array of integers, generate an array of\
    \ rolling sum of elements found until given moment\n    in the sequence.\n   \
    \ >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L,\
    \ 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result =\
    \ new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, val; numbers)\
    \ \n    {\n        sum += val;\n        result[i] = sum;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling product of\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\n\
    long[] rolling_product(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long product = numbers", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1..$])\
    \ \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n   \
    \ }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, e; numbers[1\
    \ .. $]) \n    {\n        if (e > max) \n        {\n            max = e;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ number; numbers) \n    {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ min = min(min, number);\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling sum of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers[0];\n    fore", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers)\n    {\n        if (n\
    \ > max)\n            max = n;\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n    \
    \    max = max(max, number);\n        result[i + 1] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n      \
    \  max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return result;\n\
    }\n/*\n    From a given array of integers, generate an array of rolling minimum\
    \ element found until given moment\n    in the sequence.\n    >>> rolling_min([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        min\
    \ = min(min, numbers[i]);\n        result[i] = min;\n    }\n    return result;\n\
    }\n/*\n    From a given array of integers, generate an array of rolling sum of\
    \ elements found until given moment\n    in the sequence.\n    >>> rolling_sum([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \    From a given array of integers, generate an array of rolling product of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_product([1L,\
    \ 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[]\
    \ rolling_product(long[] numbers) \n", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n     \
    \   max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++) \n    {\n        max = max(max,\
    \ numbers[i]);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   foreach(i, number; numbers)\n    {\n        if(number > max)\n        {\n\
    \            max = number;\n        }\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    foreach(i, v; numbers) \n    {\n        max = max(max, v);\n\
    \        result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        max = max(max, number);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers) \n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n     \
    \   if (number > max) \n        {\n            max = number;\n        }\n    \
    \    result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++) \n    {\n        if (numbers[i] > max) \n        {\n\
    \            max = numbers[i];\n        }\n        result[i] = max;\n    }\n \
    \   return result;\n}\n/*\n    From a given array of integers, generate an array\
    \ of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n\
    \    long min = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        if (numbers[i] < min) \n        {\n            min = numbers[i];\n\
    \        }\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n        sum\
    \ += numbers[i];\n        result[i] = sum;\n    }\n    return result;\n}\n/*\n\
    \    From a given array of integers, generate an array of rolling average of elements\
    \ found until given moment\n    in the sequence.\n    >>> rolling_avg([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max)\n            max = n;\n        result[i\
    \ + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, v; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ v);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ number; numbers) \n    {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling minimum element found until given moment\n    in the sequence.\n\
    \    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L,\
    \ 1L]\n    \n*/\nlong[] rolling_min(long[] numbers) \n{\n    long[] result = new\
    \ long[numbers.length];\n    long min = numbers[0];\n    foreach(i, number; numbers)\
    \ \n    {\n        min = min(min, number);\n        result[i] = min;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    foreach(i, number;\
    \ numbers) \n    {\n        sum += number;\n        result[i] = sum;\n    }\n\
    \    return result;\n}\n/*\n From a given array of integers, generate an array\
    \ of rolling product of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L,\
    \ 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[] numbers) \n{\n   \
    \ long[] result = new long[numbers.length];\n    long product = numbers", "{\n\
    \    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.length; i++) \n    {\n        result[i] =\
    \ max(result[i - 1], numbers[i]);\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max_so_far = numbers[0];\n\
    \    result[0] = max_so_far;\n    foreach (i, number; numbers[1 .. $]) \n    {\n\
    \        max_so_far = max(max_so_far, number);\n        result[i + 1] = max_so_far;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++) \n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i,\
    \ number; numbers[1 .. $]) \n    {\n        max_so_far = max(max_so_far, number);\n\
    \        result[i + 1] = max_so_far;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    foreach(i,\
    \ number; numbers)\n    {\n        max = max(max, number);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i,\
    \ number; numbers[1 .. $]) \n    {\n        max_so_far = max(max_so_far, number);\n\
    \        result[i + 1] = max_so_far;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if\
    \ (n > max) \n        {\n            max = n;\n        }\n        result[i + 1]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, number; numbers[1\
    \ .. $]) \n    {\n        max = max(max, number);\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        if (n > max) \n        {\n            max = n;\n   \
    \     }\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n   \
    \ long[] result = new long[numbers.length];\n    long max = numbers[0];\n    result[0]\
    \ = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max,\
    \ number);\n        result[i + 1] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n     \
    \   max = max(max, number);\n        result[i + 1] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, number; numbers) \n    {\n        max = max(max, number);\n  \
    \      result[i] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1 .. $]) \n    {\n        max = max(max, number);\n\
    \        result[i + 1] = max;\n    }\n    return result;\n}", "{\n    auto result\
    \ = new long[](numbers.length);\n    result[0] = numbers[0];\n    foreach (i,\
    \ number; numbers[1 .. $]) \n    {\n        result[i + 1] = max(result[i], number);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        if\
    \ (n > max) \n        {\n            max = n;\n        }\n        result[i + 1]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n       \
    \ max = max(max, number);\n        result[i] = max;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, n; numbers[1 .. $]) \n    {\n        max\
    \ = max(max, n);\n        result[i + 1] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n    \
    \    if (number > max) \n        {\n            max = number;\n        }\n   \
    \     result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    long max = numbers[0];\n    result[0] = max;\n\
    \    foreach (i, number; numbers[1 .. $]) \n    {\n        if (number > max) \n\
    \        {\n            max = number;\n        }\n        result[i + 1] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max_so_far = numbers[0];\n    result[0] = max_so_far;\n    foreach (i,\
    \ number; numbers[1 .. $]) \n    {\n        max_so_far = max(max_so_far, number);\n\
    \        result[i + 1] = max_so_far;\n    }\n    return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling minimum element found\
    \ until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min_so_far\
    \ = numbers[0];\n    result[0] = min_so_far;\n    foreach (i, number; numbers[1\
    \ .. $]) \n    {\n        min_so_far = min(min_so_far, number);\n        result[i\
    \ + 1] = min_so_far;\n    }\n    return result;\n}\n/*\n    Given an array of\
    \ integers, generate an array of rolling sum of elements found until given moment\n\
    \    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n   \
    \ [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[] numbers) \n{\n\
    \    long[] result = new long[numbers.length];\n    long sum_so_far = numbers[0];\n\
    \    result[0] = sum_so_far;\n    foreach (i, number; numbers[1 .. $]) \n    {\n\
    \        sum_so_far += number;\n        result[i + 1] = sum_so_far;\n    }\n \
    \   return result;\n}\n/*\n    Given an array of integers, generate an array of\
    \ rolling product of elements found until", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n  \
    \  {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n \
    \   return result;\n}", "{\n    long[] result = new long[numbers.length];\n  \
    \  result[0] = numbers[0];\n    foreach (i, n; numbers[1 .. $]) \n    {\n    \
    \    result[i + 1] = max(result[i], n);\n    }\n    return result;\n}", "{\n \
    \   long[] result = new long[numbers.length];\n    long max = numbers[0];\n  \
    \  for (int i = 0; i < numbers.length; i++) \n    {\n        if (numbers[i] >\
    \ max) \n        {\n            max = numbers[i];\n        }\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    for (int i = 1; i < numbers.length;\
    \ i++)\n    {\n        max = max(max, numbers[i]);\n        result[i] = max;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    result[0] = max;\n    foreach (i, n; numbers[1\
    \ .. $]) \n    {\n        max = max(max, n);\n        result[i + 1] = max;\n \
    \   }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    foreach(i, n; numbers)\n    {\n        max =\
    \ max(max, n);\n        result[i] = max;\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[numbers.length];\n    long max = numbers[0];\n \
    \   result[0] = max;\n    foreach (i, number; numbers[1 .. $]) \n    {\n     \
    \   if (number > max) \n        {\n            max = number;\n        }\n    \
    \    result[i + 1] = max;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[numbers.length];\n    result[0] = numbers[0];\n    foreach (i, number;\
    \ numbers[1 .. $]) \n    {\n        result[i + 1] = max(result[i], number);\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n \
    \   {\n        max = max(max, numbers[i]);\n        result[i] = max;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[numbers.length];\n \
    \   long max = numbers[0];\n    foreach(i, number; numbers) \n    {\n        max\
    \ = max(max, number);\n        result[i] = max;\n    }\n    return result;\n}\n\
    /*\n    From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long min =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        min = min(min,\
    \ number);\n        result[i] = min;\n    }\n    return result;\n}\n/*\n    From\
    \ a given array of integers, generate an array of rolling sum of elements found\
    \ until given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long sum =\
    \ numbers[0];\n    foreach(i, number; numbers) \n    {\n        sum += number;\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n    From a given\
    \ array of integers, generate an array of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    long product\
    \ = numbers[0];", "{\n    long[] result = new long[numbers.length];\n    long\
    \ max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) \n    {\n  \
    \      max = max(max, numbers[i]);\n        result[i] = max;\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    for (int i = 0; i < numbers.length; i++)\n    {\n       \
    \ if (numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        if (numbers[i] <\
    \ min)\n        {\n            min = numbers[i];\n        }\n        result[i]\
    \ = min;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling sum of elements found until given moment\n    in the sequence.\n\
    \    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L,\
    \ 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers) \n{\n    long[] result\
    \ = new long[numbers.length];\n    long sum = numbers[0];\n    for (int i = 0;\
    \ i < numbers.length; i++)\n    {\n        sum += numbers[i];\n        result[i]\
    \ = sum;\n    }\n    return result;\n}\n/*\n From a given array of integers, generate\
    \ an array of rolling average of elements found until given moment\n    in the\
    \ sequence.\n    >>> rolling_avg([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 2L,",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        max = max(max, numbers[i]);\n\
    \        result[i] = max;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling minimum element found until given\
    \ moment\n    in the sequence.\n    >>> rolling_min([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n    \n*/\nlong[] rolling_min(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long min = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        min = min(min, numbers[i]);\n\
    \        result[i] = min;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling sum of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n\
    \    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n    \n*/\nlong[] rolling_sum(long[] numbers)\
    \ \n{\n    long[] result = new long[numbers.length];\n    long sum = numbers[0];\n\
    \    for (int i = 0; i < numbers.length; i++)\n    {\n        sum += numbers[i];\n\
    \        result[i] = sum;\n    }\n    return result;\n}\n/*\n From a given array\
    \ of integers, generate an array of rolling product of elements found until given\
    \ moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L, 3L, 4L,\
    \ 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n    \n*/\nlong[] rolling_product(long[]\
    \ numbers) \n", "{\n    long[] result = new long[numbers.length];\n    long max\
    \ = numbers[0];\n    foreach(i, e; numbers) \n    {\n        if (e > max)\n  \
    \          max = e;\n        result[i] = max;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n\
    \    foreach(i, n; numbers) \n    {\n        max = max(max, n);\n        result[i]\
    \ = max;\n    }\n    return result;\n}", "{\n    long[] result = new long[numbers.length];\n\
    \    result[0] = numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n\
    \        result[i + 1] = max(result[i], number);\n    }\n    return result;\n\
    }\n/*\n From a given array of integers, generate an array of rolling minimum element\
    \ found until given moment\n    in the sequence.\n    >>> rolling_min([1L, 2L,\
    \ 3L, 2L, 3L, 4L, 2L])\n    [1L, 1L, 1L, 1L, 1L, 1L, 1L]\n*/\nlong[] rolling_min(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] =\
    \ numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i\
    \ + 1] = min(result[i], number);\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling sum of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_sum([1L, 2L, 3L, 2L, 3L,\
    \ 4L, 2L])\n    [1L, 3L, 6L, 8L, 11L, 15L, 17L]\n*/\nlong[] rolling_sum(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] =\
    \ numbers[0];\n    foreach (i, number; numbers[1..$]) \n    {\n        result[i\
    \ + 1] = result[i] + number;\n    }\n    return result;\n}\n/*\n From a given\
    \ array of integers, generate an array of rolling product of elements found until\
    \ given moment\n    in the sequence.\n    >>> rolling_product([1L, 2L, 3L, 2L,\
    \ 3L, 4L, 2L])\n    [1L, 2L, 6L, 12L, 36L, 144L, 288L]\n*/\nlong[] rolling_product(long[]\
    \ numbers) \n{\n    long[] result = new long[numbers"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
