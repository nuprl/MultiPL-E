name: HumanEval_119_match_parens
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6pjujps_.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp6pjujps_.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmp6pjujps_.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x37c05554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0y0eoafr.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmp0y0eoafr.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmp0y0eoafr.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x65f0d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n\
    \    {\n        if(c == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n           \
    \ open++;\n        else\n            close++;\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2n6oxoje.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp2n6oxoje.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp2n6oxoje.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x69ee1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzhxymkll.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpzhxymkll.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpzhxymkll.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x9d4fb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(c; lst[0])\n  \
    \  {\n        if(c == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(c; lst[1])\n    {\n        if(c == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpn2qt8otx.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpn2qt8otx.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpn2qt8otx.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xb7818554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open != s2_close)\n        return\
    \ \"No\";\n    else if(s1_open != s1_close && s2_open == s2_close)\n        return\
    \ \"No\";\n    else\n    {\n        if(s1_open > s1_close)\n        {\n      \
    \      if(s2_open > s2_close)\n            {\n                if(s1_open - s1_close\
    \ == s2_open - s2_close)\n                    return \"Yes\";\n              \
    \  else\n                    return \"No\";\n            }\n            else\n\
    \            {\n                if(s1_open - s1_close == s2_close - s2_open)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n        else\n        {\n      \
    \      if(s2_open > s2_close)\n            {\n                if(s1_close - s1_open\
    \ == s2_open - s2_close)\n                    return \"Yes\";\n              \
    \  else\n                    return \"No\";\n            }\n            else\n\
    \            {\n                if(s1_close - s1_open == s2_close - s2_open)\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpahbpzfvw.d(92): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42917d]\\n??:? void tmpahbpzfvw.__unittest_L87_C1()\
    \ [0x427e46]\\n??:? void tmpahbpzfvw.__modtest() [0x4283e4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dacb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ed6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a979]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa08]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a905]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ead]\\n??:? runModuleUnitTests [0x42d8a1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429640]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295c7]\\n??:? _d_run_main [0x429532]\\n??:? main [0x4283f7]\\\
    n??:? __libc_start_main [0xc0bb7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 == 0\
    \ && c2 != 0)\n        return \"No\";\n    else if(c1 != 0 && c2 == 0)\n     \
    \   return \"No\";\n    else\n    {\n        if(c1 > 0)\n        {\n         \
    \   if(c2 > 0)\n            {\n                if(c1 > c2)\n                 \
    \   return \"Yes\";\n                else\n                    return \"No\";\n\
    \            }\n            else\n            {\n                if(c1 > abs(c2))\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n        else\n        {\n      \
    \      if(c2 > 0)\n            {\n                if(abs(c1) > c2)\n         \
    \           return \"Yes\";\n                else\n                    return\
    \ \"No\";\n            }\n            else\n            {\n                if(abs(c1)\
    \ > abs(c2))\n                    return \"Yes\";\n                else\n    \
    \                return \"No\";\n            }\n        }\n    }\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpazfd_4l3.d(89): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4291c5]\\n??:? void tmpazfd_4l3.__unittest_L85_C1()\
    \ [0x427df0]\\n??:? void tmpazfd_4l3.__modtest() [0x428430]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db13]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428f1e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9c1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa50]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a94d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ef5]\\n??:? runModuleUnitTests [0x42d8e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429688]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42960f]\\n??:? _d_run_main [0x42957a]\\n??:? main [0x428443]\\\
    n??:? __libc_start_main [0x2a125554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpi6lmpq9l.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpi6lmpq9l.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpi6lmpq9l.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x2efab554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcq8wpfi4.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpcq8wpfi4.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpcq8wpfi4.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x17d4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int count1 = 0;\n    int count2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            count1++;\n        else\n    \
    \        count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n \
    \           count2++;\n        else\n            count2--;\n    }\n    if(count1\
    \ == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 <\
    \ 0)\n        return \"No\";\n    if(count1 < 0 && count2 > 0)\n    {\n      \
    \  if(count1 + count2 == 0)\n            return \"Yes\";\n        else\n     \
    \       return \"No\";\n    }\n    if(count1 > 0 && count2 < 0)\n    {\n     \
    \   if(count1 + count2 == 0)\n            return \"Yes\";\n        else\n    \
    \        return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxea6q245.d(25): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpxea6q245.d(26): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxea6q245.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Your code here\n    string s = \"\";\n    foreach(i; lst)\n\
    \        s ~= i;\n    int count = 0;\n    foreach(i; s)\n    {\n        if(i ==\
    \ '(')\n            count++;\n        else if(i == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsu9h4ibk.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpsu9h4ibk.__unittest_L42_C1()\
    \ [0x427e0e]\\n??:? void tmpsu9h4ibk.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0x4b69f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyvzwzkzr.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpyvzwzkzr.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpyvzwzkzr.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x217a8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else\n        \
    \    cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkn4agfb5.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpkn4agfb5.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpkn4agfb5.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xd36f8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmajvdhco.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpmajvdhco.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpmajvdhco.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x7c77554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0zjedd24.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp0zjedd24.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmp0zjedd24.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x27004554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    int count1\
    \ = 0;\n    int count2 = 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n\
    \            count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ str2)\n    {\n        if(c == '(')\n            count2++;\n        else\n  \
    \          count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1p45wg6c.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp1p45wg6c.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp1p45wg6c.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x9d3f7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpawhvwy_e.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpawhvwy_e.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpawhvwy_e.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x8429e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphuhj7oam.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmphuhj7oam.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmphuhj7oam.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xeac42554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuqzxvfjc.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpuqzxvfjc.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpuqzxvfjc.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xebb1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmllknurb.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpmllknurb.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpmllknurb.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xfa84b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open < s2_close)\n        return\
    \ \"No\";\n    else if(s1_open < s1_close && s2_open == s2_close)\n        return\
    \ \"No\";\n    else if(s1_open < s1_close && s2_open < s2_close)\n        return\
    \ \"No\";\n    else\n        return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9crnrq9y.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290c5]\\n??:? void tmp9crnrq9y.__unittest_L54_C1()\
    \ [0x427e10]\\n??:? void tmp9crnrq9y.__modtest() [0x428330]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da13]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e1e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8c1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a950]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a84d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428df5]\\n??:? runModuleUnitTests [0x42d7e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429588]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42950f]\\n??:? _d_run_main [0x42947a]\\n??:? main [0x428343]\\\
    n??:? __libc_start_main [0x9b942554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1\
    \ ~ s2;\n    int n = s.length;\n    int cnt = 0;\n    foreach(i; 0..n)\n    {\n\
    \        if(s[i] == '(')\n            cnt++;\n        else\n            cnt--;\n\
    \        if(cnt < 0)\n            return \"No\";\n    }\n    if(cnt == 0)\n  \
    \      return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp02_svqyo.d(26): Error: cannot implicitly convert expression `s.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp02_svqyo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Write your code here\n    int count = 0;\n    foreach(i; lst)\n\
    \    {\n        foreach(j; i)\n        {\n            if(j == '(')\n         \
    \       count++;\n            else\n                count--;\n            if(count\
    \ < 0)\n                return \"No\";\n        }\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbuldppow.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpbuldppow.__unittest_L42_C1()\
    \ [0x427dde]\\n??:? void tmpbuldppow.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x3f49f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfeevnkqr.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpfeevnkqr.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpfeevnkqr.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x7549f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkduyvl2u.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpkduyvl2u.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpkduyvl2u.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xb870b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcyejsrgl.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpcyejsrgl.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpcyejsrgl.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x63c13554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n  \
    \  int[] b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n\
    \    int[] e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n\
    \    int[] h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n\
    \    int[] k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n\
    \    int[] o = new int[n];\n    int[] p = new int[n];\n    int[] q = new int[n];\n\
    \    int[] r = new int[n];\n    int[] s = new int[n];\n    int[] t = new int[n];\n\
    \    int[] u = new int[n];\n    int[] v = new int[n];\n    int[] w = new int[n];\n\
    \    int[] x = new int[n];\n    int[] y = new int[n];\n    int[] z = new int[n];\n\
    \    int[] A = new int[n];\n    int[] B = new int[n];\n    int[] C = new int[n];\n\
    \    int[] D = new int[n];\n    int[] E = new int[n];\n    int[] F = new int[n];\n\
    \    int[] G = new int[n];\n    int[] H = new int[n];\n    int[] I = new int[n];\n\
    \    int[] J = new int[n];\n    int[] K = new int[n];\n    int[] L = new int[n];\n\
    \    int[] M = new int[n];\n    int[] N = new int[n];\n    int[] O = new int[n];\n\
    \    int[] P = new int[n];\n    int[]\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_9_7zl6y.d(70): Error: no identifier for declarator `int[]`\\\
    n/tmp/tmp_9_7zl6y.d(70): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9_7zl6y.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto c1 = s1.count('(');\n\
    \    auto c2 = s2.count('(');\n    auto d1 = s1.count(')');\n    auto d2 = s2.count(')');\n\
    \    if (c1 == d1 && c2 == d2)\n        return \"Yes\";\n    if (c1 == d1 && c2\
    \ != d2)\n        return \"No\";\n    if (c1 != d1 && c2 == d2)\n        return\
    \ \"No\";\n    if (c1 > d1)\n        return \"Yes\";\n    if (c2 > d2)\n     \
    \   return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate =\
    \ match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1g8oo7k9.d(25): Error: no property `count` for type `string`\\\
    n/tmp/tmp1g8oo7k9.d(26): Error: no property `count` for type `string`\\n/tmp/tmp1g8oo7k9.d(27):\
    \ Error: no property `count` for type `string`\\n/tmp/tmp1g8oo7k9.d(28): Error:\
    \ no property `count` for type `string`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1g8oo7k9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1\
    \ ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n\
    \            count++;\n        else if(c == ')')\n            count--;\n     \
    \   if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n   \
    \     return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx_7skojf.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpx_7skojf.__unittest_L41_C1()\
    \ [0x427e0a]\\n??:? void tmpx_7skojf.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x9a0d8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp07uu30gu.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp07uu30gu.__unittest_L45_C1()\
    \ [0x427c94]\\n??:? void tmp07uu30gu.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x466a6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphdxs606_.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmphdxs606_.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmphdxs606_.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xab649554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n\
    \    auto n = s.length;\n    auto cnt = 0;\n    foreach(i; 0 .. n)\n    {\n  \
    \      if(s[i] == '(')\n            cnt++;\n        else\n            cnt--;\n\
    \        if(cnt < 0)\n            return \"No\";\n    }\n    if(cnt == 0)\n  \
    \      return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp434i3s4e.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp434i3s4e.__unittest_L42_C1()\
    \ [0x427e1a]\\n??:? void tmp434i3s4e.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0x5543554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2en5fvhb.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp2en5fvhb.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp2en5fvhb.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xf374a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0dpqxjxx.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp0dpqxjxx.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp0dpqxjxx.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x8620f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    return open == close ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl5fwoa_9.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpl5fwoa_9.__unittest_L41_C1()\
    \ [0x4280f6]\\n??:? void tmpl5fwoa_9.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0xd06d7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(char c; lst[0])\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n    }\n \
    \   foreach(char c; lst[1])\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n    }\n    return count == 0 ? \"Yes\" :\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpox3kc812.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpox3kc812.__unittest_L40_C1()\
    \ [0x4280f2]\\n??:? void tmpox3kc812.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xab001554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int n = s.length;\n    int cnt\
    \ = 0;\n    foreach(i; 0 .. n)\n    {\n        if(s[i] == '(')\n            cnt++;\n\
    \        else\n            cnt--;\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwvtbhy3o.d(24): Error: cannot implicitly convert expression `s.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpwvtbhy3o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    int count1\
    \ = 0;\n    int count2 = 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n\
    \            count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ str2)\n    {\n        if(c == '(')\n            count2++;\n        else\n  \
    \          count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_tbz2jtr.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp_tbz2jtr.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp_tbz2jtr.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xf3ae8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8x2x4x4l.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp8x2x4x4l.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmp8x2x4x4l.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xa42cd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe5sdixs6.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpe5sdixs6.__unittest_L37_C1()\
    \ [0x4280a6]\\n??:? void tmpe5sdixs6.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x7e30d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcnzar10u.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpcnzar10u.__unittest_L36_C1()\
    \ [0x4280a6]\\n??:? void tmpcnzar10u.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0xf09db554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpeq7slc4o.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpeq7slc4o.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpeq7slc4o.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x5d6db554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb0i356oz.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpb0i356oz.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpb0i356oz.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x94db8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzcma1iu2.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpzcma1iu2.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpzcma1iu2.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xbc0d2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmvf6c5wv.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpmvf6c5wv.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpmvf6c5wv.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x36e6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd5uo3y99.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpd5uo3y99.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpd5uo3y99.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x533b6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    string s = lst[0] ~ lst[1];\n    int count\
    \ = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpot4u1jn7.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpot4u1jn7.__unittest_L37_C1()\
    \ [0x427df6]\\n??:? void tmpot4u1jn7.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xea721554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe8ly5ofc.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpe8ly5ofc.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpe8ly5ofc.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x830ed554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n    }\n    foreach(c; s2)\n    {\n      \
    \  if(c == '(')\n            count++;\n        else\n            count--;\n  \
    \  }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpidyv27_4.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpidyv27_4.__unittest_L45_C1()\
    \ [0x428102]\\n??:? void tmpidyv27_4.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0x629c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n    }\n    foreach(c; s2)\n    {\n      \
    \  if(c == '(')\n            count++;\n        else\n            count--;\n  \
    \  }\n    if(count == 0)\n        return \"Yes\";\n    else\n        return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa29sy143.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpa29sy143.__unittest_L45_C1()\
    \ [0x428102]\\n??:? void tmpa29sy143.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0xdeddb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n\
    \            s1_open++;\n        else\n            s1_open--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            s2_open++;\n        else\n   \
    \         s2_open--;\n    }\n    if(s1_open == 0 && s2_open == 0)\n        return\
    \ \"Yes\";\n    else if(s1_open == 0 && s2_open < 0)\n        return \"Yes\";\n\
    \    else if(s1_open > 0 && s2_open == 0)\n        return \"Yes\";\n    else if(s1_open\
    \ > 0 && s2_open < 0)\n        return \"Yes\";\n    else\n        return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8l78_1u1.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290ad]\\n??:? void tmp8l78_1u1.__unittest_L52_C1()\
    \ [0x427df8]\\n??:? void tmp8l78_1u1.__modtest() [0x428318]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9fb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a938]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a835]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ddd]\\n??:? runModuleUnitTests [0x42d7d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429570]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294f7]\\n??:? _d_run_main [0x429462]\\n??:? main [0x42832b]\\\
    n??:? __libc_start_main [0xd2aff554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt14bjpqp.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpt14bjpqp.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpt14bjpqp.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xfefc0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplnyehf22.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmplnyehf22.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmplnyehf22.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x1d2f7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int a = 0;\n    int b = 0;\n    foreach(i; lst[0])\n    {\n  \
    \      if(i == '(')\n            a++;\n        else\n            a--;\n    }\n\
    \    foreach(i; lst[1])\n    {\n        if(i == '(')\n            b++;\n     \
    \   else\n            b--;\n    }\n    if(a == 0 && b == 0)\n        return \"\
    Yes\";\n    else if(a == 0 && b < 0)\n        return \"No\";\n    else if(a >\
    \ 0 && b == 0)\n        return \"No\";\n    else if(a > 0 && b < 0)\n    {\n \
    \       if(abs(b) > a)\n            return \"No\";\n        else\n           \
    \ return \"Yes\";\n    }\n    else if(a < 0 && b == 0)\n    {\n        if(abs(a)\
    \ > b)\n            return \"No\";\n        else\n            return \"Yes\";\n\
    \    }\n    else\n    {\n        if(abs(a) == abs(b))\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0quny_75.d(72): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42919d]\\n??:? void tmp0quny_75.__unittest_L67_C1()\
    \ [0x427e52]\\n??:? void tmp0quny_75.__modtest() [0x428404]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42daeb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ef6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a999]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa28]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a925]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ecd]\\n??:? runModuleUnitTests [0x42d8c1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429660]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295e7]\\n??:? _d_run_main [0x429552]\\n??:? main [0x428417]\\\
    n??:? __libc_start_main [0x71f4e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0lgkq_3m.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp0lgkq_3m.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp0lgkq_3m.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x6a5fe554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Your code here\n    int count = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            count++;\n            else if(c == ')')\n                count--;\n\
    \            if(count < 0)\n                return \"No\";\n        }\n    }\n\
    \    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjfb_68pa.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpjfb_68pa.__unittest_L39_C1()\
    \ [0x427dde]\\n??:? void tmpjfb_68pa.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xcb165554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkgj8jjvl.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpkgj8jjvl.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpkgj8jjvl.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xfc119554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else if(c == ')')\n            count1--;\n    }\n\
    \    foreach(c; s2)\n    {\n        if(c == '(')\n            count2++;\n    \
    \    else if(c == ')')\n            count2--;\n    }\n    if(count1 == 0 && count2\
    \ == 0)\n        return \"Yes\";\n    else if(count1 == 0 && count2 < 0)\n   \
    \     return \"Yes\";\n    else if(count1 > 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1wqirwgn.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42909d]\\n??:? void tmp1wqirwgn.__unittest_L50_C1()\
    \ [0x427cdc]\\n??:? void tmp1wqirwgn.__modtest() [0x428308]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9eb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428df6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a899]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a928]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a825]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dcd]\\n??:? runModuleUnitTests [0x42d7c1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429560]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294e7]\\n??:? _d_run_main [0x429452]\\n??:? main [0x42831b]\\\
    n??:? __libc_start_main [0xd3528554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpewehpfy8.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpewehpfy8.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpewehpfy8.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x489a8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9d5_sqn5.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmp9d5_sqn5.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmp9d5_sqn5.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x74049554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptvbg07z8.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmptvbg07z8.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmptvbg07z8.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x63048554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 == 0\
    \ && c2 < 0)\n        return \"No\";\n    else if(c1 > 0 && c2 == 0)\n       \
    \ return \"No\";\n    else if(c1 > 0 && c2 < 0)\n    {\n        if(c1 == abs(c2))\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz8_9mado.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429135]\\n??:? void tmpz8_9mado.__unittest_L57_C1()\
    \ [0x427ee6]\\n??:? void tmpz8_9mado.__modtest() [0x42839c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e8e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a931]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e65]\\n??:? runModuleUnitTests [0x42d859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42957f]\\n??:? _d_run_main [0x4294ea]\\n??:? main [0x4283af]\\\
    n??:? __libc_start_main [0x73a31554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8h178478.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp8h178478.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp8h178478.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x814c0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0gkiq0ew.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp0gkiq0ew.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmp0gkiq0ew.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xb13aa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr2ylhor1.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpr2ylhor1.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpr2ylhor1.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xfc30c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Write your code here\n    int count = 0;\n    foreach(i; lst)\n\
    \    {\n        foreach(j; i)\n        {\n            if(j == '(')\n         \
    \       count++;\n            else\n                count--;\n            if(count\
    \ < 0)\n                return \"No\";\n        }\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvqzt37pu.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpvqzt37pu.__unittest_L42_C1()\
    \ [0x427dde]\\n??:? void tmpvqzt37pu.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x91730554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjn1ljer4.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpjn1ljer4.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpjn1ljer4.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x28248554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    int l = 0;\n    int count = 0;\n    int count2\
    \ = 0;\n    int count3 = 0;\n    int count4 = 0;\n    int count5 = 0;\n    int\
    \ count6 = 0;\n    int count7 = 0;\n    int count8 = 0;\n    int count9 = 0;\n\
    \    int count10 = 0;\n    int count11 = 0;\n    int count12 = 0;\n    int count13\
    \ = 0;\n    int count14 = 0;\n    int count15 = 0;\n    int count16 = 0;\n   \
    \ int count17 = 0;\n    int count18 = 0;\n    int count19 = 0;\n    int count20\
    \ = 0;\n    int count21 = 0;\n    int count22 = 0;\n    int count23 = 0;\n   \
    \ int count24 = 0;\n    int count25 = 0;\n    int count26 = 0;\n    int count27\
    \ = 0;\n    int count28 = 0;\n    int count29 = 0;\n    int count30 = 0;\n   \
    \ int count31 = 0;\n    int count32 = 0;\n    int count33 = 0;\n    int count34\
    \ = 0;\n    int count35 = 0;\n    int count36 = 0;\n    int count37 = 0;\n   \
    \ int count38 = 0;\n    int count39 = 0;\n    int count40 = 0;\n    int count41\
    \ = 0;\n    int count42 = 0;\n    int count43 = 0;\n    int count44 = 0;\n   \
    \ int count45 = 0;\n    int count46 = 0;\n    int count47 = 0;\n    int count48\
    \ = 0;\n    int count49 = 0;\n    int count50 = 0;\n    int count51 = 0;\n   \
    \ int count52 = 0;\n    int count53 = 0;\n    int count54 = 0;\n    int count55\
    \ = 0;\n    int count56 = 0;\n    int count57 = 0;\n    int count58\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ga4r7zo.d(87): Error: semicolon expected, not `unittest`\\n/tmp/tmp4ga4r7zo.d(87):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4ga4r7zo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcmemv99v.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpcmemv99v.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpcmemv99v.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x7b073554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz1kigzf9.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpz1kigzf9.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpz1kigzf9.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xe2fd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaz0d4j4o.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpaz0d4j4o.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpaz0d4j4o.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x37622554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnv0iu51s.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpnv0iu51s.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpnv0iu51s.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x2274d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    int count = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            count++;\n            else if(c == ')')\n                count--;\n\
    \            if(count < 0)\n                return \"No\";\n        }\n    }\n\
    \    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqqr1898q.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpqqr1898q.__unittest_L39_C1()\
    \ [0x427dde]\\n??:? void tmpqqr1898q.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x794d8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppdkp7ab5.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmppdkp7ab5.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmppdkp7ab5.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x90866554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpar0iup4n.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpar0iup4n.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpar0iup4n.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x54b45554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7vfxvirt.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp7vfxvirt.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp7vfxvirt.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xae712554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3k569jg6.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp3k569jg6.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmp3k569jg6.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xbd981554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp84rad7p1.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp84rad7p1.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp84rad7p1.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xe4aa0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1forzje0.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp1forzje0.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmp1forzje0.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xd132f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnigeu80z.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpnigeu80z.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpnigeu80z.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x7fe94554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz6lklv0g.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpz6lklv0g.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpz6lklv0g.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xdab3c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmmznqy85.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpmmznqy85.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpmmznqy85.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x70721554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int cnt = 0;\n    foreach(i;\
    \ 0..n)\n    {\n        if(i < n1)\n        {\n            if(s1[i] == '(')\n\
    \                cnt++;\n            else\n                cnt--;\n        }\n\
    \        else\n        {\n            if(s2[i - n1] == '(')\n                cnt++;\n\
    \            else\n                cnt--;\n        }\n        if(cnt < 0)\n  \
    \          return \"No\";\n    }\n    return \"Yes\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpakhdrih5.d(25): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpakhdrih5.d(26): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpakhdrih5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0lenwkdz.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp0lenwkdz.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmp0lenwkdz.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xf5b78554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpasg6yr78.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpasg6yr78.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpasg6yr78.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xe8d02554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuyy2kp3z.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpuyy2kp3z.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpuyy2kp3z.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x7f45b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpovnf5jnh.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpovnf5jnh.__unittest_L39_C1()\
    \ [0x4280ae]\\n??:? void tmpovnf5jnh.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0x54c1a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyoggokia.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpyoggokia.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpyoggokia.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x304a2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpthyv8t92.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpthyv8t92.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpthyv8t92.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x4c550554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1\
    \ ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n\
    \            count++;\n        else if(c == ')')\n            count--;\n     \
    \   if(count < 0)\n            return \"No\";\n    }\n    if(count == 0)\n   \
    \     return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdpnk1prk.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpdpnk1prk.__unittest_L41_C1()\
    \ [0x427e0a]\\n??:? void tmpdpnk1prk.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xd8e54554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxwl3wo39.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpxwl3wo39.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpxwl3wo39.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x9ac4c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp77118_31.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp77118_31.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp77118_31.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xe7b3f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Your code here\n    int count = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            count++;\n            else if(c == ')')\n                count--;\n\
    \            if(count < 0)\n                return \"No\";\n        }\n    }\n\
    \    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpy171jl9f.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpy171jl9f.__unittest_L39_C1()\
    \ [0x427dde]\\n??:? void tmpy171jl9f.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xf4896554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqt0dwk10.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpqt0dwk10.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpqt0dwk10.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xfddef554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd2gsjlqq.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpd2gsjlqq.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpd2gsjlqq.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x49eca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcrtj6lyw.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpcrtj6lyw.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpcrtj6lyw.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xfc25c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmlx_8_l6.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpmlx_8_l6.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpmlx_8_l6.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xc8b14554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int cnt1 = 0;\n\
    \    int cnt2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n        \
    \    cnt1++;\n        else\n            cnt1--;\n    }\n    foreach(c; s2)\n \
    \   {\n        if(c == '(')\n            cnt2++;\n        else\n            cnt2--;\n\
    \    }\n    if(cnt1 == 0 && cnt2 == 0)\n        return \"Yes\";\n    else\n  \
    \      return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp01ypxwet.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp01ypxwet.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp01ypxwet.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x1d5ba554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsfo1tzfh.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpsfo1tzfh.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpsfo1tzfh.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd0345554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8ucevwid.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp8ucevwid.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmp8ucevwid.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xf84dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int count = 0;\n    foreach(string\
    \ s; lst)\n    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n\
    \                count++;\n            else\n                count--;\n      \
    \      if(count < 0)\n            {\n                result = \"No\";\n      \
    \          break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpm2pgmgpd.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpm2pgmgpd.__unittest_L42_C1()\
    \ [0x427dde]\\n??:? void tmpm2pgmgpd.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x29ecc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpu6huajus.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpu6huajus.__unittest_L37_C1()\
    \ [0x4280a6]\\n??:? void tmpu6huajus.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0xe14d5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpabfjdqh7.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpabfjdqh7.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpabfjdqh7.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xb52f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmoav2_za.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpmoav2_za.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpmoav2_za.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x2bd81554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    return isGood(s1\
    \ + s2) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcvr8ze3s.d(25): Error: undefined identifier `isGood`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcvr8ze3s.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpu4ot6on3.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpu4ot6on3.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpu4ot6on3.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x3dfef554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n\
    \    auto n = s.length;\n    auto stack = new Stack!int;\n    foreach(i, c; s)\n\
    \    {\n        if (c == '(')\n            stack.push(i);\n        else\n    \
    \    {\n            if (stack.empty)\n                return \"No\";\n       \
    \     else\n                stack.pop();\n        }\n    }\n    if (stack.empty)\n\
    \        return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n \
    \   alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3y4qeyvi.d(27): Error: template instance `Stack!int` template\
    \ `Stack` is not defined\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"\
    /tmp/tmp3y4qeyvi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj9itoepm.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpj9itoepm.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpj9itoepm.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xf47ce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyxyll6zb.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpyxyll6zb.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpyxyll6zb.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xace42554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxs2yex_e.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpxs2yex_e.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpxs2yex_e.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x555a0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 == 0\
    \ && c2 != 0)\n        return \"No\";\n    else if(c1 != 0 && c2 == 0)\n     \
    \   return \"No\";\n    else\n    {\n        if(c1 > 0)\n        {\n         \
    \   if(c2 > 0)\n            {\n                if(c1 > c2)\n                 \
    \   return \"Yes\";\n                else\n                    return \"No\";\n\
    \            }\n            else\n            {\n                if(c1 > abs(c2))\n\
    \                    return \"Yes\";\n                else\n                 \
    \   return \"No\";\n            }\n        }\n        else\n        {\n      \
    \      if(c2 > 0)\n            {\n                if(abs(c1) > c2)\n         \
    \           return \"Yes\";\n                else\n                    return\
    \ \"No\";\n            }\n            else\n            {\n                if(abs(c1)\
    \ > abs(c2))\n                    return \"Yes\";\n                else\n    \
    \                return \"No\";\n            }\n        }\n    }\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp86c1o_w8.d(89): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4291c5]\\n??:? void tmp86c1o_w8.__unittest_L85_C1()\
    \ [0x427df0]\\n??:? void tmp86c1o_w8.__modtest() [0x428430]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db13]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428f1e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9c1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa50]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a94d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ef5]\\n??:? runModuleUnitTests [0x42d8e9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429688]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42960f]\\n??:? _d_run_main [0x42957a]\\n??:? main [0x428443]\\\
    n??:? __libc_start_main [0xb3e28554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwwtlc8n3.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpwwtlc8n3.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpwwtlc8n3.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xb3a01554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp77wnas1m.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp77wnas1m.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp77wnas1m.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xbcc42554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo4h_qyvv.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpo4h_qyvv.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpo4h_qyvv.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xe7957554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptvdxpvv1.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmptvdxpvv1.__unittest_L49_C1()\
    \ [0x427ddc]\\n??:? void tmptvdxpvv1.__modtest() [0x4282fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x42830f]\\\
    n??:? __libc_start_main [0xcaf4d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2iyzgc8k.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp2iyzgc8k.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp2iyzgc8k.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x1899e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s = lst[0] ~ lst[1];\n    auto p = 0;\n    foreach(c; s)\n\
    \    {\n        if(c == '(')\n            p++;\n        else\n            p--;\n\
    \        if(p < 0)\n            return \"No\";\n    }\n    return p == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmi8ffu09.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpmi8ffu09.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpmi8ffu09.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x25bae554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprplsnu4p.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmprplsnu4p.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmprplsnu4p.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x1c30554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0urjqg7q.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp0urjqg7q.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmp0urjqg7q.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xe3299554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str1 = lst[0];\n    string str2 = lst[1];\n    int count1\
    \ = 0;\n    int count2 = 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n\
    \            count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ str2)\n    {\n        if(c == '(')\n            count2++;\n        else\n  \
    \          count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppmiho1kq.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmppmiho1kq.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmppmiho1kq.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x63b5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int balance = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            balance++;\n        else\n    \
    \        balance--;\n        if(balance < 0)\n            return \"No\";\n   \
    \ }\n    return balance == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0rgx0ws0.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp0rgx0ws0.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmp0rgx0ws0.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xc7cc8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 > 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9xvx975t.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmp9xvx975t.__unittest_L49_C1()\
    \ [0x427ddc]\\n??:? void tmp9xvx975t.__modtest() [0x4282fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x42830f]\\\
    n??:? __libc_start_main [0x9f3a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int\
    \ count = 0;\n    foreach(e; s)\n    {\n        if(e == '(')\n            count++;\n\
    \        else if(e == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyqbcgwyz.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpyqbcgwyz.__unittest_L40_C1()\
    \ [0x427e0e]\\n??:? void tmpyqbcgwyz.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0x99908554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0gygty_p.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp0gygty_p.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmp0gygty_p.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x19263554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpun4harhx.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429085]\\n??:? void tmpun4harhx.__unittest_L49_C1()\
    \ [0x427e4a]\\n??:? void tmpun4harhx.__modtest() [0x4282ec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dde]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a881]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428db5]\\n??:? runModuleUnitTests [0x42d7a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429548]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294cf]\\n??:? _d_run_main [0x42943a]\\n??:? main [0x4282ff]\\\
    n??:? __libc_start_main [0xa2b9d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjvhytroi.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpjvhytroi.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpjvhytroi.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x8dc50554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int cnt = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                cnt++;\n       \
    \     else\n                cnt--;\n            if(cnt < 0)\n                return\
    \ \"No\";\n        }\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprdwc6fuo.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmprdwc6fuo.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmprdwc6fuo.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x7bd0f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzmfal077.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpzmfal077.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpzmfal077.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x17d5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4an1awqx.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp4an1awqx.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmp4an1awqx.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x7a37f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int a = 0;\n    int b = 0;\n    foreach(i; lst[0])\n    {\n  \
    \      if(i == '(')\n            a++;\n        else\n            a--;\n    }\n\
    \    foreach(i; lst[1])\n    {\n        if(i == '(')\n            b++;\n     \
    \   else\n            b--;\n    }\n    if(a == 0 && b == 0)\n        return \"\
    Yes\";\n    else if(a == 0 && b < 0)\n        return \"No\";\n    else if(a <\
    \ 0 && b == 0)\n        return \"No\";\n    else if(a < 0 && b < 0)\n        return\
    \ \"No\";\n    else if(a > 0 && b > 0)\n        return \"Yes\";\n    else if(a\
    \ > 0 && b < 0)\n        return \"Yes\";\n    else if(a < 0 && b > 0)\n      \
    \  return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe50azr4n.d(62): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290fd]\\n??:? void tmpe50azr4n.__unittest_L56_C1()\
    \ [0x427e48]\\n??:? void tmpe50azr4n.__modtest() [0x428368]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da4b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a988]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a885]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e2d]\\n??:? runModuleUnitTests [0x42d821]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429547]\\n??:? _d_run_main [0x4294b2]\\n??:? main [0x42837b]\\\
    n??:? __libc_start_main [0x23f76554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    for (int i = 0;\
    \ i < n1; i++)\n    {\n        if (s1[i] == '(')\n            c1++;\n        else\n\
    \            c1--;\n    }\n    for (int i = 0; i < n2; i++)\n    {\n        if\
    \ (s2[i] == '(')\n            c2++;\n        else\n            c2--;\n    }\n\
    \    if (c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if (c1 > 0 &&\
    \ c2 < 0)\n    {\n        if (c1 == -c2)\n            return \"Yes\";\n      \
    \  else\n            return \"No\";\n    }\n    else if (c1 < 0 && c2 > 0)\n \
    \   {\n        if (c2 == -c1)\n            return \"Yes\";\n        else\n   \
    \         return \"No\";\n    }\n    else\n        return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjsq612oc.d(25): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpjsq612oc.d(26): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjsq612oc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    return (open == close) ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpagdibt1w.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpagdibt1w.__unittest_L41_C1()\
    \ [0x4280f6]\\n??:? void tmpagdibt1w.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0xb5e6e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    return (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphw7y04x_.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmphw7y04x_.__unittest_L37_C1()\
    \ [0x4280a6]\\n??:? void tmphw7y04x_.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x4c83e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n  \
    \          if(c == '(')\n                open++;\n            else\n         \
    \       close++;\n        }\n    }\n    if(open != close)\n        result = \"\
    No\";\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkpzfw4o2.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpkpzfw4o2.__unittest_L40_C1()\
    \ [0x4280be]\\n??:? void tmpkpzfw4o2.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0xe2cfc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoyky26gm.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpoyky26gm.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpoyky26gm.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xdfba0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    for (int i = 0; i < lst[0].length;\
    \ i++)\n    {\n        if (lst[0][i] == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    for (int i = 0; i < lst[1].length; i++)\n  \
    \  {\n        if (lst[1][i] == '(')\n            open++;\n        else\n     \
    \       close++;\n    }\n    if (open == close)\n        return \"Yes\";\n   \
    \ return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5ijey1s8.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmp5ijey1s8.__unittest_L43_C1()\
    \ [0x428146]\\n??:? void tmp5ijey1s8.__modtest() [0x428300]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x428313]\\\
    n??:? __libc_start_main [0xa6338554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_kikp4az.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp_kikp4az.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp_kikp4az.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x109e3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    if(count1 == 0 && count2 != 0)\n        return \"No\";\n    if(count1\
    \ != 0 && count2 == 0)\n        return \"No\";\n    if(count1 < 0 && count2 >\
    \ 0)\n        return \"No\";\n    if(count1 > 0 && count2 < 0)\n        return\
    \ \"No\";\n    if(count1 > 0 && count2 > 0)\n        return \"Yes\";\n    if(count1\
    \ < 0 && count2 < 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoar5lel1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429105]\\n??:? void tmpoar5lel1.__unittest_L57_C1()\
    \ [0x427d44]\\n??:? void tmpoar5lel1.__modtest() [0x428370]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da53]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e5e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a901]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a990]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a88d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e35]\\n??:? runModuleUnitTests [0x42d829]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42954f]\\n??:? _d_run_main [0x4294ba]\\n??:? main [0x428383]\\\
    n??:? __libc_start_main [0x65aa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5ailq_i0.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmp5ailq_i0.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmp5ailq_i0.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xd52e2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyw0vttt4.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpyw0vttt4.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpyw0vttt4.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x9f2a6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpq32acvld.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpq32acvld.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpq32acvld.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x59df5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl5__r7co.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpl5__r7co.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpl5__r7co.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xe40b9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxa0eze7g.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpxa0eze7g.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpxa0eze7g.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x2ebfb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 > 0\
    \ && c2 < 0)\n        return \"Yes\";\n    else if(c1 < 0 && c2 > 0)\n       \
    \ return \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplkmtipmx.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmplkmtipmx.__unittest_L50_C1()\
    \ [0x427ddc]\\n??:? void tmplkmtipmx.__modtest() [0x4282fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x42830f]\\\
    n??:? __libc_start_main [0x91659554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp84ecok7y.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp84ecok7y.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmp84ecok7y.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xbf8e3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2\
    \ != 0)\n        return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"\
    No\";\n    if(c1 < 0 && c2 > 0)\n        return \"No\";\n    if(c1 > 0 && c2 <\
    \ 0)\n        return \"No\";\n    if(abs(c1) > abs(c2))\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsbe64ho5.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429165]\\n??:? void tmpsbe64ho5.__unittest_L55_C1()\
    \ [0x427d8c]\\n??:? void tmpsbe64ho5.__modtest() [0x4283cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ebe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a961]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e95]\\n??:? runModuleUnitTests [0x42d889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429628]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295af]\\n??:? _d_run_main [0x42951a]\\n??:? main [0x4283df]\\\
    n??:? __libc_start_main [0x13ec7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx4btsfj4.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpx4btsfj4.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpx4btsfj4.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x8eac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp6r07mqr.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpp6r07mqr.__unittest_L45_C1()\
    \ [0x427c94]\\n??:? void tmpp6r07mqr.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xd3d66554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] a = new int[n];\n  \
    \  int[] b = new int[n];\n    int[] c = new int[n];\n    int[] d = new int[n];\n\
    \    int[] e = new int[n];\n    int[] f = new int[n];\n    int[] g = new int[n];\n\
    \    int[] h = new int[n];\n    int[] i = new int[n];\n    int[] j = new int[n];\n\
    \    int[] k = new int[n];\n    int[] l = new int[n];\n    int[] m = new int[n];\n\
    \    int[] nn = new int[n];\n    int[] o = new int[n];\n    int[] p = new int[n];\n\
    \    int[] q = new int[n];\n    int[] r = new int[n];\n    int[] s = new int[n];\n\
    \    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n\
    \    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n\
    \    int[] z = new int[n];\n    int[] aa = new int[n];\n    int[] bb = new int[n];\n\
    \    int[] cc = new int[n];\n    int[] dd = new int[n];\n    int[] ee = new int[n];\n\
    \    int[] ff = new int[n];\n    int[] gg = new int[n];\n    int[] hh = new int[n];\n\
    \    int[] ii = new int[n];\n    int[] jj = new int[n];\n    int[] kk = new int[n];\n\
    \    int[] ll = new int[n];\n    int[] mm = new int[n];\n    int[] nnn = new int[n];\n\
    \    int[] oo\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp__lsgh6g.d(69): Error: semicolon expected, not `unittest`\\n/tmp/tmp__lsgh6g.d(69):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp__lsgh6g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // your code here\n    string s = lst[0] ~ lst[1];\n    int count\
    \ = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n\
    \        else if(c == ')')\n            count--;\n        if(count < 0)\n    \
    \        return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpm564xwzu.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpm564xwzu.__unittest_L37_C1()\
    \ [0x427df6]\\n??:? void tmpm564xwzu.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xf5d6d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7f7yzv_7.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp7f7yzv_7.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmp7f7yzv_7.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xf30cd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqprkm74x.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpqprkm74x.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpqprkm74x.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x6c85b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s) {\n        if (c == '(') {\n            count++;\n        } else {\n    \
    \        count--;\n        }\n        if (count < 0) {\n            return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprat_seq8.d(44): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmprat_seq8.__unittest_L37_C1()\
    \ [0x427dee]\\n??:? void tmprat_seq8.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x66d74554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_kbs9bi_.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp_kbs9bi_.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp_kbs9bi_.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x3e98b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s = s1\
    \ ~ s2;\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n\
    \            count++;\n        else\n            count--;\n        if(count <\
    \ 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return \"\
    Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplnj89xjo.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmplnj89xjo.__unittest_L41_C1()\
    \ [0x427e02]\\n??:? void tmplnj89xjo.__modtest() [0x4282a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d98b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a839]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42d761]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429500]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429487]\\n??:? _d_run_main [0x4293f2]\\n??:? main [0x4282b7]\\\
    n??:? __libc_start_main [0xfca4c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Good strings have an equal number of open and close parentheses.\n\
    \    // If the number of open parentheses is greater than the number of close\n\
    \    // parentheses, then the string is not good.\n    // If the number of open\
    \ parentheses is less than the number of close\n    // parentheses, then the string\
    \ is not good.\n    // If the number of open parentheses is equal to the number\
    \ of close\n    // parentheses, then the string is good.\n    //\n    // The number\
    \ of open parentheses is the number of '(' characters in the\n    // string.\n\
    \    // The number of close parentheses is the number of ')' characters in the\n\
    \    // string.\n    //\n    // The number of open parentheses in the first string\
    \ is the number of '('\n    // characters in the first string.\n    // The number\
    \ of close parentheses in the first string is the number of ')'\n    // characters\
    \ in the first string.\n    //\n    // The number of open parentheses in the second\
    \ string is the number of '('\n    // characters in the second string.\n    //\
    \ The number of close parentheses in the second string is the number of ')'\n\
    \    // characters in the second string.\n    //\n    // The number of open parentheses\
    \ in the concatenated string is the sum of\n    // the number of open parentheses\
    \ in the first string and the number of open\n    // parentheses in the second\
    \ string.\n    // The number of close parentheses in the concatenated string is\
    \ the sum of\n    // the number of close parentheses in the first string and the\
    \ number of\n    // close parentheses in the second string.\n    //\n    // The\
    \ number of open parentheses in the concatenated string is greater than\n    //\
    \ the number of close parentheses in the concatenated string if the number\n \
    \   // of open parentheses in the first string is greater than the number of\n\
    \    // close parentheses in the first string, and the number of open parentheses\n\
    \    // in the second string is greater than the number of close parentheses in\n\
    \    // the second string.\n    // The number of open parentheses in the concatenated\
    \ string is less than the\n    // number of close parentheses in the concatenated\
    \ string if the number of\n    // open parentheses in the first string is less\
    \ than the number of close\n    // parentheses in the first string, and the number\
    \ of open parentheses in\n\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0c25wkdx.d(64): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0c25wkdx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n  \
    \          if(c == '(')\n                open++;\n            else\n         \
    \       close++;\n        }\n    }\n    if(open != close)\n        result = \"\
    No\";\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk5k3alj0.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpk5k3alj0.__unittest_L40_C1()\
    \ [0x4280be]\\n??:? void tmpk5k3alj0.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0x8b1e8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    return left == right ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8krd4h9c.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmp8krd4h9c.__unittest_L41_C1()\
    \ [0x4280f6]\\n??:? void tmp8krd4h9c.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0xc43b0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp2lqviit.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpp2lqviit.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpp2lqviit.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xf7582554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n\
    \    dp[0] = 1;\n    for (int i = 0; i < n; i++)\n    {\n        if (dp[i] ==\
    \ 0)\n            continue;\n        if (i < n1 && s1[i] == '(')\n           \
    \ dp[i + 1] = 1;\n        if (i < n2 && s2[i] == '(')\n            dp[i + 1] =\
    \ 1;\n        if (i < n1 && s1[i] == ')')\n            dp[i + 1] = dp[i - 1];\n\
    \        if (i < n2 && s2[i] == ')')\n            dp[i + 1] = dp[i - 1];\n   \
    \ }\n    return dp[n] == 1 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv7_4cn8b.d(25): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpv7_4cn8b.d(26): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv7_4cn8b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n  \
    \          if(c == '(')\n                open++;\n            else\n         \
    \       close++;\n        }\n    }\n    if(open != close)\n        result = \"\
    No\";\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptcwd_t6o.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmptcwd_t6o.__unittest_L40_C1()\
    \ [0x4280be]\\n??:? void tmptcwd_t6o.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0xbe06c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw3m7el5j.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpw3m7el5j.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpw3m7el5j.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x49a70554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprdp1b1nl.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmprdp1b1nl.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmprdp1b1nl.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xe40a7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp75j_aoi4.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp75j_aoi4.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp75j_aoi4.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x66bd6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n        }\n    }\n    return\
    \ count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplivebu4u.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmplivebu4u.__unittest_L36_C1()\
    \ [0x4280a6]\\n??:? void tmplivebu4u.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x8c9d2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s = lst[0] ~ lst[1];\n    auto c = 0;\n    foreach(i; s)\n\
    \    {\n        if(i == '(')\n            c++;\n        else\n            c--;\n\
    \        if(c < 0)\n            return \"No\";\n    }\n    return c == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdwr5de3t.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpdwr5de3t.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpdwr5de3t.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x24e5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzmm1supx.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpzmm1supx.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmpzmm1supx.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x84648554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(i; 0..n1)\n\
    \    {\n        if(s1[i] == '(')\n            c1++;\n        else\n          \
    \  c1--;\n    }\n    foreach(i; 0..n2)\n    {\n        if(s2[i] == '(')\n    \
    \        c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 ==\
    \ 0)\n        return \"Yes\";\n    else if(c1 > 0 && c2 < 0)\n    {\n        if(c1\
    \ == abs(c2))\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else if(c1 < 0 && c2 > 0)\n    {\n        if(abs(c1) == c2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6xj8qojc.d(25): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmp6xj8qojc.d(26): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6xj8qojc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    // Write your code here\n    int open = 0;\n    int close = 0;\n\
    \    foreach(i; lst[0])\n    {\n        if(i == '(')\n            open++;\n  \
    \      else\n            close++;\n    }\n    foreach(i; lst[1])\n    {\n    \
    \    if(i == '(')\n            open++;\n        else\n            close++;\n \
    \   }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2kyjov1d.d(57): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp2kyjov1d.__unittest_L44_C1()\
    \ [0x4280fa]\\n??:? void tmp2kyjov1d.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xec951554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcouxnfyf.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpcouxnfyf.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmpcouxnfyf.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x798a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 == 0\
    \ && c2 < 0)\n        return \"No\";\n    else if(c1 > 0 && c2 == 0)\n       \
    \ return \"No\";\n    else\n    {\n        if(c1 + c2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmfguw3k2.d(68): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290ad]\\n??:? void tmpmfguw3k2.__unittest_L55_C1()\
    \ [0x42815a]\\n??:? void tmpmfguw3k2.__modtest() [0x428314]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9fb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a938]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a835]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ddd]\\n??:? runModuleUnitTests [0x42d7d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429570]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294f7]\\n??:? _d_run_main [0x429462]\\n??:? main [0x428327]\\\
    n??:? __libc_start_main [0xa55f5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else if(c == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoqzayj7t.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpoqzayj7t.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpoqzayj7t.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xefa22554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    int c1 = 0;\n  \
    \  int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            c1++;\n\
    \        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n    \
    \    return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1\
    \ > 0 && c2 < 0)\n        return \"No\";\n    if(c1 < 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 > 0 && c2 > 0)\n        return \"Yes\";\n    if(c1 < 0 &&\
    \ c2 < 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5jvlq80r.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429105]\\n??:? void tmp5jvlq80r.__unittest_L57_C1()\
    \ [0x427d44]\\n??:? void tmp5jvlq80r.__modtest() [0x428370]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da53]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e5e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a901]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a990]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a88d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e35]\\n??:? runModuleUnitTests [0x42d829]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42954f]\\n??:? _d_run_main [0x4294ba]\\n??:? main [0x428383]\\\
    n??:? __libc_start_main [0x7330d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open > s2_close)\n        return\
    \ \"Yes\";\n    else if(s1_open > s1_close && s2_open == s2_close)\n        return\
    \ \"Yes\";\n    else if(s1_open > s1_close && s2_open > s2_close)\n    {\n   \
    \     int diff = abs(s1_open - s1_close) + abs(s2_open - s2_close);\n        if(diff\
    \ % 2 == 0)\n            return \"Yes\";\n        else\n            return \"\
    No\";\n    }\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd840qm7p.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42916d]\\n??:? void tmpd840qm7p.__unittest_L60_C1()\
    \ [0x427d98]\\n??:? void tmpd840qm7p.__modtest() [0x4283d8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dabb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ec6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a969]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e9d]\\n??:? runModuleUnitTests [0x42d891]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429630]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295b7]\\n??:? _d_run_main [0x429522]\\n??:? main [0x4283eb]\\\
    n??:? __libc_start_main [0x735ab554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpigrpbmms.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpigrpbmms.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpigrpbmms.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x67f37554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n\
    \    int n2 = s2.length;\n    int c1 = 0;\n    int c2 = 0;\n    foreach(i; 0..n1)\n\
    \    {\n        if(s1[i] == '(')\n            c1++;\n        else\n          \
    \  c1--;\n    }\n    foreach(i; 0..n2)\n    {\n        if(s2[i] == '(')\n    \
    \        c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 ==\
    \ 0)\n        return \"Yes\";\n    else if(c1 == 0 && c2 != 0)\n        return\
    \ \"No\";\n    else if(c1 != 0 && c2 == 0)\n        return \"No\";\n    else\n\
    \    {\n        if(c1 > 0)\n        {\n            if(c1 == c2)\n            \
    \    return \"Yes\";\n            else\n                return \"No\";\n     \
    \   }\n        else\n        {\n            if(c1 == c2)\n                return\
    \ \"Yes\";\n            else\n                return \"No\";\n        }\n    }\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplvsmx012.d(25): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmplvsmx012.d(26): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplvsmx012.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n\
    \    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n          \
    \  c1++;\n        else\n            c1--;\n    }\n    foreach(c; s2)\n    {\n\
    \        if(c == '(')\n            c2++;\n        else\n            c2--;\n  \
    \  }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0)\n \
    \       return \"No\";\n    if(c2 == 0)\n        return \"No\";\n    if(c1 < 0)\n\
    \        c1 = -c1;\n    if(c2 < 0)\n        c2 = -c2;\n    if(c1 % 2 == 0 && c2\
    \ % 2 == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp63w9e3k6.d(59): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290d5]\\n??:? void tmp63w9e3k6.__unittest_L55_C1()\
    \ [0x427d14]\\n??:? void tmp63w9e3k6.__modtest() [0x428340]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e2e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8d1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a960]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a85d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e05]\\n??:? runModuleUnitTests [0x42d7f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429598]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42951f]\\n??:? _d_run_main [0x42948a]\\n??:? main [0x428353]\\\
    n??:? __libc_start_main [0xe5c6c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8b25yjmv.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp8b25yjmv.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp8b25yjmv.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xfcc39554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk9jtfl55.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpk9jtfl55.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpk9jtfl55.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xae5c2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open == close)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_fp5rn72.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp_fp5rn72.__unittest_L39_C1()\
    \ [0x4280ae]\\n??:? void tmp_fp5rn72.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0xe1afa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    auto s1 = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n\
    \    int count = 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n        \
    \    count++;\n        else if(c == ')')\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkeficy9x.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpkeficy9x.__unittest_L41_C1()\
    \ [0x427e0a]\\n??:? void tmpkeficy9x.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x8c837554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp161xbpv5.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp161xbpv5.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp161xbpv5.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd07d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n  \
    \          if(c == '(')\n                open++;\n            else\n         \
    \       close++;\n        }\n    }\n    if(open != close)\n        result = \"\
    No\";\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnn0noy9y.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpnn0noy9y.__unittest_L40_C1()\
    \ [0x4280be]\\n??:? void tmpnn0noy9y.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0xb21d7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else\n      \
    \      count--;\n        if(count < 0)\n            return \"No\";\n    }\n  \
    \  return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpr3mo5qhj.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpr3mo5qhj.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpr3mo5qhj.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0xf7d79554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int left = 0;\n    int right = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            left++;\n        else\n            right++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            left++;\n\
    \        else\n            right++;\n    }\n    if(left == right)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3268hlvi.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp3268hlvi.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp3268hlvi.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xa66ce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string str = \"\";\n    foreach(i; lst)\n        str ~= i;\n \
    \   int count = 0;\n    foreach(i; str)\n    {\n        if(i == '(')\n       \
    \     count++;\n        else if(i == ')')\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    if(count == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpex3itd1c.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpex3itd1c.__unittest_L41_C1()\
    \ [0x427e0e]\\n??:? void tmpex3itd1c.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0xf1343554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8fzc58bi.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp8fzc58bi.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmp8fzc58bi.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x63be4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp61qa95ll.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp61qa95ll.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp61qa95ll.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd2677554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2spm5f_z.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp2spm5f_z.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmp2spm5f_z.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x11bbf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count1 =\
    \ 0;\n    int count2 = 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n \
    \           count1++;\n        else\n            count1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count2++;\n        else\n    \
    \        count2--;\n    }\n    if(count1 == 0 && count2 == 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8curv7dg.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp8curv7dg.__unittest_L46_C1()\
    \ [0x427c94]\\n??:? void tmp8curv7dg.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0xd395b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else if(c == ')')\n                count--;\n            if(count < 0)\n\
    \                return \"No\";\n        }\n    }\n    return count == 0 ? \"\
    Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp43gi9qf2.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp43gi9qf2.__unittest_L38_C1()\
    \ [0x427dde]\\n??:? void tmp43gi9qf2.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x580b7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            cnt++;\n        else\n        \
    \    cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n    return\
    \ cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpde62ezsr.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpde62ezsr.__unittest_L36_C1()\
    \ [0x427dee]\\n??:? void tmpde62ezsr.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x3b5ce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int s1_open\
    \ = 0;\n    int s2_open = 0;\n    int s1_close = 0;\n    int s2_close = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            s1_open++;\n    \
    \    else\n            s1_close++;\n    }\n    foreach(c; s2)\n    {\n       \
    \ if(c == '(')\n            s2_open++;\n        else\n            s2_close++;\n\
    \    }\n    if(s1_open == s1_close && s2_open == s2_close)\n        return \"\
    Yes\";\n    else if(s1_open == s1_close && s2_open > s2_close)\n        return\
    \ \"Yes\";\n    else if(s1_open > s1_close && s2_open == s2_close)\n        return\
    \ \"Yes\";\n    else if(s1_open > s1_close && s2_open > s2_close)\n    {\n   \
    \     if(s1_open - s1_close == s2_close - s2_open)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    else\n        return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpifazvmyc.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290ed]\\n??:? void tmpifazvmyc.__unittest_L59_C1()\
    \ [0x427d28]\\n??:? void tmpifazvmyc.__modtest() [0x428354]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8e9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a978]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a875]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e1d]\\n??:? runModuleUnitTests [0x42d811]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429537]\\n??:? _d_run_main [0x4294a2]\\n??:? main [0x428367]\\\
    n??:? __libc_start_main [0xea272554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpq63aouu7.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpq63aouu7.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpq63aouu7.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x65863554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe3nyx37l.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpe3nyx37l.__unittest_L39_C1()\
    \ [0x4280aa]\\n??:? void tmpe3nyx37l.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x3387e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \      return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvjcw7bxc.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpvjcw7bxc.__unittest_L38_C1()\
    \ [0x427dda]\\n??:? void tmpvjcw7bxc.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xcb7f9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string result = \"Yes\";\n    int open = 0;\n    int close = 0;\n\
    \    foreach(string s; lst)\n    {\n        foreach(char c; s)\n        {\n  \
    \          if(c == '(')\n                open++;\n            else if(c == ')')\n\
    \                close++;\n        }\n    }\n    if(open != close)\n        result\
    \ = \"No\";\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd9ekj695.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpd9ekj695.__unittest_L40_C1()\
    \ [0x4280c2]\\n??:? void tmpd9ekj695.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x6d4a6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplq7p7iu7.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmplq7p7iu7.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmplq7p7iu7.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x15d23554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    string s = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c;\
    \ s)\n    {\n        if(c == '(')\n            count++;\n        else if(c ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqewt9tkq.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpqewt9tkq.__unittest_L36_C1()\
    \ [0x427df6]\\n??:? void tmpqewt9tkq.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x81eb8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given an array\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>>\
    \ match_parens([\")\", \")\"])\n    \"No\"\n    \n*/\nstring match_parens(string[]\
    \ lst) \n{\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n  \
    \  {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmi8_y734.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpmi8_y734.__unittest_L43_C1()\
    \ [0x4280fa]\\n??:? void tmpmi8_y734.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x89f0a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
