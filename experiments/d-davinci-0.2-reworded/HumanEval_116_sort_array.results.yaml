name: HumanEval_116_sort_array
language: d
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpacmtyqnx.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpacmtyqnx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    return arr.sort!((a, b) => \n    {\n  \
    \      auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n      \
    \  if (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw7y52dv9.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7y52dv9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto aBits = a.to!string.count(\"\
    1\");\n        auto bBits = b.to!string.count(\"1\");\n        return aBits ==\
    \ bBits ? a.compare(b) : aBits.compare(bBits);\n    });\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc8w2d74d.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc8w2d74d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpojxfb6kg.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpojxfb6kg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes();\n\
    \        int b_ones = b.countOnes();\n        if (a_ones == b_ones)\n        \
    \    return a - b;\n        return a_ones - b_ones;\n    });\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy1mwuyrr.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy1mwuyrr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjps4a8sn.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpjps4a8sn.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjps4a8sn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 = aa.count(\"\
    1\");\n        auto b1 = bb.count(\"1\");\n        if (a1 == b1)\n           \
    \ return a > b;\n        return a1 > b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqezu9cks.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqezu9cks.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    long[] ones = new long[arr.length];\n\
    \    long[] zeros = new long[arr.length];\n    int z = 0;\n    int o = 0;\n  \
    \  foreach(long i; arr)\n    {\n        if(i < 0)\n            continue;\n   \
    \     if(i == 0)\n            zeros[z++] = i;\n        else\n            ones[o++]\
    \ = i;\n    }\n    ones = ones[0..o];\n    zeros = zeros[0..z];\n    sort!((a,\
    \ b) => countOnes(a) < countOnes(b) || (countOnes(a) == countOnes(b) && a < b))(ones);\n\
    \    sort!((a, b) => countOnes(a) < countOnes(b) || (countOnes(a) == countOnes(b)\
    \ && a < b))(zeros);\n    int i = 0;\n    foreach(long z; zeros)\n        result[i++]\
    \ = z;\n    foreach(long o; ones)\n        result[i++] = o;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppo357tqp.d(36): Error: template instance `sort!((a, b) => countOnes(a)\
    \ < countOnes(b) || countOnes(a) == countOnes(b) && (a < b))` template `sort`\
    \ is not defined, did you mean sqrt?\\n/tmp/tmppo357tqp.d(37): Error: template\
    \ instance `sort!((a, b) => countOnes(a) < countOnes(b) || countOnes(a) == countOnes(b)\
    \ && (a < b))` template `sort` is not defined, did you mean sqrt?\\n/tmp/tmppo357tqp.d(39):\
    \ Error: variable `z` is shadowing variable `tmppo357tqp.sort_array.z`\\n/tmp/tmppo357tqp.d(41):\
    \ Error: variable `o` is shadowing variable `tmppo357tqp.sort_array.o`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo357tqp.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptuk9advr.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptuk9advr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv7al9f_e.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv7al9f_e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_len = arr.length;\n    auto arr_copy = arr.dup;\n   \
    \ auto arr_ones = new long[arr_len];\n    auto arr_sorted = new long[arr_len];\n\
    \    auto arr_sorted_ones = new long[arr_len];\n    auto arr_sorted_copy = new\
    \ long[arr_len];\n    auto arr_sorted_copy_ones = new long[arr_len];\n    auto\
    \ arr_sorted_copy_ones_sorted = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted = new\
    \ long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index = new\
    \ long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_sorted_index_sorted_index_sorted\
    \ = new long[arr_len];\n    auto arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_s\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprwqppuzl.d(39): Error: no identifier for declarator `arr_sorted_copy_ones_sorted_index_sorted_index_sorted_index_s`\\\
    n/tmp/tmprwqppuzl.d(39): Error: found `unittest` instead of statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwqppuzl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string(2);\n        auto b1 = b.to!string(2);\n        if (a1.count('1')\
    \ == b1.count('1'))\n            return a < b;\n        return a1.count('1') <\
    \ b1.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw7jv5biy.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw7jv5biy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_pc2knjf.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_pc2knjf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpshffgzsn.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpshffgzsn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort!((a, b) => a.countOnes() ==\
    \ b.countOnes() ? a - b : a.countOnes() - b.countOnes())(sorted);\n    return\
    \ sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3xaevutq.d(21): Error: template instance `sort!((a, b) => a.countOnes()\
    \ == b.countOnes() ? a - b : a.countOnes() - b.countOnes())` template `sort` is\
    \ not defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3xaevutq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgbh3lk1d.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgbh3lk1d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvihy46rt.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvihy46rt.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] result = new long[arr.length];\n\
    \    long[] ones = new long[arr.length];\n    long[] zeros = new long[arr.length];\n\
    \    long[] zeros_copy = new long[arr.length];\n    long[] ones_copy = new long[arr.length];\n\
    \    int zeros_index = 0;\n    int ones_index = 0;\n    int result_index = 0;\n\
    \    foreach(i; arr)\n    {\n        if(i == 0)\n        {\n            zeros[zeros_index]\
    \ = i;\n            zeros_index++;\n        }\n        else\n        {\n     \
    \       ones[ones_index] = i;\n            ones_index++;\n        }\n    }\n \
    \   zeros_copy = zeros[0..zeros_index];\n    ones_copy = ones[0..ones_index];\n\
    \    ones_copy.sort!((a, b) => count_ones(a) < count_ones(b));\n    foreach(i;\
    \ ones_copy)\n    {\n        result[result_index] = i;\n        result_index++;\n\
    \    }\n    zeros_copy.sort!((a, b) => a < b);\n    foreach(i; zeros_copy)\n \
    \   {\n        result[result_index] = i;\n        result_index++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5_1w5fmx.d(44): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5_1w5fmx.d(50): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_1w5fmx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxwuf87ln.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxwuf87ln.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto cmp = (a, b) => a.countOnes == b.countOnes ? a - b : a.countOnes\
    \ - b.countOnes;\n    return arr.sort!cmp;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcd9kauzo.d(20): Error: variable `tmpcd9kauzo.sort_array.cmp`\
    \ type `void` is inferred from initializer `(a, b) => a.countOnes == b.countOnes\
    \ ? a - b : a.countOnes - b.countOnes`, and variables cannot be of type `void`\\\
    n/tmp/tmpcd9kauzo.d(20): Error: template lambda has no value\\n/tmp/tmpcd9kauzo.d(21):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpcd9kauzo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // Your code here\n    auto arr_tuple = new Tuple!(long, long)[arr.length];\n\
    \    foreach(i, e; arr)\n    {\n        arr_tuple[i] = tuple(e, count_ones(e));\n\
    \    }\n    sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]))(arr_tuple);\n\
    \    foreach(i, e; arr_tuple)\n    {\n        arr[i] = e[0];\n    }\n    return\
    \ arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8t9mj08i.d(24): Error: undefined identifier `count_ones`\\n/tmp/tmp8t9mj08i.d(26):\
    \ Error: template instance `sort!((a, b) => a[1] < b[1] || a[1] == b[1] && (a[0]\
    \ < b[0]))` template `sort` is not defined, did you mean sqrt?\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8t9mj08i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwvbi3w7.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwvbi3w7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpll8yjc29.d(20): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpll8yjc29.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkd2tc9l5.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkd2tc9l5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_mq128k.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_mq128k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string.count('1');\n        auto b_ = b.to!string.count('1');\n\
    \        return a_ == b_ ? a.compare(b) : a_.compare(b_);\n    });\n    return\
    \ arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxu4ghxz0.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxu4ghxz0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj9ecq2lv.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj9ecq2lv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string;\n        auto b_ = b.to!string;\n        auto a_count\
    \ = a_.count!((c) => c == '1');\n        auto b_count = b_.count!((c) => c ==\
    \ '1');\n        if (a_count == b_count)\n            return a < b;\n        return\
    \ a_count < b_count;\n    });\n    return arr_;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1i6enxt7.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1i6enxt7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        int a1 = a.countOnes;\n        int b1 = b.countOnes;\n        if (a1\
    \ == b1)\n            return a - b;\n        return a1 - b1;\n    });\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr277aqsy.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr277aqsy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpryrrn_sl.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpryrrn_sl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkp58jbcc.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpkp58jbcc.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpkp58jbcc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[][] arr2 = new long[arr.length][2];\n    foreach(i, e; arr)\n\
    \    {\n        arr2[i][0] = e;\n        arr2[i][1] = e.countOnes;\n    }\n  \
    \  arr2.sort!((a, b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return\
    \ arr2.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_twz2gs.d(20): Error: variable `arr` cannot be read at compile\
    \ time\\n/tmp/tmpm_twz2gs.d(24): Error: no property `countOnes` for type `long`\\\
    n/tmp/tmpm_twz2gs.d(26): Error: no property `sort` for type `long[][]`\\n/tmp/tmpm_twz2gs.d(27):\
    \ Error: no property `map` for type `long[][]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpm_twz2gs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbgl0ezgy.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbgl0ezgy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 =\
    \ aa.count('1');\n        auto b1 = bb.count('1');\n        if (a1 == b1)\n  \
    \          return a > b;\n        return a1 > b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4tdg96ax.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4tdg96ax.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpli6swot6.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpli6swot6.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpli6swot6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcyt46qqb.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyt46qqb.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] result = new long[arr.length];\n\
    \    int[] count = new int[arr.length];\n    for(int i = 0; i < arr.length; i++)\n\
    \    {\n        count[i] = countOnes(arr[i]);\n    }\n    int[] sorted = sort(count);\n\
    \    int[] index = new int[arr.length];\n    for(int i = 0; i < arr.length; i++)\n\
    \    {\n        index[i] = findIndex(count, sorted[i]);\n    }\n    for(int i\
    \ = 0; i < arr.length; i++)\n    {\n        result[i] = arr[index[i]];\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpofonyuqb.d(25): Error: undefined identifier `countOnes`\\n/tmp/tmpofonyuqb.d(27):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmpofonyuqb.d(31):\
    \ Error: undefined identifier `findIndex`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpofonyuqb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes, a).cmp((b.countOnes,\
    \ b)));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5tj6d8t2.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5tj6d8t2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return\
    \ a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return arr2;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4jbbyt70.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4jbbyt70.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk82el8xb.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk82el8xb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        if (a1 ==\
    \ b1)\n            return a < b;\n        return a1 < b1;\n    });\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb525ujic.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb525ujic.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort!((a, b) => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b))(arr2);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnbcqhy5q.d(21): Error: template instance `sort!((a, b) => a.countOnes\
    \ > b.countOnes || a.countOnes == b.countOnes && (a > b))` template `sort` is\
    \ not defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpnbcqhy5q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] ret = arr.dup;\n    ret.sort!((a, b) => \n    {\n     \
    \   int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n   \
    \ });\n    return ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpavkn3k46.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpavkn3k46.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        return a2 == b2 ? a < b : a2 < b2;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9rhhkgq3.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9rhhkgq3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n    \
    \    return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_yaix_i3.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_yaix_i3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string;\n        auto b_ = b.to!string;\n        auto a_1 =\
    \ a_.count('1');\n        auto b_1 = b_.count('1');\n        if (a_1 == b_1)\n\
    \            return a < b;\n        return a_1 < b_1;\n    });\n    return arr_;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_9lod9sm.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_9lod9sm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n      \
    \  if (onesA == onesB)\n            return a - b;\n        return onesA - onesB;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0hi2bnq1.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0hi2bnq1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) =>\n    {\n        auto\
    \ x = a.countOnes;\n        auto y = b.countOnes;\n        if (x == y)\n     \
    \       return a < b;\n        return x < y;\n    });\n    return a;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphdgi5f93.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphdgi5f93.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ak8h_ql.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ak8h_ql.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n      \
    \  if (a_ones == b_ones)\n            return a.compare(b);\n        return a_ones.compare(b_ones);\n\
    \    });\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp56zox4dc.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp56zox4dc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzgegf9fk.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgegf9fk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string(2);\n        auto bb = b.to!string(2);\n        auto\
    \ a1 = aa.count('1');\n        auto b1 = bb.count('1');\n        if (a1 == b1)\n\
    \            return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx1m91jws.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx1m91jws.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjxn8_1y8.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpjxn8_1y8.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjxn8_1y8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort!((a, b) => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b))(arr2);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjqdmw64e.d(21): Error: template instance `sort!((a, b) => a.countOnes\
    \ > b.countOnes || a.countOnes == b.countOnes && (a > b))` template `sort` is\
    \ not defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpjqdmw64e.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpub13zj3k.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpub13zj3k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4brxlmmy.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmp4brxlmmy.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4brxlmmy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp86au2c0l.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp86au2c0l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        auto a_ones = count(a.to!string, '1');\n        auto b_ones = count(b.to!string,\
    \ '1');\n        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n\
    \    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvzpb1zmj.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvzpb1zmj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_with_ones = arr.map!(a => tuple(a, a.countOnes)).array;\n\
    \    arr_with_ones.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    return arr_with_ones.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps3y4x9tm.d(20): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps3y4x9tm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmxosv1gi.d(20): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmxosv1gi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => {\n        auto\
    \ a_ones = a.to!string.count!(c => c == '1');\n        auto b_ones = b.to!string.count!(c\
    \ => c == '1');\n        if (a_ones == b_ones)\n            return a < b;\n  \
    \      return a_ones < b_ones;\n    });\n    return arr2;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb1ngnm0v.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb1ngnm0v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n        if\
    \ (a_ones == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfebu2nch.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfebu2nch.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto sorted = arr.dup;\n    sorted.sort!((a, b) =>\n    {\n  \
    \      auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n      \
    \  if (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz8me655u.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz8me655u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes));\n    arr_tuple.sort!((a,\
    \ b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnk8g8cal.d(20): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnk8g8cal.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg7uapmnb.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpg7uapmnb.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg7uapmnb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw60zugck.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw60zugck.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] sorted = arr.dup;\n    sort(sorted,\
    \ (a, b) =>\n    {\n        if (a == b)\n            return 0;\n        if (a\
    \ < 0)\n            return -1;\n        if (b < 0)\n            return 1;\n  \
    \      int a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n      \
    \  if (a_ones == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp297apyu_.d(22): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp297apyu_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int aOnes = a.countOnes;\n\
    \        int bOnes = b.countOnes;\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprjfene6t.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprjfene6t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sorted.sort!((a, b) => \n    {\n\
    \        int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n      \
    \  if (a_ones == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2z3mpb5q.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2z3mpb5q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int a_ones = countOnes(a);\n        int b_ones = countOnes(b);\n    \
    \    return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk1o2lox2.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk1o2lox2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        long a_ones = countOnes(a);\n        long b_ones = countOnes(b);\n  \
    \      return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a > b\
    \ ? 1 : 0;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp81x7g818.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp81x7g818.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_u5udiun.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_u5udiun.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        return a1 == b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplyfagsga.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplyfagsga.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1hj5wur7.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1hj5wur7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps38_7m_u.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps38_7m_u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int aOnes = a.countOnes;\n\
    \        int bOnes = b.countOnes;\n        if (aOnes == bOnes)\n            return\
    \ a - b;\n        return aOnes - bOnes;\n    });\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkl5_ctdf.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkl5_ctdf.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return\
    \ a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return arr2;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph726vgu7.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph726vgu7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = new Tuple!(long, int)[arr.length];\n    foreach(i,\
    \ e; arr)\n    {\n        arr_tuple[i] = tuple(e, e.countOnes);\n    }\n    arr_tuple.sort!((a,\
    \ b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return arr_tuple.map!(a\
    \ => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpojf3td7n.d(23): Error: no property `countOnes` for type `long`\\\
    n/tmp/tmpojf3td7n.d(25): Error: no property `sort` for type `Tuple!(long, int)[]`\\\
    n/tmp/tmpojf3td7n.d(26): Error: no property `map` for type `Tuple!(long, int)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpojf3td7n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpod7rrqei.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpod7rrqei.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes));\n\
    \    arr2.sort!((a, b) => a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp703qud92.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp703qud92.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp703qud92.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) => \n    {\n        auto\
    \ a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n   \
    \ });\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf9tscrak.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9tscrak.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqqm_80nj.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqqm_80nj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    // your code here\n    long[] result = arr.dup;\n    sort(result,\
    \ (a, b) =>\n    {\n        auto a_ones = countOnes(a);\n        auto b_ones =\
    \ countOnes(b);\n        if (a_ones == b_ones)\n            return a - b;\n  \
    \      return a_ones - b_ones;\n    });\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_xi2ptnl.d(22): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_xi2ptnl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps6niub6n.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6niub6n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_a_kdt5w.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_a_kdt5w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a.compare(b) : a_ones.compare(b_ones);\n  \
    \  });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl8jscw5m.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl8jscw5m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) {\n        auto a1\
    \ = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n     \
    \   if (a1 == b1)\n            return a < b;\n        return a1 < b1;\n    });\n\
    \    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjki0s889.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjki0s889.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  if (a == b) return 0;\n        if (a < 0) return -1;\n        if (b < 0) return\
    \ 1;\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones) return a < b ? -1 : 1;\n        return a_ones <\
    \ b_ones ? -1 : 1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp293my1q9.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp293my1q9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmple9hwewr.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmple9hwewr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return\
    \ a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a > b ? 1 : 0;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5owhnjwh.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5owhnjwh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes >\
    \ b.countOnes) ? 1 : (a.countOnes < b.countOnes) ? -1 : (a > b) ? 1 : -1);\n \
    \   return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmqjk8zpy.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqjk8zpy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9wxksj05.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9wxksj05.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg1v6mfqy.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpg1v6mfqy.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg1v6mfqy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 =\
    \ aa.count('1');\n        auto b1 = bb.count('1');\n        if (a1 == b1)\n  \
    \          return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe7s90ycz.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe7s90ycz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string;\n        auto b_ = b.to!string;\n        auto a_ones\
    \ = a_.count('1');\n        auto b_ones = b_.count('1');\n        if (a_ones ==\
    \ b_ones)\n            return a < b;\n        return a_ones < b_ones;\n    });\n\
    \    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph5_i4oxx.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph5_i4oxx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = count_ones(a);\n        auto b_ones = count_ones(b);\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppo9frwk3.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppo9frwk3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes, a).cmp((b.countOnes,\
    \ b)));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd581h7xc.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd581h7xc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr_sorted = sort(arr_, (a, b)\
    \ =>\n    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp24x6vaw.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp24x6vaw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0i6blt8g.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0i6blt8g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd2ynndyb.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd2ynndyb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    long[] ones = new long[arr.length];\n\
    \    long[] zeros = new long[arr.length];\n    int j = 0;\n    int k = 0;\n  \
    \  for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] < 0)\n    \
    \    {\n            result[i] = arr[i];\n        }\n        else\n        {\n\
    \            if (arr[i] == 0)\n            {\n                zeros[j] = arr[i];\n\
    \                j++;\n            }\n            else\n            {\n      \
    \          ones[k] = arr[i];\n                k++;\n            }\n        }\n\
    \    }\n    ones = ones[0..k];\n    zeros = zeros[0..j];\n    ones.sort!((a, b)\
    \ => countOnes(a) < countOnes(b));\n    zeros.sort!((a, b) => a < b);\n    j =\
    \ 0;\n    k = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if\
    \ (result[i] < 0)\n        {\n            continue;\n        }\n        else\n\
    \        {\n            if (j < zeros.length)\n            {\n               \
    \ result[i] = zeros[j];\n                j++;\n            }\n            else\n\
    \            {\n                result[i] = ones[k];\n                k++;\n \
    \           }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq8i2epsd.d(47): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpq8i2epsd.d(48): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq8i2epsd.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => \n\
    \    {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp53d5nw6s.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp53d5nw6s.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplpao6tst.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplpao6tst.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw3meswqd.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw3meswqd.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvst7cwww.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvst7cwww.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) => \n    {\n\
    \        if (a == b)\n            return 0;\n        else if (a < 0)\n       \
    \     return 1;\n        else if (b < 0)\n            return -1;\n        else\n\
    \        {\n            int aOnes = a.countOnes;\n            int bOnes = b.countOnes;\n\
    \            if (aOnes == bOnes)\n                return a - b;\n            else\n\
    \                return aOnes - bOnes;\n        }\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjduk99ed.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjduk99ed.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n\
    \        return a_ones < b_ones ? -1 : a_ones > b_ones ? 1 : a < b ? -1 : a >\
    \ b ? 1 : 0;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8jf1fhgb.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8jf1fhgb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        return\
    \ a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return arr2;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoziclca8.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoziclca8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpma_wakms.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpma_wakms.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto result = arr.dup;\n    auto sort = (a, b) =>\n    {\n   \
    \     auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n       \
    \ return a_ones == b_ones ? a - b : a_ones - b_ones;\n    };\n    result.sort(sort);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5s2uippv.d(21): Error: variable `tmp5s2uippv.sort_array.sort`\
    \ type `void` is inferred from initializer `(a, b) => ()\\n{\\nauto a_ones = a.countOnes;\\\
    nauto b_ones = b.countOnes;\\nreturn a_ones == b_ones ? a - b : a_ones - b_ones;\\\
    n}\\n`, and variables cannot be of type `void`\\n/tmp/tmp5s2uippv.d(21): Error:\
    \ template lambda has no value\\n/tmp/tmp5s2uippv.d(27): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5s2uippv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr2 = arr_.sort!((a, b) => a.countOnes\
    \ > b.countOnes);\n    auto arr3 = arr2.sort!((a, b) => a.countOnes == b.countOnes\
    \ && a > b);\n    return arr3;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5klh9_6d.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5klh9_6d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    long[] ones = new long[arr.length];\n\
    \    long[] zeros = new long[arr.length];\n    int i = 0;\n    int j = 0;\n  \
    \  int k = 0;\n    foreach(long num; arr)\n    {\n        if(num < 0)\n      \
    \  {\n            result[i] = num;\n            i++;\n        }\n        else\n\
    \        {\n            if(num == 0)\n            {\n                zeros[j]\
    \ = num;\n                j++;\n            }\n            else\n            {\n\
    \                ones[k] = num;\n                k++;\n            }\n       \
    \ }\n    }\n    ones = sort(ones);\n    zeros = sort(zeros);\n    i = 0;\n   \
    \ j = 0;\n    k = 0;\n    foreach(long num; arr)\n    {\n        if(num < 0)\n\
    \        {\n            result[i] = num;\n            i++;\n        }\n      \
    \  else\n        {\n            if(num == 0)\n            {\n                result[i]\
    \ = zeros[j];\n                i++;\n                j++;\n            }\n   \
    \         else\n            {\n                result[i] = ones[k];\n        \
    \        i++;\n                k++;\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg058rw1v.d(47): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmpg058rw1v.d(48): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpg058rw1v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = new long[arr.length];\n    long[] ones = new long[arr.length];\n\
    \    for (int i = 0; i < arr.length; i++)\n    {\n        ones[i] = count_ones(arr[i]);\n\
    \    }\n    sort(ones);\n    foreach(i, v; ones)\n    {\n        foreach(j, w;\
    \ arr)\n        {\n            if (v == count_ones(w))\n            {\n      \
    \          result[i] = w;\n                arr[j] = -1;\n                break;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq2x0imt5.d(24): Error: undefined identifier `count_ones`\\n/tmp/tmpq2x0imt5.d(26):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\n/tmp/tmpq2x0imt5.d(31):\
    \ Error: undefined identifier `count_ones`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpq2x0imt5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto result = arr.dup;\n    auto sort = sort!((a, b) =>\n    {\n\
    \        auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        return a1 < b1 || (a1 == b1 && a < b);\n    });\n    sort(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_ud7bg_.d(21): Error: template instance `sort!((a, b) => ()\\\
    n{\\nauto a1 = a.to!string.count(\\'1\\');\\nauto b1 = b.to!string.count(\\'1\\\
    ');\\nreturn a1 < b1 || a1 == b1 && (a < b);\\n}\\n)` template `sort` is not defined,\
    \ did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm_ud7bg_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto sort_by_ones = (long a, long b)\n    {\n        return countOnes(a)\
    \ == countOnes(b) ? a - b : countOnes(a) - countOnes(b);\n    };\n    return arr.sort(sort_by_ones);\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnm07ya55.d(22): Error: undefined identifier `countOnes`\\n/tmp/tmpnm07ya55.d(22):\
    \ Error: undefined identifier `countOnes`\\n/tmp/tmpnm07ya55.d(22): Error: undefined\
    \ identifier `countOnes`\\n/tmp/tmpnm07ya55.d(22): Error: undefined identifier\
    \ `countOnes`\\n/tmp/tmpnm07ya55.d(24): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnm07ya55.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgkxjff34.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgkxjff34.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] res = arr.dup;\n    res.sort!((a, b) =>\n    {\n      \
    \  int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a - b;\n        return a_ones - b_ones;\n   \
    \ });\n    return res;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n\
    \    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxfhpnqe9.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxfhpnqe9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) => \n    {\n     \
    \   auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1\
    \ == b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpagbm0duo.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpagbm0duo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        long a_ones = a.countOnes;\n        long b_ones = b.countOnes;\n    \
    \    if (a_ones == b_ones)\n            return a - b;\n        return a_ones -\
    \ b_ones;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmrltry3a.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmrltry3a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b));\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiknoza4v.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiknoza4v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string;\n        auto b_ = b.to!string;\n        if (a_.count(\"\
    1\") == b_.count(\"1\"))\n            return a < b;\n        return a_.count(\"\
    1\") < b_.count(\"1\");\n    });\n    return arr_;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppt60sjv_.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppt60sjv_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl36hk8v2.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpl36hk8v2.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpl36hk8v2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 =\
    \ aa.count(\"1\");\n        auto b1 = bb.count(\"1\");\n        if (a1 == b1)\n\
    \            return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1yf1rj8_.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1yf1rj8_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto cmp = (a, b) =>\n    {\n        auto a_ones = countOnes(a);\n\
    \        auto b_ones = countOnes(b);\n        return a_ones == b_ones ? a - b\
    \ : a_ones - b_ones;\n    };\n    return arr.sort!cmp;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43pih70f.d(20): Error: variable `tmp43pih70f.sort_array.cmp`\
    \ type `void` is inferred from initializer `(a, b) => ()\\n{\\nauto a_ones = countOnes(a);\\\
    nauto b_ones = countOnes(b);\\nreturn a_ones == b_ones ? a - b : a_ones - b_ones;\\\
    n}\\n`, and variables cannot be of type `void`\\n/tmp/tmp43pih70f.d(20): Error:\
    \ template lambda has no value\\n/tmp/tmp43pih70f.d(26): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43pih70f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int aOnes = a.countOnes;\n\
    \        int bOnes = b.countOnes;\n        return aOnes == bOnes ? a.compare(b)\
    \ : aOnes.compare(bOnes);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxi6bmzz6.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxi6bmzz6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string.count('1');\n        auto bb = b.to!string.count('1');\n\
    \        if (aa == bb)\n            return a < b;\n        return aa < bb;\n \
    \   });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ypixm9b.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ypixm9b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        if (a < 0 || b < 0)\n            return a < b ? -1 : 1;\n        int\
    \ aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n        if (aOnes\
    \ == bOnes)\n            return a < b ? -1 : 1;\n        return aOnes < bOnes\
    \ ? -1 : 1;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6rbjv9uz.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6rbjv9uz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppim843t_.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppim843t_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string(2);\n        auto b_ = b.to!string(2);\n        if (a_.count('1')\
    \ == b_.count('1'))\n            return a < b;\n        return a_.count('1') <\
    \ b_.count('1');\n    });\n    return arr_;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdgzi1xbu.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdgzi1xbu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        return a2 == b2 ? a < b : a2 < b2;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwlno706f.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwlno706f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] res = arr.dup;\n    res.sort!((a, b) =>\n    {\n      \
    \  if (a == b)\n            return 0;\n        int aOnes = countOnes(a);\n   \
    \     int bOnes = countOnes(b);\n        if (aOnes == bOnes)\n            return\
    \ a < b ? -1 : 1;\n        return aOnes < bOnes ? -1 : 1;\n    });\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp39jlcztp.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp39jlcztp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        auto a1 = a.countOnes;\n\
    \        auto b1 = b.countOnes;\n        return a1 == b1 ? a - b : a1 - b1;\n\
    \    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_odn2co8.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_odn2co8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj5b_ngzm.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj5b_ngzm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto a = arr.dup;\n    a.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return a;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4qd29_c7.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4qd29_c7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7fj57t0a.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7fj57t0a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto aa = a.to!string.count('1');\n        auto bb = b.to!string.count('1');\n\
    \        return aa == bb ? a.compare(b) : aa.compare(bb);\n    });\n    return\
    \ arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppnxdzobm.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppnxdzobm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    int[] ones = new int[arr.length];\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        ones[i] = countOnes(arr[i]);\n    }\n    return arr.sort!((a,\
    \ b) => ones[a] == ones[b] ? a - b : ones[a] - ones[b]);\n}\nunittest\n{\n   \
    \ alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppafpkjsj.d(23): Error: undefined identifier `countOnes`\\n/tmp/tmppafpkjsj.d(25):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmppafpkjsj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        auto aBits = a.to!string.count!(c\
    \ => c == '1');\n        auto bBits = b.to!string.count!(c => c == '1');\n   \
    \     return aBits == bBits ? a - b : aBits - bBits;\n    });\n}\nunittest\n{\n\
    \    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfqh2p53o.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfqh2p53o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto result = arr.dup;\n    result.sort!((a, b) => \n    {\n \
    \       auto aOnes = countOnes(a);\n        auto bOnes = countOnes(b);\n     \
    \   return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_wvcrbz2.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_wvcrbz2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b));\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_s59v_a.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_s59v_a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int onesA = countOnes(a);\n        int onesB = countOnes(b);\n      \
    \  if (onesA == onesB)\n            return a < b ? -1 : 1;\n        return onesA\
    \ < onesB ? -1 : 1;\n    });\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0vhbkmof.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0vhbkmof.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => (a.countOnes\
    \ == b.countOnes) ? a - b : a.countOnes - b.countOnes);\n    return arr_sorted;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxasvallh.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxasvallh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvuyebcfv.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvuyebcfv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6olzujav.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmp6olzujav.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp6olzujav.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        if (a == b)\n            return 0;\n        long aOnes = countOnes(a);\n\
    \        long bOnes = countOnes(b);\n        if (aOnes == bOnes)\n           \
    \ return a < b ? -1 : 1;\n        return aOnes < bOnes ? -1 : 1;\n    });\n  \
    \  return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvvdo_qu_.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvvdo_qu_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = new Tuple!(long, int)[arr.length];\n    foreach(i,\
    \ e; arr)\n    {\n        arr_tuple[i] = tuple(e, cast(int)e.countOnes);\n   \
    \ }\n    arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0] < b[0]));\n\
    \    foreach(i, e; arr_tuple)\n    {\n        arr[i] = e[0];\n    }\n    return\
    \ arr;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvcy3uvoo.d(23): Error: no property `countOnes` for type `long`\\\
    n/tmp/tmpvcy3uvoo.d(25): Error: no property `sort` for type `Tuple!(long, int)[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvcy3uvoo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvss7jp9f.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvss7jp9f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string(2);\n        auto b1 = b.to!string(2);\n        if (a1.count!(c\
    \ => c == '1') == b1.count!(c => c == '1'))\n            return a < b;\n     \
    \   return a1.count!(c => c == '1') < b1.count!(c => c == '1');\n    });\n   \
    \ return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4s1tz167.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4s1tz167.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    sort(arr_, (a, b) => \n    {\n     \
    \   auto a_ = a.countOnes;\n        auto b_ = b.countOnes;\n        if (a_ ==\
    \ b_)\n            return a < b;\n        return a_ < b_;\n    });\n    return\
    \ arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprk4cxf7d.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprk4cxf7d.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    int[] ones = new int[arr.length];\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        ones[i] = countOnes(arr[i]);\n    }\n    return sort(arr,\
    \ ones);\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpys7y_ofl.d(23): Error: undefined identifier `countOnes`\\n/tmp/tmpys7y_ofl.d(25):\
    \ Error: undefined identifier `sort`, did you mean function `sqrt`?\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpys7y_ofl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!((a, b) =>\n    {\n      \
    \  auto a_ = a.to!string;\n        auto b_ = b.to!string;\n        auto a_ones\
    \ = a_.count('1');\n        auto b_ones = b_.count('1');\n        if (a_ones ==\
    \ b_ones)\n            return a < b;\n        return a_ones < b_ones;\n    });\n\
    \    return arr_;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8ixuzs5g.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8ixuzs5g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 = a1.count('1');\n\
    \        auto b2 = b1.count('1');\n        if (a2 == b2)\n            return a\
    \ < b;\n        return a2 < b2;\n    });\n    return arr2;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv1q4dsb1.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv1q4dsb1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a.compare(b);\n        return\
    \ a_ones.compare(b_ones);\n    });\n    return arr_sorted;\n}\nunittest\n{\n \
    \   alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiu4cyezb.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu4cyezb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk3spytoi.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk3spytoi.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    sort(result, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0gq3up3z.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0gq3up3z.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  return aOnes == bOnes ? a - b : aOnes - bOnes;\n    });\n    return result;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmpsn4rbe.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpsn4rbe.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => (a.countOnes ==\
    \ b.countOnes) ? a < b : a.countOnes < b.countOnes);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzlkawi63.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzlkawi63.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 ==\
    \ b1 ? a < b : a1 < b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpipshvcki.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpipshvcki.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, countOnes(a)));\n    auto\
    \ sorted_arr = arr_tuple.sort!((a, b) => a[1] < b[1] || (a[1] == b[1] && a[0]\
    \ < b[0]));\n    return sorted_arr.map!(a => a[0]).array;\n}\nunittest\n{\n  \
    \  alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L])\
    \ == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) ==\
    \ [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L,\
    \ 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzvcranty.d(20): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzvcranty.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.countOnes;\n        auto b1 = b.countOnes;\n        return a1 ==\
    \ b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpotdv9d0p.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpotdv9d0p.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    sort(result, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a < b ? -1 : 1;\n        return aOnes\
    \ < bOnes ? -1 : 1;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkcaxiqhx.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkcaxiqhx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_tuple = arr.map!(a => tuple(a, a.countOnes()));\n   \
    \ arr_tuple.sort!((a, b) => a[1] == b[1] ? a[0] < b[0] : a[1] < b[1]);\n    return\
    \ arr_tuple.map!(a => a[0]).array;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv3zw8_h8.d(20): Error: no property `map` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv3zw8_h8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) => \n    {\n\
    \        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n        if\
    \ (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplr1892k5.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplr1892k5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    auto arr_sorted = sort(arr_, (a, b)\
    \ => \n    {\n        auto a_ = cast(int)a;\n        auto b_ = cast(int)b;\n \
    \       auto a_ones = count_ones(a_);\n        auto b_ones = count_ones(b_);\n\
    \        if (a_ones == b_ones)\n            return a_ < b_;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg05qgwop.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg05qgwop.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort!((a, b) => a.countOnes() == b.countOnes()\
    \ ? a < b : a.countOnes() < b.countOnes())(arr2);\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7iga8hbn.d(21): Error: template instance `sort!((a, b) => a.countOnes()\
    \ == b.countOnes() ? a < b : a.countOnes() < b.countOnes())` template `sort` is\
    \ not defined, did you mean sqrt?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp7iga8hbn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto result = arr.dup;\n    result.sort!((a, b) =>\n    {\n  \
    \      auto a_ones = countOnes(a);\n        auto b_ones = countOnes(b);\n    \
    \    if (a_ones == b_ones)\n            return a < b;\n        return a_ones <\
    \ b_ones;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L,\
    \ 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L,\
    \ -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L, 4L, 5L,\
    \ 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n\
    \    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n\
    \    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n  \
    \  assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid\
    \ main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp313m_3mh.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp313m_3mh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count('1');\n        auto b1 = b.to!string.count('1');\n\
    \        return a1 == b1 ? a - b : a1 - b1;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfc6sugon.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfc6sugon.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_ = arr.dup;\n    arr_.sort!(a, b => a.countOnes > b.countOnes\
    \ || (a.countOnes == b.countOnes && a > b));\n    return arr_;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph084192k.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph084192k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa__axx9f.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa__axx9f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => {\n        int aOnes = countOnes(a);\n\
    \        int bOnes = countOnes(b);\n        return aOnes == bOnes ? a.compare(b)\
    \ : aOnes.compare(bOnes);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1lcngz77.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1lcngz77.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9k_rf_76.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9k_rf_76.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a1 = a.to!string.count(\"1\");\n        auto b1 = b.to!string.count(\"\
    1\");\n        return a1 == b1 ? a < b : a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfbryygot.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbryygot.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort(sorted, (a, b) =>\n    {\n\
    \        int aOnes = countOnes(a);\n        int bOnes = countOnes(b);\n      \
    \  if (aOnes == bOnes)\n            return a - b;\n        return aOnes - bOnes;\n\
    \    });\n    return sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0fplaxul.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0fplaxul.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        auto a_ones = a.countOnes;\n\
    \        auto b_ones = b.countOnes;\n        return a_ones == b_ones ? a - b :\
    \ a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpae4y_gvu.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpae4y_gvu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] ret = arr.dup;\n    ret.sort!((a, b) =>\n    {\n      \
    \  int a1 = a.countOnes;\n        int b1 = b.countOnes;\n        return a1 ==\
    \ b1 ? a - b : a1 - b1;\n    });\n    return ret;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphdczmj3d.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphdczmj3d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int aCount = a.countOnes();\n\
    \        int bCount = b.countOnes();\n        return aCount == bCount ? a - b\
    \ : aCount - bCount;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprjij_t6v.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprjij_t6v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) {\n        auto a1\
    \ = a.countOnes;\n        auto b1 = b.countOnes;\n        if (a1 == b1)\n    \
    \        return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n}\n\
    unittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L,\
    \ 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L,\
    \ -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L,\
    \ 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprmfb3h6b.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprmfb3h6b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) =>\n    {\n        int a_ones = a.countOnes();\n\
    \        int b_ones = b.countOnes();\n        return a_ones == b_ones ? a - b\
    \ : a_ones - b_ones;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbbnvl18j.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbbnvl18j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv8_twvsp.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpv8_twvsp.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpv8_twvsp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        return aOnes == bOnes ? a.compare(b)\
    \ : aOnes.compare(bOnes);\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvn8_sry0.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvn8_sry0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        if (a_ones == b_ones)\n            return a < b;\n        return a_ones\
    \ < b_ones;\n    });\n    return arr_sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmfaf541k.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfaf541k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    sort(arr2, (a, b) =>\n    {\n      \
    \  auto aa = a.to!string.count('1');\n        auto bb = b.to!string.count('1');\n\
    \        return aa == bb ? a - b : aa - bb;\n    });\n    return arr2;\n}\nunittest\n\
    {\n    alias candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L,\
    \ 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L])\
    \ == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) ==\
    \ [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L,\
    \ 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L,\
    \ 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L,\
    \ 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L,\
    \ 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbdqohh6q.d(21): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbdqohh6q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3q4b904t.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3q4b904t.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto aa = a.to!string;\n        auto bb = b.to!string;\n        auto a1 =\
    \ aa.count('1');\n        auto b1 = bb.count('1');\n        if (a1 == b1)\n  \
    \          return a < b;\n        return a1 < b1;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkgsvusev.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkgsvusev.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) =>\n    {\n      \
    \  auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if\
    \ (a_ones == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n\
    \    });\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprbdj4nx1.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprbdj4nx1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((long a, long b) =>\n\
    \    {\n        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n \
    \       if (aOnes == bOnes)\n            return a < b;\n        return aOnes <\
    \ bOnes;\n    });\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpthlicyna.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpthlicyna.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] sorted = arr.dup;\n    sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b))(sorted);\n    return sorted;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp48l7bxzr.d(21): Error: template instance `sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b))` template `sort` is not defined, did you mean sqrt?\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp48l7bxzr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    return arr.sort!((a, b) => \n    {\n        int aOnes = a.countOnes();\n\
    \        int bOnes = b.countOnes();\n        return aOnes == bOnes ? a - b : aOnes\
    \ - bOnes;\n    });\n}\nunittest\n{\n    alias candidate = sort_array;\n\n   \
    \ assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb6xvahl8.d(20): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb6xvahl8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpykzn_uqz.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpykzn_uqz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] ret = arr.dup;\n    ret.sort!((a, b) =>\n    {\n      \
    \  int a_ones = a.countOnes;\n        int b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a.compare(b);\n        return a_ones.compare(b_ones);\n\
    \    });\n    return ret;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp03m5_1h3.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp03m5_1h3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto s = arr.dup;\n    s.sort!((a, b) =>\n    {\n        auto\
    \ a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n        if (a_ones\
    \ == b_ones)\n            return a < b;\n        return a_ones < b_ones;\n   \
    \ });\n    return s;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n  \
    \  assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyn5heqm2.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyn5heqm2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    long[] result = arr.dup;\n    result.sort!((a, b) =>\n    {\n\
    \        int aOnes = a.countOnes;\n        int bOnes = b.countOnes;\n        if\
    \ (aOnes == bOnes)\n            return a.compare(b);\n        return aOnes.compare(bOnes);\n\
    \    });\n    return result;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpld4kk13d.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpld4kk13d.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.count_ones;\n        auto b_ones = b.count_ones;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbasgjeu.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmbasgjeu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => \n    {\n     \
    \   auto a1 = a.to!string;\n        auto b1 = b.to!string;\n        auto a2 =\
    \ a1.count('1');\n        auto b2 = b1.count('1');\n        if (a2 == b2)\n  \
    \          return a < b;\n        return a2 < b2;\n    });\n    return arr2;\n\
    }\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0nl8exs1.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0nl8exs1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0rt8ra7e.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rt8ra7e.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    auto arr3 = arr.dup;\n    auto arr4\
    \ = arr.dup;\n    auto arr5 = arr.dup;\n    auto arr6 = arr.dup;\n    auto arr7\
    \ = arr.dup;\n    auto arr8 = arr.dup;\n    auto arr9 = arr.dup;\n    auto arr10\
    \ = arr.dup;\n    auto arr11 = arr.dup;\n    auto arr12 = arr.dup;\n    auto arr13\
    \ = arr.dup;\n    auto arr14 = arr.dup;\n    auto arr15 = arr.dup;\n    auto arr16\
    \ = arr.dup;\n    auto arr17 = arr.dup;\n    auto arr18 = arr.dup;\n    auto arr19\
    \ = arr.dup;\n    auto arr20 = arr.dup;\n    auto arr21 = arr.dup;\n    auto arr22\
    \ = arr.dup;\n    auto arr23 = arr.dup;\n    auto arr24 = arr.dup;\n    auto arr25\
    \ = arr.dup;\n    auto arr26 = arr.dup;\n    auto arr27 = arr.dup;\n    auto arr28\
    \ = arr.dup;\n    auto arr29 = arr.dup;\n    auto arr30 = arr.dup;\n    auto arr31\
    \ = arr.dup;\n    auto arr32 = arr.dup;\n    auto arr33 = arr.dup;\n    auto arr34\
    \ = arr.dup;\n    auto arr35 = arr.dup;\n    auto arr36 = arr.dup;\n    auto arr37\
    \ = arr.dup;\n    auto arr38 = arr.dup;\n    auto arr39 = arr.dup;\n    auto arr40\
    \ = arr.dup;\n    auto arr41 = arr.dup;\n    auto arr42 = arr.dup;\n    auto arr43\
    \ = arr.dup;\n    auto arr44 = arr.dup;\n    auto arr45 = arr.dup;\n    auto arr46\
    \ = arr.dup;\n    auto arr47 = arr.dup;\n    auto arr\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqb6k4y8k.d(67): Error: no identifier for declarator `arr`\\n/tmp/tmpqb6k4y8k.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpqb6k4y8k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) {\n        auto aBin\
    \ = a.to!string(2);\n        auto bBin = b.to!string(2);\n        if (aBin.count('1')\
    \ == bBin.count('1'))\n            return a < b;\n        return aBin.count('1')\
    \ < bBin.count('1');\n    });\n    return arr2;\n}\nunittest\n{\n    alias candidate\
    \ = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L,\
    \ 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L,\
    \ -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L, 77L,\
    \ 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L,\
    \ 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L, 6L,\
    \ 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwlaj0c_w.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwlaj0c_w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr2 = arr.dup;\n    arr2.sort!((a, b) => a.countOnes.cmp(b.countOnes)\
    \ || a.cmp(b));\n    return arr2;\n}\nunittest\n{\n    alias candidate = sort_array;\n\
    \n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L,\
    \ -3L, -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L,\
    \ 0L, 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmperztl620.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmperztl620.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) => (a.countOnes,\
    \ a).cmp((b.countOnes, b)));\n    return arr_sorted;\n}\nunittest\n{\n    alias\
    \ candidate = sort_array;\n\n    assert(candidate([1L, 5L, 2L, 3L, 4L]) == [1L,\
    \ 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L, -4L, -5L, -6L]) == [-4L,\
    \ -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L, 2L, 3L, 4L]) == [0L, 1L,\
    \ 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n    assert(candidate([2L, 5L,\
    \ 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L, 4L, 4L, 3L, 3L, 5L, 5L, 5L,\
    \ 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L, 32L, 5L]) == [32L, 3L, 5L,\
    \ 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L,\
    \ 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L, 32L]) == [2L, 4L, 8L, 16L,\
    \ 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa67gip4f.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpa67gip4f.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    In this Kata, you have\
    \ to sort an array of non-negative integers according to\n    number of ones in\
    \ their binary representation in ascending order.\n    For similar number of ones,\
    \ sort based on decimal value.\n\n    It must be implemented like this:\n    >>>\
    \ sort_array([1L, 5L, 2L, 3L, 4L])\n    [1L, 2L, 3L, 4L, 5L]\n    >>> sort_array([-2L,\
    \ -3L, -4L, -5L, -6L])\n    [-6L, -5L, -4L, -3L, -2L]\n    >>> sort_array([1L,\
    \ 0L, 2L, 3L, 4L])\n    [0L, 1L, 2L, 3L, 4L]\n    \n*/\nlong[] sort_array(long[]\
    \ arr) \n{\n    auto arr_sorted = arr.dup;\n    arr_sorted.sort!((a, b) =>\n \
    \   {\n        auto a_ones = a.countOnes;\n        auto b_ones = b.countOnes;\n\
    \        return a_ones == b_ones ? a - b : a_ones - b_ones;\n    });\n    return\
    \ arr_sorted;\n}\nunittest\n{\n    alias candidate = sort_array;\n\n    assert(candidate([1L,\
    \ 5L, 2L, 3L, 4L]) == [1L, 2L, 4L, 3L, 5L]);\n    assert(candidate([-2L, -3L,\
    \ -4L, -5L, -6L]) == [-4L, -2L, -6L, -5L, -3L]);\n    assert(candidate([1L, 0L,\
    \ 2L, 3L, 4L]) == [0L, 1L, 2L, 4L, 3L]);\n    assert(candidate([]) == []);\n \
    \   assert(candidate([2L, 5L, 77L, 4L, 5L, 3L, 5L, 7L, 2L, 3L, 4L]) == [2L, 2L,\
    \ 4L, 4L, 3L, 3L, 5L, 5L, 5L, 7L, 77L]);\n    assert(candidate([3L, 6L, 44L, 12L,\
    \ 32L, 5L]) == [32L, 3L, 5L, 6L, 12L, 44L]);\n    assert(candidate([2L, 4L, 8L,\
    \ 16L, 32L]) == [2L, 4L, 8L, 16L, 32L]);\n    assert(candidate([2L, 4L, 8L, 16L,\
    \ 32L]) == [2L, 4L, 8L, 16L, 32L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpexopp4rr.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpexopp4rr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
