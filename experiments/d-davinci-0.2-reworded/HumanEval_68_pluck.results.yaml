name: HumanEval_68_pluck
language: d
results:
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpnzllwaze.__unittest_L59_C1()\
    \ [0x4280b9]\\n??:? void tmpnzllwaze.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0x9d6b5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long minEven = long.max;\n    long minEvenIndex = long.max;\n\
    \    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < minEven)\n      \
    \  {\n            minEven = v;\n            minEvenIndex = i;\n        }\n   \
    \ }\n    if(minEven == long.max)\n    {\n        return [];\n    }\n    return\
    \ [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min == arr[0])\n        return result;\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsyadkefz.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42876d]\\n??:? void tmpsyadkefz.__unittest_L58_C1()\
    \ [0x4280dd]\\n??:? void tmpsyadkefz.__modtest() [0x4284f0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c827]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b6ba]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430945]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430df4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b691]\\n??:? runModuleUnitTests [0x42c5fd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c30]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428bb7]\\n??:? _d_run_main [0x428b22]\\n??:? main [0x428503]\\\
    n??:? __libc_start_main [0xe38ea554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long smallest = 0;\n    long\
    \ index = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n   \
    \         {\n                smallest = arr[i];\n                index = i;\n\
    \                found = true;\n            }\n            else\n            {\n\
    \                if (arr[i] < smallest)\n                {\n                 \
    \   smallest = arr[i];\n                    index = i;\n                }\n  \
    \          }\n        }\n    }\n    if (found)\n    {\n        result[0] = smallest;\n\
    \        result[1] = index;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt7tuwxdy.d(76): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpt7tuwxdy.__unittest_L70_C1()\
    \ [0x42811e]\\n??:? void tmpt7tuwxdy.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x7fc74554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg_qasmvj.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpg_qasmvj.__unittest_L58_C1()\
    \ [0x4280bd]\\n??:? void tmpg_qasmvj.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0xf19c1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    int index\
    \ = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n  \
    \      {\n            min = v;\n            index = i;\n        }\n    }\n   \
    \ if(index == -1)\n        return res;\n    res[0] = min;\n    res[1] = index;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuzi07xbe.d(47): Error: cannot implicitly convert expression `i`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpuzi07xbe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 10001;\n    long index = -1;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (index == -1)\n    {\n        return new long[0];\n    }\n    return new\
    \ long[] { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ns1e7v6.d(53): Error: found `{` when expecting `;` following\
    \ `return` statement\\n/tmp/tmp_ns1e7v6.d(53): Error: found `}` when expecting\
    \ `;` following statement\\n/tmp/tmp_ns1e7v6.d(53): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_ns1e7v6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    int index = -1;\n    long min\
    \ = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] %\
    \ 2 == 0)\n        {\n            if (index == -1)\n            {\n          \
    \      index = i;\n                min = arr[i];\n            }\n            else\
    \ if (arr[i] < min)\n            {\n                index = i;\n             \
    \   min = arr[i];\n            }\n        }\n    }\n    if (index != -1)\n   \
    \ {\n        result[0] = min;\n        result[1] = index;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxxmznc9n.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpxxmznc9n.__unittest_L65_C1()\
    \ [0x42811a]\\n??:? void tmpxxmznc9n.__modtest() [0x4284cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284df]\\\
    n??:? __libc_start_main [0x415ad554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long minIndex = -1;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (minIndex == -1)\n    {\n        return new long[0];\n    }\n \
    \   return new long[] { min, minIndex };\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvjt92c4x.d(53): Error: found `{` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpvjt92c4x.d(53): Error: found `}` when expecting\
    \ `;` following statement\\n/tmp/tmpvjt92c4x.d(53): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpvjt92c4x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfh3raqek.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpfh3raqek.__unittest_L58_C1()\
    \ [0x4280bd]\\n??:? void tmpfh3raqek.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x4c637554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    bool found = false;\n    foreach(long i, long val; arr)\n  \
    \  {\n        if(val % 2 == 0 && val < min)\n        {\n            min = val;\n\
    \            index = i;\n            found = true;\n        }\n    }\n    if(found)\n\
    \    {\n        result[0] = min;\n        result[1] = index;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_qx6qf6e.d(65): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmp_qx6qf6e.__unittest_L59_C1()\
    \ [0x42809a]\\n??:? void tmp_qx6qf6e.__modtest() [0x42844c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c787]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308a5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430831]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f1]\\n??:? runModuleUnitTests [0x42c55d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x42845f]\\\
    n??:? __libc_start_main [0xf22b7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == 10001)\n    {\n        return\
    \ new long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index != -1)\n    {\n        res[0] = min;\n        res[1] = index;\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjypae5n9.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286cd]\\n??:? void tmpjypae5n9.__unittest_L57_C1()\
    \ [0x42809e]\\n??:? void tmpjypae5n9.__modtest() [0x428450]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c787]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b61a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308a5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430831]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b5f1]\\n??:? runModuleUnitTests [0x42c55d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b90]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b17]\\n??:? _d_run_main [0x428a82]\\n??:? main [0x428463]\\\
    n??:? __libc_start_main [0x890cd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1nxoso91.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4286e5]\\n??:? void tmp1nxoso91.__unittest_L58_C1()\
    \ [0x4280b2]\\n??:? void tmp1nxoso91.__modtest() [0x428464]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c79f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b632]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4308bd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430849]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b609]\\n??:? runModuleUnitTests [0x42c575]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ba8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b2f]\\n??:? _d_run_main [0x428a9a]\\n??:? main [0x428477]\\\
    n??:? __libc_start_main [0x6c069554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (long i =\
    \ 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1)\n        return new long[0];\n    return new long[]\
    \ { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpha6tvui0.d(51): Error: found `{` when expecting `;` following\
    \ `return` statement\\n/tmp/tmpha6tvui0.d(51): Error: found `}` when expecting\
    \ `;` following statement\\n/tmp/tmpha6tvui0.d(51): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpha6tvui0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxzrnrava.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpxzrnrava.__unittest_L59_C1()\
    \ [0x4280bd]\\n??:? void tmpxzrnrava.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x83867554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp4xwjzjp.d(64): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42874d]\\n??:? void tmpp4xwjzjp.__unittest_L59_C1()\
    \ [0x4280bd]\\n??:? void tmpp4xwjzjp.__modtest() [0x4284d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c807]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b69a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430925]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b671]\\n??:? runModuleUnitTests [0x42c5dd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428c10]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428b97]\\n??:? _d_run_main [0x428b02]\\n??:? main [0x4284e3]\\\
    n??:? __libc_start_main [0x688f0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
