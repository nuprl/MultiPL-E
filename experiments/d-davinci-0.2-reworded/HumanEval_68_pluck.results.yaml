language: d
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long minEven = long.max;\n    long minEvenIndex = long.max;\n\
    \    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < minEven)\n      \
    \  {\n            minEven = v;\n            minEvenIndex = i;\n        }\n   \
    \ }\n    if(minEven == long.max)\n    {\n        return [];\n    }\n    return\
    \ [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min == arr[0])\n        return result;\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpsyadkefz.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42876d]\n??:? void tmpsyadkefz.__unittest_L58_C1() [0x4280dd]\n??:?
    void tmpsyadkefz.__modtest() [0x4284f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c827]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430945]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430df4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308d1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b691]\n??:? runModuleUnitTests [0x42c5fd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c30]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428bb7]\n??:? _d_run_main [0x428b22]\n??:? main [0x428503]\n??:?
    __libc_start_main [0xe38ea554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long smallest = 0;\n    long\
    \ index = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n   \
    \         {\n                smallest = arr[i];\n                index = i;\n\
    \                found = true;\n            }\n            else\n            {\n\
    \                if (arr[i] < smallest)\n                {\n                 \
    \   smallest = arr[i];\n                    index = i;\n                }\n  \
    \          }\n        }\n    }\n    if (found)\n    {\n        result[0] = smallest;\n\
    \        result[1] = index;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpt7tuwxdy.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpt7tuwxdy.__unittest_L70_C1() [0x42811e]\n??:?
    void tmpt7tuwxdy.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x7fc74554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpg_qasmvj.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpg_qasmvj.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmpg_qasmvj.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xf19c1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    int index\
    \ = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n  \
    \      {\n            min = v;\n            index = i;\n        }\n    }\n   \
    \ if(index == -1)\n        return res;\n    res[0] = min;\n    res[1] = index;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuzi07xbe.d(47): Error: cannot implicitly convert expression
    `i` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuzi07xbe.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 10001;\n    long index = -1;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (index == -1)\n    {\n        return new long[0];\n    }\n    return new\
    \ long[] { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ns1e7v6.d(53): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp_ns1e7v6.d(53): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp_ns1e7v6.d(53): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ns1e7v6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    int index = -1;\n    long min\
    \ = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] %\
    \ 2 == 0)\n        {\n            if (index == -1)\n            {\n          \
    \      index = i;\n                min = arr[i];\n            }\n            else\
    \ if (arr[i] < min)\n            {\n                index = i;\n             \
    \   min = arr[i];\n            }\n        }\n    }\n    if (index != -1)\n   \
    \ {\n        result[0] = min;\n        result[1] = index;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpxxmznc9n.d(71): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpxxmznc9n.__unittest_L65_C1() [0x42811a]\n??:?
    void tmpxxmznc9n.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x415ad554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long minIndex = -1;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (minIndex == -1)\n    {\n        return new long[0];\n    }\n \
    \   return new long[] { min, minIndex };\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvjt92c4x.d(53): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpvjt92c4x.d(53): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpvjt92c4x.d(53): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvjt92c4x.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfh3raqek.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpfh3raqek.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmpfh3raqek.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x4c637554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    bool found = false;\n    foreach(long i, long val; arr)\n  \
    \  {\n        if(val % 2 == 0 && val < min)\n        {\n            min = val;\n\
    \            index = i;\n            found = true;\n        }\n    }\n    if(found)\n\
    \    {\n        result[0] = min;\n        result[1] = index;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_qx6qf6e.d(65): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286cd]\n??:? void tmp_qx6qf6e.__unittest_L59_C1() [0x42809a]\n??:?
    void tmp_qx6qf6e.__modtest() [0x42844c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b90]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b17]\n??:? _d_run_main [0x428a82]\n??:? main [0x42845f]\n??:?
    __libc_start_main [0xf22b7554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == 10001)\n    {\n        return\
    \ new long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index != -1)\n    {\n        res[0] = min;\n        res[1] = index;\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjypae5n9.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286cd]\n??:? void tmpjypae5n9.__unittest_L57_C1() [0x42809e]\n??:?
    void tmpjypae5n9.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b90]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b17]\n??:? _d_run_main [0x428a82]\n??:? main [0x428463]\n??:?
    __libc_start_main [0x890cd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1nxoso91.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmp1nxoso91.__unittest_L58_C1() [0x4280b2]\n??:?
    void tmp1nxoso91.__modtest() [0x428464]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x428477]\n??:?
    __libc_start_main [0x6c069554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (long i =\
    \ 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1)\n        return new long[0];\n    return new long[]\
    \ { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpha6tvui0.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpha6tvui0.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpha6tvui0.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpha6tvui0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpxzrnrava.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpxzrnrava.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpxzrnrava.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x83867554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpp4xwjzjp.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpp4xwjzjp.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpp4xwjzjp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x688f0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return [];\n    }\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    int minIndex = 0;\n    for (int i = 0;\
    \ i < arr.length; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min) {\n   \
    \         min = arr[i];\n            minIndex = i;\n        }\n    }\n    if (min\
    \ % 2 == 0) {\n        result[0] = min;\n        result[1] = minIndex;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpffssdcmy.d(60): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpffssdcmy.__unittest_L55_C1() [0x4280b9]\n??:?
    void tmpffssdcmy.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x5c477554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    foreach(i, v;\
    \ arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min =\
    \ v;\n            index = i;\n        }\n    }\n    if(index == -1)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return [];\n    }\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0) return new long[0];\n    long min = arr[0];\n\
    \    long min_index = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n\
    \            {\n                min = arr[i];\n                min_index = i;\n\
    \                found = true;\n            }\n            else\n            {\n\
    \                if (arr[i] < min)\n                {\n                    min\
    \ = arr[i];\n                    min_index = i;\n                }\n         \
    \   }\n        }\n    }\n    if (found)\n    {\n        return new long[] { min,\
    \ min_index };\n    }\n    else\n    {\n        return new long[0];\n    }\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp9rin5ekd.d(65): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp9rin5ekd.d(65): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp9rin5ekd.d(65): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9rin5ekd.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    return min == long.max ? new long[0] : new long[] { min, index };\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmoeq3bcs.d(49): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpmoeq3bcs.d(49): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpmoeq3bcs.d(49): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpmoeq3bcs.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = arr[0];\n    long\
    \ index = 0;\n    bool found = false;\n    for (long i = 0; i < arr.length; i++)\
    \ \n    {\n        if (arr[i] % 2 == 0) \n        {\n            if (arr[i] <\
    \ min) \n            {\n                min = arr[i];\n                index =\
    \ i;\n                found = true;\n            }\n        }\n    }\n    if (found)\
    \ \n    {\n        result[0] = min;\n        result[1] = index;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpyveaa5mz.d(67): unittest failure\n----------------\n??:?
    _d_unittestp [0x428735]\n??:? void tmpyveaa5mz.__unittest_L62_C1() [0x4280a1]\n??:?
    void tmpyveaa5mz.__modtest() [0x4284b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b682]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43090d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dbc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430899]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b659]\n??:? runModuleUnitTests [0x42c5c5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b7f]\n??:? _d_run_main [0x428aea]\n??:? main [0x4284c7]\n??:?
    __libc_start_main [0x1bdbd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return [];\n    }\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long index\
    \ = 0;\n    long count = 0;\n    foreach(long i; arr)\n    {\n        if(i % 2\
    \ == 0)\n        {\n            if(count == 0)\n            {\n              \
    \  min = i;\n                index = count;\n            }\n            else\n\
    \            {\n                if(i < min)\n                {\n             \
    \       min = i;\n                    index = count;\n                }\n    \
    \        }\n        }\n        count++;\n    }\n    if(min == 0)\n    {\n    \
    \    return result;\n    }\n    result[0] = min;\n    result[1] = index;\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpy8ody8yb.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286ed]\n??:? void tmpy8ody8yb.__unittest_L71_C1() [0x42805d]\n??:?
    void tmpy8ody8yb.__modtest() [0x428470]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430851]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b611]\n??:? runModuleUnitTests [0x42c57d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bb0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b37]\n??:? _d_run_main [0x428aa2]\n??:? main [0x428483]\n??:?
    __libc_start_main [0xb0090554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return result;\n\
    \    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpvlmf1mpw.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmpvlmf1mpw.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmpvlmf1mpw.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xd0cb0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    result[0] = -1;\n    result[1]\
    \ = -1;\n    if (arr.length == 0)\n        return result;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n        {\n     \
    \       if (result[0] == -1)\n            {\n                result[0] = arr[i];\n\
    \                result[1] = i;\n            }\n            else if (arr[i] <\
    \ result[0])\n            {\n                result[0] = arr[i];\n           \
    \     result[1] = i;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpm6pivmgf.d(68): unittest failure\n----------------\n??:?
    _d_unittestp [0x42881d]\n??:? void tmpm6pivmgf.__unittest_L62_C1() [0x4281ee]\n??:?
    void tmpm6pivmgf.__modtest() [0x4285a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c8d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b76a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4309f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ea4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430981]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b741]\n??:? runModuleUnitTests [0x42c6ad]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ce0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428c67]\n??:? _d_run_main [0x428bd2]\n??:? main [0x4285b3]\n??:?
    __libc_start_main [0x9ee6c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = -1;\n    long index\
    \ = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0)\n        {\n  \
    \          if(min == -1)\n            {\n                min = v;\n          \
    \      index = i;\n            }\n            else if(v < min)\n            {\n\
    \                min = v;\n                index = i;\n            }\n       \
    \ }\n    }\n    if(min != -1)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp9_kfkno0.d(71): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286dd]\n??:? void tmp9_kfkno0.__unittest_L65_C1() [0x4280ae]\n??:?
    void tmp9_kfkno0.__modtest() [0x428460]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c797]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b62a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d64]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430841]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b601]\n??:? runModuleUnitTests [0x42c56d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b27]\n??:? _d_run_main [0x428a92]\n??:? main [0x428473]\n??:?
    __libc_start_main [0x85ca1554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long minEven = 10001;\n    long minIndex = 0;\n    for\
    \ (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < minEven)\n        {\n            minEven = arr[i];\n            minIndex =\
    \ i;\n        }\n    }\n    if (minEven == 10001)\n        return result;\n  \
    \  result[0] = minEven;\n    result[1] = minIndex;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpy0z1tktx.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428735]\n??:? void tmpy0z1tktx.__unittest_L58_C1() [0x428102]\n??:?
    void tmpy0z1tktx.__modtest() [0x4284b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b682]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43090d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dbc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430899]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b659]\n??:? runModuleUnitTests [0x42c5c5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b7f]\n??:? _d_run_main [0x428aea]\n??:? main [0x4284c7]\n??:?
    __libc_start_main [0xa6e2c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0) return new long[0];\n    long min = arr[0];\n\
    \    long index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n      \
    \  if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n\
    \            index = i;\n        }\n    }\n    if (min % 2 != 0) return new long[0];\n\
    \    return new long[] { min, index };\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpucec8gg_.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpucec8gg_.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpucec8gg_.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpucec8gg_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index != -1)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpjwg8lo6z.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286cd]\n??:? void tmpjwg8lo6z.__unittest_L57_C1() [0x42809e]\n??:?
    void tmpjwg8lo6z.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b90]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b17]\n??:? _d_run_main [0x428a82]\n??:? main [0x428463]\n??:?
    __libc_start_main [0x92d30554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index == -1)\n        return [];\n    result[0] = min;\n    result[1] =\
    \ index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp11eeelgh.d(62): unittest failure\n----------------\n??:?
    _d_unittestp [0x42873d]\n??:? void tmp11eeelgh.__unittest_L57_C1() [0x4280a9]\n??:?
    void tmp11eeelgh.__modtest() [0x4284bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b68a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430915]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b661]\n??:? runModuleUnitTests [0x42c5cd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b87]\n??:? _d_run_main [0x428af2]\n??:? main [0x4284cf]\n??:?
    __libc_start_main [0x75b16554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = -1;\n    long index\
    \ = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0)\n        {\n  \
    \          if(min == -1)\n            {\n                min = v;\n          \
    \      index = i;\n            }\n            else if(v < min)\n            {\n\
    \                min = v;\n                index = i;\n            }\n       \
    \ }\n    }\n    if(min == -1)\n    {\n        return result;\n    }\n    result[0]\
    \ = min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpt1vingz0.d(72): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286ed]\n??:? void tmpt1vingz0.__unittest_L66_C1() [0x4280be]\n??:?
    void tmpt1vingz0.__modtest() [0x428470]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430851]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b611]\n??:? runModuleUnitTests [0x42c57d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bb0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b37]\n??:? _d_run_main [0x428aa2]\n??:? main [0x428483]\n??:?
    __libc_start_main [0x73583554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    int index = 0;\n    for (int i = 0; i <\
    \ arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n    \
    \    {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpof8_vrko.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpof8_vrko.__unittest_L58_C1() [0x4280b9]\n??:?
    void tmpof8_vrko.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0xdab2a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = arr[0];\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprcr9hzcg.d(62): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286ed]\n??:? void tmprcr9hzcg.__unittest_L57_C1() [0x428059]\n??:?
    void tmprcr9hzcg.__modtest() [0x42846c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430851]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b611]\n??:? runModuleUnitTests [0x42c57d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bb0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b37]\n??:? _d_run_main [0x428aa2]\n??:? main [0x42847f]\n??:?
    __libc_start_main [0x5d36f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp11eeelgh.d(62): unittest failure\n----------------\n??:?
    _d_unittestp [0x42873d]\n??:? void tmp11eeelgh.__unittest_L57_C1() [0x4280a9]\n??:?
    void tmp11eeelgh.__modtest() [0x4284bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b68a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430915]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b661]\n??:? runModuleUnitTests [0x42c5cd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b87]\n??:? _d_run_main [0x428af2]\n??:? main [0x4284cf]\n??:?
    __libc_start_main [0x75b16554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] < min && arr[i] % 2 ==\
    \ 0)\n        {\n            min = arr[i];\n            index = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1897nmps.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp1897nmps.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmp1897nmps.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0xaddb3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            result[0] = min;\n            result[1] = i;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpihcrtz3w.d(59): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmpihcrtz3w.__unittest_L54_C1() [0x428099]\n??:?
    void tmpihcrtz3w.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430db4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430891]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b651]\n??:? runModuleUnitTests [0x42c5bd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0xd9060554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1nxoso91.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmp1nxoso91.__unittest_L58_C1() [0x4280b2]\n??:?
    void tmp1nxoso91.__modtest() [0x428464]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x428477]\n??:?
    __libc_start_main [0x6c069554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long index\
    \ = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n  \
    \  {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n     \
    \       {\n                min = arr[i];\n                index = i;\n       \
    \         found = true;\n            }\n            else\n            {\n    \
    \            if (arr[i] < min)\n                {\n                    min = arr[i];\n\
    \                    index = i;\n                }\n            }\n        }\n\
    \    }\n    if (found)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplw7lg7yy.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplw7lg7yy.__unittest_L70_C1() [0x42811e]\n??:?
    void tmplw7lg7yy.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x38ffa554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = INT_MAX;\n    long\
    \ index = 0;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(min == INT_MAX)\n        return [];\n    result[0] = min;\n    result[1]\
    \ = index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpv9gxw1wv.d(40): Error: undefined identifier `INT_MAX`\n/tmp/tmpv9gxw1wv.d(50):
    Error: undefined identifier `INT_MAX`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpv9gxw1wv.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    long min\
    \ = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            index = i;\n        }\n    }\n    if (min % 2 == 0)\n\
    \        return new long[] { min, index };\n    return new long[0];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu9n8u_oo.d(52): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpu9n8u_oo.d(52): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpu9n8u_oo.d(52): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9n8u_oo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long smallest = arr[0];\n    long index = 0;\n    for\
    \ (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < smallest)\n        {\n            smallest = arr[i];\n            index =\
    \ i;\n        }\n    }\n    if (smallest % 2 == 0)\n    {\n        result[0] =\
    \ smallest;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp0tmcvwt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp0tmcvwt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmp0tmcvwt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x2b0b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplxun4lrm.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplxun4lrm.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmplxun4lrm.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x1e18554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqami092v.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpqami092v.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpqami092v.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xc037f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == long.max)\n    {\n        return\
    \ result;\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpm21bs6hb.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmpm21bs6hb.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmpm21bs6hb.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xef062554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            result[0] = min;\n            result[1] = i;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpihcrtz3w.d(59): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmpihcrtz3w.__unittest_L54_C1() [0x428099]\n??:?
    void tmpihcrtz3w.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430db4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430891]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b651]\n??:? runModuleUnitTests [0x42c5bd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0xd9060554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (long i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6imb0zmd.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp6imb0zmd.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp6imb0zmd.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x7c96e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplxun4lrm.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplxun4lrm.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmplxun4lrm.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x1e18554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long minEven = long.max;\n    long minEvenIndex = long.max;\n\
    \    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < minEven)\n      \
    \  {\n            minEven = v;\n            minEvenIndex = i;\n        }\n   \
    \ }\n    if(minEven == long.max)\n    {\n        return [];\n    }\n    return\
    \ [minEven, minEvenIndex];\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    foreach(i, v;\
    \ arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min =\
    \ v;\n            index = i;\n        }\n    }\n    if(index == -1)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ minIndex = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (minIndex != -1)\n    {\n \
    \       result[0] = min;\n        result[1] = minIndex;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnqokk26x.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x428715]\n??:? void tmpnqokk26x.__unittest_L57_C1() [0x4280e6]\n??:?
    void tmpnqokk26x.__modtest() [0x428498]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d9c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430879]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b5f]\n??:? _d_run_main [0x428aca]\n??:? main [0x4284ab]\n??:?
    __libc_start_main [0xe1645554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    result[0] = -1;\n    result[1]\
    \ = -1;\n    if (arr.length == 0)\n        return result;\n    foreach (i, e;\
    \ arr)\n    {\n        if (e % 2 == 0)\n        {\n            if (result[0] ==\
    \ -1 || e < result[0])\n            {\n                result[0] = e;\n      \
    \          result[1] = i;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3_fv_7oh.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp3_fv_7oh.__unittest_L57_C1() [0x42811a]\n??:?
    void tmp3_fv_7oh.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0xa29e7554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 999999999;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min != 999999999)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp9ijko44g.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x428715]\n??:? void tmp9ijko44g.__unittest_L57_C1() [0x4280e2]\n??:?
    void tmp9ijko44g.__modtest() [0x428494]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d9c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430879]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b5f]\n??:? _d_run_main [0x428aca]\n??:? main [0x4284a7]\n??:?
    __libc_start_main [0x8fd07554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long minIndex\
    \ = 0;\n    bool found = false;\n    for (long i = 0; i < arr.length; i++)\n \
    \   {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n    \
    \        {\n                min = arr[i];\n                minIndex = i;\n   \
    \             found = true;\n            }\n            else\n            {\n\
    \                if (arr[i] < min)\n                {\n                    min\
    \ = arr[i];\n                    minIndex = i;\n                }\n          \
    \  }\n        }\n    }\n    if (found)\n    {\n        result[0] = min;\n    \
    \    result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpu5ishjpk.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpu5ishjpk.__unittest_L70_C1() [0x42811e]\n??:?
    void tmpu5ishjpk.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x61116554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_31t44rp.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp_31t44rp.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp_31t44rp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xe07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    int min = int.max;\n    int\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if (v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if (index != -1)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7221hvmc.d(46): Error: cannot implicitly convert expression
    `v` of type `long` to `int`\n/tmp/tmp7221hvmc.d(47): Error: cannot implicitly
    convert expression `i` of type `ulong` to `int`\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp7221hvmc.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (long i =\
    \ 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1)\n        return [];\n    return [min, index];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index != -1)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkldrlhd9.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x428715]\n??:? void tmpkldrlhd9.__unittest_L57_C1() [0x4280e6]\n??:?
    void tmpkldrlhd9.__modtest() [0x428498]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d9c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430879]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b5f]\n??:? _d_run_main [0x428aca]\n??:? main [0x4284ab]\n??:?
    __libc_start_main [0x48bda554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            result[0] = min;\n \
    \           result[1] = i;\n        }\n    }\n    if (min == 10001)\n    {\n \
    \       return new long[0];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    long min\
    \ = arr[0];\n    long minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] < min && arr[i] % 2 == 0)\n        {\n            min\
    \ = arr[i];\n            minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n\
    \        return new long[] { min, minIndex };\n    return new long[0];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpfh8_0zku.d(52): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpfh8_0zku.d(52): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpfh8_0zku.d(52): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfh8_0zku.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    long min\
    \ = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            index = i;\n        }\n    }\n    if (min % 2 == 0)\n\
    \        return new long[] { min, index };\n    return new long[0];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu9n8u_oo.d(52): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpu9n8u_oo.d(52): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpu9n8u_oo.d(52): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9n8u_oo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(long i, long v; arr)\n    {\n        if(v % 2 == 0\
    \ && v < min)\n        {\n            min = v;\n            index = i;\n     \
    \   }\n    }\n    if(index == -1)\n        return res;\n    res[0] = min;\n  \
    \  res[1] = index;\n    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1wf7h5pg.d(62): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286dd]\n??:? void tmp1wf7h5pg.__unittest_L56_C1() [0x4280ae]\n??:?
    void tmp1wf7h5pg.__modtest() [0x428460]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c797]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b62a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d64]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430841]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b601]\n??:? runModuleUnitTests [0x42c56d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b27]\n??:? _d_run_main [0x428a92]\n??:? main [0x428473]\n??:?
    __libc_start_main [0x963bd554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long minIndex\
    \ = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n  \
    \  {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n     \
    \       {\n                min = arr[i];\n                minIndex = i;\n    \
    \            found = true;\n            }\n            else\n            {\n \
    \               if (arr[i] < min)\n                {\n                    min\
    \ = arr[i];\n                    minIndex = i;\n                }\n          \
    \  }\n        }\n    }\n    if (found)\n    {\n        result[0] = min;\n    \
    \    result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpb8865fqr.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpb8865fqr.__unittest_L70_C1() [0x42811e]\n??:?
    void tmpb8865fqr.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xa06ba554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    long count = 0;\n    foreach(long i; arr)\n    {\n        if(i\
    \ % 2 == 0)\n        {\n            if(i < min)\n            {\n             \
    \   min = i;\n                index = count;\n            }\n        }\n     \
    \   count++;\n    }\n    if(min == long.max)\n    {\n        return result;\n\
    \    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpc4c1yel3.d(69): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmpc4c1yel3.__unittest_L63_C1() [0x4280b6]\n??:?
    void tmpc4c1yel3.__modtest() [0x428468]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x42847b]\n??:?
    __libc_start_main [0x7d90b554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long smallest = 0;\n    long\
    \ index = 0;\n    bool found = false;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n   \
    \         {\n                smallest = arr[i];\n                index = i;\n\
    \                found = true;\n            }\n            else\n            {\n\
    \                if (arr[i] < smallest)\n                {\n                 \
    \   smallest = arr[i];\n                    index = i;\n                }\n  \
    \          }\n        }\n    }\n    if (found)\n    {\n        result[0] = smallest;\n\
    \        result[1] = index;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp9n8elt5y.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp9n8elt5y.__unittest_L70_C1() [0x42811e]\n??:?
    void tmp9n8elt5y.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x6959c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfh3raqek.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpfh3raqek.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmpfh3raqek.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x4c637554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    \n    long\
    \ minEven = long.max;\n    long minEvenIndex = -1;\n    for (long i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < minEven)\n        {\n \
    \           minEven = arr[i];\n            minEvenIndex = i;\n        }\n    }\n\
    \    \n    if (minEvenIndex == -1)\n        return new long[0];\n    \n    return\
    \ new long[] { minEven, minEvenIndex };\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpf5g93in7.d(56): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpf5g93in7.d(56): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpf5g93in7.d(56): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf5g93in7.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = int.max;\n    long\
    \ index = 0;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(min == int.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp3s0ano3i.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286d5]\n??:? void tmp3s0ano3i.__unittest_L58_C1() [0x4280a6]\n??:?
    void tmp3s0ano3i.__modtest() [0x428458]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b622]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d5c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430839]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f9]\n??:? runModuleUnitTests [0x42c565]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b98]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b1f]\n??:? _d_run_main [0x428a8a]\n??:? main [0x42846b]\n??:?
    __libc_start_main [0x20b1f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = arr[0];\n    long\
    \ index = 0;\n    bool found = false;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (arr[i] < min)\n\
    \            {\n                min = arr[i];\n                index = i;\n  \
    \              found = true;\n            }\n        }\n    }\n    if (found)\n\
    \    {\n        result[0] = min;\n        result[1] = index;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp9glvujip.d(67): unittest failure\n----------------\n??:?
    _d_unittestp [0x428735]\n??:? void tmp9glvujip.__unittest_L62_C1() [0x4280a1]\n??:?
    void tmp9glvujip.__modtest() [0x4284b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b682]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43090d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dbc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430899]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b659]\n??:? runModuleUnitTests [0x42c5c5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b7f]\n??:? _d_run_main [0x428aea]\n??:? main [0x4284c7]\n??:?
    __libc_start_main [0x34a99554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    long min\
    \ = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            index = i;\n        }\n    }\n    if (min % 2 == 0)\n\
    \        return new long[] { min, index };\n    return new long[0];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpu9n8u_oo.d(52): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpu9n8u_oo.d(52): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpu9n8u_oo.d(52): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu9n8u_oo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] < min && arr[i] % 2 ==\
    \ 0)\n        {\n            min = arr[i];\n            index = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplteupw34.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428745]\n??:? void tmplteupw34.__unittest_L59_C1() [0x4280b5]\n??:?
    void tmplteupw34.__modtest() [0x4284c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b692]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43091d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dcc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308a9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b669]\n??:? runModuleUnitTests [0x42c5d5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c08]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b8f]\n??:? _d_run_main [0x428afa]\n??:? main [0x4284db]\n??:?
    __libc_start_main [0x13228554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n\
    \    long minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n  \
    \      if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp2rkn02db.d(60): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmp2rkn02db.__unittest_L55_C1() [0x428099]\n??:?
    void tmp2rkn02db.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43073d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f5]\n??:? runModuleUnitTests [0x42c561]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0xb8704554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 10001;\n    long index = -1;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (index == -1)\n    {\n        return new long[0];\n    }\n    return new\
    \ long[] { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ns1e7v6.d(53): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp_ns1e7v6.d(53): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp_ns1e7v6.d(53): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ns1e7v6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = arr[0];\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp11eeelgh.d(62): unittest failure\n----------------\n??:?
    _d_unittestp [0x42873d]\n??:? void tmp11eeelgh.__unittest_L57_C1() [0x4280a9]\n??:?
    void tmp11eeelgh.__modtest() [0x4284bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b68a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430915]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b661]\n??:? runModuleUnitTests [0x42c5cd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b87]\n??:? _d_run_main [0x428af2]\n??:? main [0x4284cf]\n??:?
    __libc_start_main [0x75b16554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(index == -1)\n        return [];\n    result[0] = min;\n    result[1] =\
    \ index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0) return new long[0];\n    long min = arr[0];\n\
    \    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n\
    \            index = i;\n        }\n    }\n    if (min % 2 == 0) return new long[]\
    \ {min, index};\n    return new long[0];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqin7o5o_.d(50): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpqin7o5o_.d(50): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpqin7o5o_.d(50): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqin7o5o_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == long.max)\n    {\n        return\
    \ result;\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpkgr1_sf2.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428735]\n??:? void tmpkgr1_sf2.__unittest_L58_C1() [0x428102]\n??:?
    void tmpkgr1_sf2.__modtest() [0x4284b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b682]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43090d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dbc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430899]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b659]\n??:? runModuleUnitTests [0x42c5c5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b7f]\n??:? _d_run_main [0x428aea]\n??:? main [0x4284c7]\n??:?
    __libc_start_main [0x8e3bf554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    return index == -1 ? new long[0] : new long[] { min, index };\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3g3_mvae.d(49): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp3g3_mvae.d(49): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp3g3_mvae.d(49): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3g3_mvae.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0) return new long[0];\n    long min = arr[0];\n\
    \    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] < min && arr[i] % 2 == 0)\n        {\n            min = arr[i];\n\
    \            index = i;\n        }\n    }\n    if (min % 2 == 0) return new long[]\
    \ {min, index};\n    return new long[0];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpqin7o5o_.d(50): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpqin7o5o_.d(50): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpqin7o5o_.d(50): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqin7o5o_.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[(int)i] < min && arr[(int)i]\
    \ % 2 == 0)\n        {\n            min = arr[(int)i];\n            minIndex =\
    \ i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n\
    \        result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp71dekgjk.d(46): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp71dekgjk.d(46):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmp71dekgjk.d(48): Error:
    C style cast illegal, use `cast(int)i`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmp71dekgjk.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long index\
    \ = 0;\n    bool found = false;\n    for (long i = 0; i < arr.length; i++)\n \
    \   {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n    \
    \        {\n                min = arr[i];\n                index = i;\n      \
    \          found = true;\n            }\n            else\n            {\n   \
    \             if (arr[i] < min)\n                {\n                    min =\
    \ arr[i];\n                    index = i;\n                }\n            }\n\
    \        }\n    }\n    if (found)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp8ba5sqrc.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp8ba5sqrc.__unittest_L70_C1() [0x42811e]\n??:?
    void tmp8ba5sqrc.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x1dae0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    long\
    \ minIndex = long.max;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 &&\
    \ v < min)\n        {\n            min = v;\n            minIndex = i;\n     \
    \   }\n    }\n    if(min != long.max)\n    {\n        res[0] = min;\n        res[1]\
    \ = minIndex;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_zhwmpqn.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286d5]\n??:? void tmp_zhwmpqn.__unittest_L57_C1() [0x4280a2]\n??:?
    void tmp_zhwmpqn.__modtest() [0x428454]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b622]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d5c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430839]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f9]\n??:? runModuleUnitTests [0x42c565]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b98]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b1f]\n??:? _d_run_main [0x428a8a]\n??:? main [0x428467]\n??:?
    __libc_start_main [0x1a612554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == 10001)\n    {\n        return\
    \ result;\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp58whmw1o.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmp58whmw1o.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmp58whmw1o.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xf8200554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min != long.max)\n    {\n        result[0] = min;\n        result[1] =\
    \ index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpp9yz7e_m.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286d5]\n??:? void tmpp9yz7e_m.__unittest_L57_C1() [0x4280a6]\n??:?
    void tmpp9yz7e_m.__modtest() [0x428458]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b622]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d5c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430839]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f9]\n??:? runModuleUnitTests [0x42c565]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b98]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b1f]\n??:? _d_run_main [0x428a8a]\n??:? main [0x42846b]\n??:?
    __libc_start_main [0xc1dbc554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (long i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6imb0zmd.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp6imb0zmd.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp6imb0zmd.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x7c96e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    foreach (i,\
    \ v; arr)\n    {\n        if (v < min && v % 2 == 0)\n        {\n            min\
    \ = v;\n            index = i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n\
    \        result[0] = min;\n        result[1] = index;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6j34mt_v.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286fd]\n??:? void tmp6j34mt_v.__unittest_L59_C1() [0x42806d]\n??:?
    void tmp6j34mt_v.__modtest() [0x428480]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7b7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b64a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308d5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d84]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430861]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b621]\n??:? runModuleUnitTests [0x42c58d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bc0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b47]\n??:? _d_run_main [0x428ab2]\n??:? main [0x428493]\n??:?
    __libc_start_main [0x1ab7a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_31t44rp.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp_31t44rp.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp_31t44rp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xe07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 999999999;\n    long\
    \ index = 0;\n    foreach(long i; arr)\n    {\n        if(i % 2 == 0 && i < min)\n\
    \        {\n            min = i;\n            index = arr.indexOf(i);\n      \
    \  }\n    }\n    if(min == 999999999)\n    {\n        return result;\n    }\n\
    \    result[0] = min;\n    result[1] = index;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp4193j7ab.d(47): Error: no property `indexOf` for type `long[]`\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4193j7ab.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            result[0] = min;\n            result[1] = i;\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp13gatgn6.d(58): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmp13gatgn6.__unittest_L53_C1() [0x428099]\n??:?
    void tmp13gatgn6.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430db4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430891]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b651]\n??:? runModuleUnitTests [0x42c5bd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0x54283554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] res = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index == -1)\n        return [];\n    res[0] = min;\n    res[1] = index;\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(index != -1)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpv4tx4x2g.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286cd]\n??:? void tmpv4tx4x2g.__unittest_L57_C1() [0x42809e]\n??:?
    void tmpv4tx4x2g.__modtest() [0x428450]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c787]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d54]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430831]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f1]\n??:? runModuleUnitTests [0x42c55d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b90]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b17]\n??:? _d_run_main [0x428a82]\n??:? main [0x428463]\n??:?
    __libc_start_main [0xc6cda554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min == arr[0])\n        return result;\n    result[0] = min;\n\
    \    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpsyadkefz.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42876d]\n??:? void tmpsyadkefz.__unittest_L58_C1() [0x4280dd]\n??:?
    void tmpsyadkefz.__modtest() [0x4284f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c827]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430945]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430df4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308d1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b691]\n??:? runModuleUnitTests [0x42c5fd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c30]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428bb7]\n??:? _d_run_main [0x428b22]\n??:? main [0x428503]\n??:?
    __libc_start_main [0xe38ea554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <= min)\n \
    \       {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        return new long[] {min, index};\n    }\n\
    \    return new long[] {};\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgfip5v2t.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpgfip5v2t.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpgfip5v2t.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\n/tmp/tmpgfip5v2t.d(53): Error: found `{` when expecting `;`
    following `return` statement\n/tmp/tmpgfip5v2t.d(54): Error: unrecognized declaration\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgfip5v2t.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    for (int i = 0; i < arr.length;\
    \ i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n     \
    \       min = arr[i];\n            result[0] = min;\n            result[1] = i;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpihcrtz3w.d(59): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmpihcrtz3w.__unittest_L54_C1() [0x428099]\n??:?
    void tmpihcrtz3w.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430db4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430891]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b651]\n??:? runModuleUnitTests [0x42c5bd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0xd9060554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == 10001)\n    {\n        return\
    \ result;\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp58whmw1o.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmp58whmw1o.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmp58whmw1o.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xf8200554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (min == 10001)\n    {\n        return\
    \ result;\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp58whmw1o.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmp58whmw1o.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmp58whmw1o.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xf8200554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpxzrnrava.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpxzrnrava.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpxzrnrava.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x83867554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    bool found = false;\n    foreach(long i, long v; arr)\n    {\n\
    \        if(v % 2 == 0 && v < min)\n        {\n            min = v;\n        \
    \    index = i;\n            found = true;\n        }\n    }\n    if(found)\n\
    \    {\n        result[0] = min;\n        result[1] = index;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpzcrs9f6h.d(65): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286d5]\n??:? void tmpzcrs9f6h.__unittest_L59_C1() [0x4280a2]\n??:?
    void tmpzcrs9f6h.__modtest() [0x428454]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b622]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d5c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430839]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f9]\n??:? runModuleUnitTests [0x42c565]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b98]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b1f]\n??:? _d_run_main [0x428a8a]\n??:? main [0x428467]\n??:?
    __libc_start_main [0x7b08c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    foreach(i, v;\
    \ arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min =\
    \ v;\n            index = i;\n        }\n    }\n    if(index == -1)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[(int)i] % 2 == 0 && arr[(int)i]\
    \ < min)\n        {\n            min = arr[(int)i];\n            minIndex = i;\n\
    \        }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n  \
    \      result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpmunxn_yt.d(46): Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpmunxn_yt.d(46):
    Error: C style cast illegal, use `cast(int)i`\n/tmp/tmpmunxn_yt.d(48): Error:
    C style cast illegal, use `cast(int)i`\nFailed: ["dmd", "-unittest", "-v", "-o-",
    "/tmp/tmpmunxn_yt.d", "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqami092v.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpqami092v.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpqami092v.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xc037f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_31t44rp.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp_31t44rp.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp_31t44rp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xe07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpxzrnrava.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpxzrnrava.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpxzrnrava.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x83867554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1nxoso91.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmp1nxoso91.__unittest_L58_C1() [0x4280b2]\n??:?
    void tmp1nxoso91.__modtest() [0x428464]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x428477]\n??:?
    __libc_start_main [0x6c069554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          minIndex = i;\n        }\n    }\n    if (min == long.max)\n    {\n\
    \        return result;\n    }\n    result[0] = min;\n    result[1] = minIndex;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbysgji8a.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmpbysgji8a.__unittest_L58_C1() [0x4280f6]\n??:?
    void tmpbysgji8a.__modtest() [0x4284a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284bb]\n??:?
    __libc_start_main [0x29f2e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    for\
    \ (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < min)\n        {\n            min = arr[i];\n            result[0] = min;\n\
    \            result[1] = i;\n        }\n    }\n    if (min == long.max)\n    {\n\
    \        return new long[0];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqami092v.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpqami092v.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpqami092v.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xc037f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpz0flqjgj.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpz0flqjgj.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmpz0flqjgj.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x41737554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index == -1)\n        return [];\n    result[0] = min;\n    result[1] =\
    \ index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1)\n        return new long[0];\n    return new long[]\
    \ { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzn3kh7du.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpzn3kh7du.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpzn3kh7du.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzn3kh7du.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqami092v.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpqami092v.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpqami092v.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xc037f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index != -1)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_78v7i1v.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x428715]\n??:? void tmp_78v7i1v.__unittest_L57_C1() [0x4280e6]\n??:?
    void tmp_78v7i1v.__modtest() [0x428498]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d9c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430879]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b5f]\n??:? _d_run_main [0x428aca]\n??:? main [0x4284ab]\n??:?
    __libc_start_main [0xa8ae8554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long smallest = 0;\n    long\
    \ index = 0;\n    bool found = false;\n    foreach(long i, long v; arr)\n    {\n\
    \        if(v % 2 == 0)\n        {\n            if(!found)\n            {\n  \
    \              found = true;\n                smallest = v;\n                index\
    \ = i;\n            }\n            else\n            {\n                if(v <\
    \ smallest)\n                {\n                    smallest = v;\n          \
    \          index = i;\n                }\n            }\n        }\n    }\n  \
    \  if(found)\n    {\n        result[0] = smallest;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpt97fhcxe.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286ed]\n??:? void tmpt97fhcxe.__unittest_L70_C1() [0x4280be]\n??:?
    void tmpt97fhcxe.__modtest() [0x428470]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b63a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d74]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430851]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b611]\n??:? runModuleUnitTests [0x42c57d]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bb0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b37]\n??:? _d_run_main [0x428aa2]\n??:? main [0x428483]\n??:?
    __libc_start_main [0xac23c554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(long i; 0..arr.length)\n    {\n        if(arr[i] % 2\
    \ == 0 && arr[i] < min)\n        {\n            min = arr[i];\n            index\
    \ = i;\n        }\n    }\n    if(min == long.max)\n    {\n        return result;\n\
    \    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpugmdlupv.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42873d]\n??:? void tmpugmdlupv.__unittest_L58_C1() [0x42810e]\n??:?
    void tmpugmdlupv.__modtest() [0x4284c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b68a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430915]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dc4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308a1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b661]\n??:? runModuleUnitTests [0x42c5cd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b87]\n??:? _d_run_main [0x428af2]\n??:? main [0x4284d3]\n??:?
    __libc_start_main [0xfcbf6554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = int.max;\n    long\
    \ minIndex = int.max;\n    for (int i = 0; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    if (min == int.max)\n    {\n\
    \        return new long[0];\n    }\n    result[0] = min;\n    result[1] = minIndex;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_31t44rp.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp_31t44rp.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp_31t44rp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xe07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (long\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpp4xwjzjp.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpp4xwjzjp.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpp4xwjzjp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x688f0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfh3raqek.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpfh3raqek.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmpfh3raqek.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x4c637554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n\
    \    long minIndex = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n  \
    \      if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n        return\
    \ [min, minIndex];\n    return [];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp2rkn02db.d(60): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmp2rkn02db.__unittest_L55_C1() [0x428099]\n??:?
    void tmp2rkn02db.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b61e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c60]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43073d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f5]\n??:? runModuleUnitTests [0x42c561]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0xb8704554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    int minIndex = 0;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpmjt0309h.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpmjt0309h.__unittest_L58_C1() [0x4280b9]\n??:?
    void tmpmjt0309h.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0xdbfe3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long minIndex = 0;\n    for (long i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            minIndex = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpfh3raqek.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpfh3raqek.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmpfh3raqek.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x4c637554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long index\
    \ = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n  \
    \  {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n     \
    \       {\n                min = arr[i];\n                index = i;\n       \
    \         found = true;\n            }\n            else\n            {\n    \
    \            if (arr[i] < min)\n                {\n                    min = arr[i];\n\
    \                    index = i;\n                }\n            }\n        }\n\
    \    }\n    if (found)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplw7lg7yy.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplw7lg7yy.__unittest_L70_C1() [0x42811e]\n??:?
    void tmplw7lg7yy.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x38ffa554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 10001L;\n    long index = -1L;\n    foreach(i, v; arr)\n\
    \    {\n        if(v % 2 == 0 && v < min)\n        {\n            min = v;\n \
    \           index = i;\n        }\n    }\n    if(index == -1L)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, e; arr)\n    {\n        if(e % 2 == 0 && e < min)\n\
    \        {\n            min = e;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp1nxoso91.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmp1nxoso91.__unittest_L58_C1() [0x4280b2]\n??:?
    void tmp1nxoso91.__modtest() [0x428464]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x428477]\n??:?
    __libc_start_main [0x6c069554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp_31t44rp.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp_31t44rp.__unittest_L58_C1() [0x4280bd]\n??:?
    void tmp_31t44rp.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xe07f554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            result[0] = min;\n            result[1] = i;\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp13gatgn6.d(58): unittest failure\n----------------\n??:?
    _d_unittestp [0x42872d]\n??:? void tmp13gatgn6.__unittest_L53_C1() [0x428099]\n??:?
    void tmp13gatgn6.__modtest() [0x4284ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7e7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b67a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430905]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430db4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430891]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b651]\n??:? runModuleUnitTests [0x42c5bd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b77]\n??:? _d_run_main [0x428ae2]\n??:? main [0x4284bf]\n??:?
    __libc_start_main [0x54283554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (long i =\
    \ 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1)\n        return new long[0];\n    return new long[]\
    \ { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpha6tvui0.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpha6tvui0.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpha6tvui0.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpha6tvui0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0) return new long[0];\n    long min = arr[0];\n\
    \    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n    {\n     \
    \   if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n\
    \            index = i;\n        }\n    }\n    if (min % 2 != 0) return new long[0];\n\
    \    return new long[] { min, index };\n}\nunittest\n{\n    alias candidate =\
    \ pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmplz3k9nlo.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmplz3k9nlo.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmplz3k9nlo.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplz3k9nlo.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    long index = 0;\n    for (int i = 0; i\
    \ < arr.length; i++) {\n        if (arr[i] < min && arr[i] % 2 == 0) {\n     \
    \       min = arr[i];\n            index = i;\n        }\n    }\n    if (min %\
    \ 2 == 0) {\n        result[0] = min;\n        result[1] = index;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpu96kad1y.d(60): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpu96kad1y.__unittest_L55_C1() [0x4280bd]\n??:?
    void tmpu96kad1y.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x13e554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    for (long i =\
    \ 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1)\n        return new long[0];\n    return new long[]\
    \ { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpha6tvui0.d(51): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmpha6tvui0.d(51): Error: found `}` when expecting `;`
    following statement\n/tmp/tmpha6tvui0.d(51): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpha6tvui0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long minIndex\
    \ = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n  \
    \  {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n     \
    \       {\n                min = arr[i];\n                minIndex = i;\n    \
    \            found = true;\n            }\n            else\n            {\n \
    \               if (arr[i] < min)\n                {\n                    min\
    \ = arr[i];\n                    minIndex = i;\n                }\n          \
    \  }\n        }\n    }\n    if (found)\n    {\n        result[0] = min;\n    \
    \    result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpb8865fqr.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpb8865fqr.__unittest_L70_C1() [0x42811e]\n??:?
    void tmpb8865fqr.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xa06ba554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long minIndex\
    \ = 0;\n    bool hasEven = false;\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0)\n        {\n            if (!hasEven)\n \
    \           {\n                min = arr[i];\n                minIndex = i;\n\
    \                hasEven = true;\n            }\n            else\n          \
    \  {\n                if (arr[i] < min)\n                {\n                 \
    \   min = arr[i];\n                    minIndex = i;\n                }\n    \
    \        }\n        }\n    }\n    if (hasEven)\n    {\n        result[0] = min;\n\
    \        result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp15472xrj.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmp15472xrj.__unittest_L70_C1() [0x42811e]\n??:?
    void tmp15472xrj.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0xe6ec2554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index == -1)\n        return result;\n    result[0] = min;\n    result[1]\
    \ = index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp6oekq80m.d(62): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286d5]\n??:? void tmp6oekq80m.__unittest_L56_C1() [0x4280a6]\n??:?
    void tmp6oekq80m.__modtest() [0x428458]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c78f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b622]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ad]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d5c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430839]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5f9]\n??:? runModuleUnitTests [0x42c565]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428b98]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b1f]\n??:? _d_run_main [0x428a8a]\n??:? main [0x42846b]\n??:?
    __libc_start_main [0x7ed39554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 10001;\n    long index = -1;\n    for (int i = 0; i\
    \ < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n  \
    \      {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (index == -1)\n    {\n        return new long[0];\n    }\n    return new\
    \ long[] { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n   \
    \ assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_ns1e7v6.d(53): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp_ns1e7v6.d(53): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp_ns1e7v6.d(53): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_ns1e7v6.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return [];\n    long min = arr[0];\n\
    \    long index = 0;\n    foreach (i, v; arr)\n    {\n        if (v % 2 == 0 &&\
    \ v < min)\n        {\n            min = v;\n            index = i;\n        }\n\
    \    }\n    if (min % 2 == 0)\n        return [min, index];\n    return [];\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpx_zrvfzm.d(60): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286dd]\n??:? void tmpx_zrvfzm.__unittest_L55_C1() [0x428049]\n??:?
    void tmpx_zrvfzm.__modtest() [0x42845c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c73b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b5ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b5a5]\n??:? runModuleUnitTests [0x42c511]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b27]\n??:? _d_run_main [0x428a92]\n??:? main [0x42846f]\n??:?
    __libc_start_main [0x535a4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    int minIndex = -1;\n    long\
    \ minValue = 0;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0)\n        {\n            if (minIndex == -1)\n            {\n     \
    \           minIndex = i;\n                minValue = arr[i];\n            }\n\
    \            else if (arr[i] < minValue)\n            {\n                minIndex\
    \ = i;\n                minValue = arr[i];\n            }\n        }\n    }\n\
    \    if (minIndex != -1)\n    {\n        result[0] = minValue;\n        result[1]\
    \ = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmps2ibnsd1.d(71): unittest failure\n----------------\n??:?
    _d_unittestp [0x428745]\n??:? void tmps2ibnsd1.__unittest_L65_C1() [0x428116]\n??:?
    void tmps2ibnsd1.__modtest() [0x4284c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b692]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43091d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dcc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308a9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b669]\n??:? runModuleUnitTests [0x42c5d5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c08]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b8f]\n??:? _d_run_main [0x428afa]\n??:? main [0x4284db]\n??:?
    __libc_start_main [0x7f771554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplxun4lrm.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplxun4lrm.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmplxun4lrm.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x1e18554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    foreach (i,\
    \ e; arr)\n    {\n        if (e % 2 == 0 && e < min)\n        {\n            min\
    \ = e;\n            index = i;\n        }\n    }\n    if (min % 2 == 0)\n    {\n\
    \        result[0] = min;\n        result[1] = index;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprd1wha3k.d(49): Error: cannot implicitly convert expression
    `i` of type `ulong` to `int`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprd1wha3k.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(index == -1)\n        return [];\n    result[0] = min;\n    result[1] =\
    \ index;\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long minEven = long.max;\n \
    \   long minEvenIndex = long.max;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < minEven)\n        {\n        \
    \    minEven = arr[i];\n            minEvenIndex = i;\n        }\n    }\n    if\
    \ (minEven == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ minEven;\n    result[1] = minEvenIndex;\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpqdix44io.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428735]\n??:? void tmpqdix44io.__unittest_L58_C1() [0x428102]\n??:?
    void tmpqdix44io.__modtest() [0x4284b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b682]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43090d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dbc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430899]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b659]\n??:? runModuleUnitTests [0x42c5c5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bf8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b7f]\n??:? _d_run_main [0x428aea]\n??:? main [0x4284c7]\n??:?
    __libc_start_main [0x591a4554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    int\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return result;\n\
    \    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L])\
    \ == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpvlmf1mpw.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmpvlmf1mpw.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmpvlmf1mpw.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xd0cb0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long index\
    \ = 0;\n    bool found = false;\n    for (int i = 0; i < arr.length; i++)\n  \
    \  {\n        if (arr[i] % 2 == 0)\n        {\n            if (!found)\n     \
    \       {\n                min = arr[i];\n                index = i;\n       \
    \         found = true;\n            }\n            else\n            {\n    \
    \            if (arr[i] < min)\n                {\n                    min = arr[i];\n\
    \                    index = i;\n                }\n            }\n        }\n\
    \    }\n    if (found)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplw7lg7yy.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplw7lg7yy.__unittest_L70_C1() [0x42811e]\n??:?
    void tmplw7lg7yy.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x38ffa554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    long index = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            index = i;\n       \
    \ }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpbh0ekmt1.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpbh0ekmt1.__unittest_L59_C1() [0x4280bd]\n??:?
    void tmpbh0ekmt1.__modtest() [0x4284d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284e3]\n??:?
    __libc_start_main [0x24752554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    foreach(i, v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n\
    \        {\n            min = v;\n            index = i;\n        }\n    }\n \
    \   if(min == long.max)\n    {\n        return result;\n    }\n    result[0] =\
    \ min;\n    result[1] = index;\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpiau_vyya.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmpiau_vyya.__unittest_L58_C1() [0x4280b2]\n??:?
    void tmpiau_vyya.__modtest() [0x428464]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x428477]\n??:?
    __libc_start_main [0x692f3554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index != -1)\n    {\n        result[0]\
    \ = min;\n        result[1] = index;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpq00cdxaq.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x428715]\n??:? void tmpq00cdxaq.__unittest_L57_C1() [0x4280e2]\n??:?
    void tmpq00cdxaq.__modtest() [0x428494]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b662]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d9c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430879]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b639]\n??:? runModuleUnitTests [0x42c5a5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428bd8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b5f]\n??:? _d_run_main [0x428aca]\n??:? main [0x4284a7]\n??:?
    __libc_start_main [0x8fdf0554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 10001L;\n    long index = -1L;\n    for (int i = 0;\
    \ i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (index == -1L)\n    {\n        return new long[0];\n    }\n    return\
    \ new long[] { min, index };\n}\nunittest\n{\n    alias candidate = pluck;\n\n\
    \    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmps09_b2r0.d(53): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmps09_b2r0.d(53): Error: found `}` when expecting `;`
    following statement\n/tmp/tmps09_b2r0.d(53): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmps09_b2r0.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = 999999999;\n    long index = 0;\n    long[] result\
    \ = new long[2];\n    for (int i = 0; i < arr.length; i++)\n    {\n        if\
    \ (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n  \
    \          index = i;\n        }\n    }\n    if (min == 999999999)\n    {\n  \
    \      return result;\n    }\n    result[0] = min;\n    result[1] = index;\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmp84dwzd7s.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x428725]\n??:? void tmp84dwzd7s.__unittest_L58_C1() [0x4280f2]\n??:?
    void tmp84dwzd7s.__modtest() [0x4284a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c7df]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b672]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308fd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dac]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430889]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b649]\n??:? runModuleUnitTests [0x42c5b5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428be8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b6f]\n??:? _d_run_main [0x428ada]\n??:? main [0x4284b7]\n??:?
    __libc_start_main [0xf7123554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    long min\
    \ = arr[0];\n    long index = 0;\n    for (long i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            index = i;\n        }\n    }\n    if (min == arr[0])\n\
    \        return new long[0];\n    return new long[] { min, index };\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7xb0gjco.d(53): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp7xb0gjco.d(53): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp7xb0gjco.d(53): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7xb0gjco.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int minIndex = 0;\n    for (int\
    \ i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] <\
    \ min)\n        {\n            min = arr[i];\n            minIndex = i;\n    \
    \    }\n    }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n      \
    \  result[1] = minIndex;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmplxun4lrm.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmplxun4lrm.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmplxun4lrm.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x1e18554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long minIndex = -1;\n    foreach(i,\
    \ v; arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min\
    \ = v;\n            minIndex = i;\n        }\n    }\n    if(minIndex == -1)\n\
    \        return [];\n    return [min, minIndex];\n}\nunittest\n{\n    alias candidate\
    \ = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0)\n     \
    \   return result;\n    long min = arr[0];\n    int index = 0;\n    for (int i\
    \ = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n\
    \        {\n            min = arr[i];\n            index = i;\n        }\n   \
    \ }\n    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1]\
    \ = index;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnzllwaze.d(64): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpnzllwaze.__unittest_L59_C1() [0x4280b9]\n??:?
    void tmpnzllwaze.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0x9d6b5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    foreach(i, v;\
    \ arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min =\
    \ v;\n            index = i;\n        }\n    }\n    if(index == -1)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    foreach(i, v;\
    \ arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min =\
    \ v;\n            index = i;\n        }\n    }\n    if(index == -1)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 0;\n    long index\
    \ = 0;\n    bool found = false;\n    for (long i = 0; i < arr.length; i++)\n \
    \   {\n        if (arr[i] % 2 == 0)\n        {\n            if (found == false)\n\
    \            {\n                min = arr[i];\n                index = i;\n  \
    \              found = true;\n            }\n            else\n            {\n\
    \                if (arr[i] < min)\n                {\n                    min\
    \ = arr[i];\n                    index = i;\n                }\n            }\n\
    \        }\n    }\n    if (found == true)\n    {\n        result[0] = min;\n \
    \       result[1] = index;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n   \
    \ assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n\
    \    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmprhp85ua1.d(76): unittest failure\n----------------\n??:?
    _d_unittestp [0x428755]\n??:? void tmprhp85ua1.__unittest_L70_C1() [0x428122]\n??:?
    void tmprhp85ua1.__modtest() [0x4284d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c80f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b6a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x43092d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430ddc]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b9]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b679]\n??:? runModuleUnitTests [0x42c5e5]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c18]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b9f]\n??:? _d_run_main [0x428b0a]\n??:? main [0x4284e7]\n??:?
    __libc_start_main [0xaa6f5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = 0;\n    long minIndex = 0;\n    foreach(i; arr)\n    {\n        if(i\
    \ % 2 == 0 && i < min)\n        {\n            min = i;\n            minIndex\
    \ = index;\n        }\n        index++;\n    }\n    if(min == long.max)\n    {\n\
    \        return result;\n    }\n    else\n    {\n        result[0] = min;\n  \
    \      result[1] = minIndex;\n        return result;\n    }\n}\nunittest\n{\n\
    \    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n\
    \    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) ==\
    \ []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpnkdf3j5t.d(69): unittest failure\n----------------\n??:?
    _d_unittestp [0x4286e5]\n??:? void tmpnkdf3j5t.__unittest_L63_C1() [0x4280b2]\n??:?
    void tmpnkdf3j5t.__modtest() [0x428464]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b632]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4308bd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430d6c]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x430849]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b609]\n??:? runModuleUnitTests [0x42c575]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428ba8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b2f]\n??:? _d_run_main [0x428a9a]\n??:? main [0x428477]\n??:?
    __libc_start_main [0xddff2554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    if (arr.length == 0)\n        return new long[0];\n    long min\
    \ = arr[0];\n    long minIndex = 0;\n    for (int i = 0; i < arr.length; i++)\n\
    \    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n        {\n            min\
    \ = arr[i];\n            minIndex = i;\n        }\n    }\n    if (min % 2 == 0)\n\
    \        return new long[] { min, minIndex };\n    return new long[0];\n}\nunittest\n\
    {\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L, 3L]) == [2L,\
    \ 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp21jk8mij.d(52): Error: found `{` when expecting `;` following
    `return` statement\n/tmp/tmp21jk8mij.d(52): Error: found `}` when expecting `;`
    following statement\n/tmp/tmp21jk8mij.d(52): Deprecation: use `{ }` for an empty
    statement, not `;`\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp21jk8mij.d",
    "-I/tmp"]\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = arr[0];\n    long minIndex = 0;\n    bool found = false;\n\
    \    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            if (!found)\n            {\n                min = arr[i];\n\
    \                minIndex = i;\n                found = true;\n            }\n\
    \            else\n            {\n                if (arr[i] < min)\n        \
    \        {\n                    min = arr[i];\n                    minIndex =\
    \ i;\n                }\n            }\n        }\n    }\n    if (found)\n   \
    \ {\n        return [min, minIndex];\n    }\n    else\n    {\n        return [];\n\
    \    }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpprct74bu.d(39): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4287ee]\n??:? long[] tmpprct74bu.pluck(long[]) [0x427e1b]\n??:?
    void tmpprct74bu.__unittest_L71_C1() [0x4280c8]\n??:? void tmpprct74bu.__modtest()
    [0x4284c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b62e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43074d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b605]\n??:? runModuleUnitTests [0x42c571]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b87]\n??:? _d_run_main [0x428af2]\n??:? main [0x4284d3]\n??:?
    __libc_start_main [0x60243554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = arr[0];\n    long index = 0;\n    bool found = false;\n\
    \    for (long i = 0; i < arr.length; i++)\n    {\n        if (arr[i] % 2 == 0)\n\
    \        {\n            if (!found)\n            {\n                min = arr[i];\n\
    \                index = i;\n                found = true;\n            }\n  \
    \          else\n            {\n                if (arr[i] < min)\n          \
    \      {\n                    min = arr[i];\n                    index = i;\n\
    \                }\n            }\n        }\n    }\n    if (found)\n    {\n \
    \       return [min, index];\n    }\n    else\n    {\n        return [];\n   \
    \ }\n}\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n \
    \   assert(candidate([]) == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L])\
    \ == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n\
    \    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n    assert(candidate([7L,\
    \ 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L, 9L, 7L, 1L]) == []);\n\
    }\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.RangeError@/tmp/tmpy7jde41v.d(39): Range violation\n----------------\n??:?
    _d_arrayboundsp [0x4287ee]\n??:? long[] tmpy7jde41v.pluck(long[]) [0x427e1b]\n??:?
    void tmpy7jde41v.__unittest_L71_C1() [0x4280c8]\n??:? void tmpy7jde41v.__modtest()
    [0x4284c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c79b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b62e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4307c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430c70]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x43074d]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b605]\n??:? runModuleUnitTests [0x42c571]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c00]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b87]\n??:? _d_run_main [0x428af2]\n??:? main [0x4284d3]\n??:?
    __libc_start_main [0x59cc5554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 1
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    if (arr.length == 0) return\
    \ result;\n    long min = arr[0];\n    int index = 0;\n    for (int i = 0; i <\
    \ arr.length; i++)\n    {\n        if (arr[i] % 2 == 0 && arr[i] < min)\n    \
    \    {\n            min = arr[i];\n            index = i;\n        }\n    }\n\
    \    if (min % 2 == 0)\n    {\n        result[0] = min;\n        result[1] = index;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = pluck;\n\n \
    \   assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'b''core.exception.AssertError@/tmp/tmpof8_vrko.d(63): unittest failure\n----------------\n??:?
    _d_unittestp [0x42874d]\n??:? void tmpof8_vrko.__unittest_L58_C1() [0x4280b9]\n??:?
    void tmpof8_vrko.__modtest() [0x4284cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c807]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b69a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x430925]\n??:? int rt.sections_elf_shared.DSO.opApply(scope
    int delegate(ref rt.sections_elf_shared.DSO)) [0x430dd4]\n??:? int rt.minfo.moduleinfos_apply(scope
    int delegate(immutable(object.ModuleInfo*))) [0x4308b1]\n??:? int object.ModuleInfo.opApply(scope
    int delegate(object.ModuleInfo*)) [0x42b671]\n??:? runModuleUnitTests [0x42c5dd]\n??:?
    void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428c10]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope
    void delegate()) [0x428b97]\n??:? _d_run_main [0x428b02]\n??:? main [0x4284df]\n??:?
    __libc_start_main [0xdab2a554]\n1/1 unittests FAILED\n'''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = 10001;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long[] result = new long[2];\n    long min = long.max;\n    long\
    \ index = -1;\n    for (int i = 0; i < arr.length; i++)\n    {\n        if (arr[i]\
    \ % 2 == 0 && arr[i] < min)\n        {\n            min = arr[i];\n          \
    \  index = i;\n        }\n    }\n    if (index == -1)\n    {\n        return new\
    \ long[0];\n    }\n    result[0] = min;\n    result[1] = index;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = pluck;\n\n    assert(candidate([4L, 2L,\
    \ 3L]) == [2L, 1L]);\n    assert(candidate([1L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([5L, 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L, 0L, 5L, 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L])\
    \ == [4L, 1L]);\n    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
- exit_code: 0
  program: "import std.math;\n/*\n\n    \"Given an array representing a branch of\
    \ a tree that has non-negative integer nodes\n    your task is to pluck one of\
    \ the nodes and return it.\n    The plucked node should be the node with the smallest\
    \ even value.\n    If multiple nodes with the same smallest even value are found\
    \ return the node that has smallest index.\n\n    The plucked node should be returned\
    \ in an array, [ smalest_value, its index ],\n    If there are no even values\
    \ or the given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4L,\
    \ 2L, 3L])\n    [2L, 1L]\n    Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index.\n\n    Example 2:\n    >>> pluck([1L, 2L, 3L])\n \
    \   [2L, 1L]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n\
    \    >>> pluck([5L, 0L, 3L, 0L, 4L, 2L])\n    [0L, 1L]\n    Explanation: 0 is\
    \ the smallest value, but  there are two zeros,\n                 so we will choose\
    \ the first zero, which has the smallest index.\n\n    Constraints:\n        *\
    \ 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \n*/\nlong[] pluck(long[]\
    \ arr) \n{\n    long min = long.max;\n    long index = -1;\n    foreach(i, v;\
    \ arr)\n    {\n        if(v % 2 == 0 && v < min)\n        {\n            min =\
    \ v;\n            index = i;\n        }\n    }\n    if(index == -1)\n        return\
    \ [];\n    return [min, index];\n}\nunittest\n{\n    alias candidate = pluck;\n\
    \n    assert(candidate([4L, 2L, 3L]) == [2L, 1L]);\n    assert(candidate([1L,\
    \ 2L, 3L]) == [2L, 1L]);\n    assert(candidate([]) == []);\n    assert(candidate([5L,\
    \ 0L, 3L, 0L, 4L, 2L]) == [0L, 1L]);\n    assert(candidate([1L, 2L, 3L, 0L, 5L,\
    \ 3L]) == [0L, 3L]);\n    assert(candidate([5L, 4L, 8L, 4L, 8L]) == [4L, 1L]);\n\
    \    assert(candidate([7L, 6L, 7L, 1L]) == [6L, 1L]);\n    assert(candidate([7L,\
    \ 9L, 7L, 1L]) == []);\n}\nvoid main(){}"
  status: OK
  stderr: b''
  stdout: b''
