{
  "name": "mbpp_308_large_product",
  "language": "py",
  "prompt": "from typing import List\n\ndef large_product(nums1: List[int], nums2: List[int], N: int) -> List[int]:\n    \"\"\"\n\tWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\t\"\"\"\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py",
  "prompt_terminology": "reworded",
  "tests": "def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3) == [60, 54, 50]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 4) == [60, 54, 50, 48]\n    assert candidate([1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 5) == [60, 54, 50, 48, 45]\n\ndef test_check():\n    check(large_product)\n\ntest_check()\n",
  "stop_tokens": [
    "\ndef",
    "\n#",
    "\nif",
    "\nclass"
  ],
  "completions": [
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort()\n    nums2.sort()\n    result = []\n    for i in range(N):\n        if nums1[-1] * nums2[-1] > nums1[0] * nums2[0]:\n            result.append(nums1.pop() * nums2.pop())\n        else:\n            result.append(nums1.pop(0) * nums2.pop(0))\n    return result\n",
    "    nums1.sort()\n    nums2.sort()\n    res = []\n    for i in range(N):\n        if nums1[-1] * nums2[-1] > nums1[0] * nums2[0]:\n            res.append(nums1.pop() * nums2.pop())\n        else:\n            res.append(nums1.pop(0) * nums2.pop(0))\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        if nums1[i] > nums2[i]:\n            res.append(nums1[i] * nums2[0])\n        else:\n            res.append(nums1[0] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    ans = []\n    for i in range(N):\n        ans.append(nums1[i] * nums2[i])\n    return ans\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    i = 0\n    j = 0\n    res = []\n    while i < len(nums1) and j < len(nums2) and len(res) < N:\n        if nums1[i] > nums2[j]:\n            res.append(nums1[i] * nums2[j])\n            j += 1\n        else:\n            res.append(nums1[i] * nums2[j])\n            i += 1\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if N <= 0:\n        return []\n    if N > len(nums1) * len(nums2):\n        return []\n    # heapify\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < N:\n                heapq.heappush(heap, (nums1[i] * nums2[j], i, j))\n            else:\n                if nums1[i] * nums2[j] > heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] * nums2[j], i, j))\n    # get result\n    res = []\n    while heap:\n        res.append(heapq.heappop(heap)[0])\n    return res[::-1]\n",
    "    nums1.sort()\n    nums2.sort()\n    nums1 = nums1[::-1]\n    nums2 = nums2[::-1]\n    result = []\n    for i in range(N):\n        result.append(nums1[i] * nums2[i])\n    return result\n\nprint(large_product([1,2,3,4,5], [6,7,8,9,10], 3))",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    result = []\n    i, j = 0, 0\n    while len(result) < N:\n        if nums1[i] * nums2[j] > nums1[i] * nums2[j + 1]:\n            result.append(nums1[i] * nums2[j])\n            j += 1\n        else:\n            result.append(nums1[i] * nums2[j + 1])\n            i += 1\n    return result",
    "    nums1.sort()\n    nums2.sort()\n    res = []\n    for i in range(N):\n        if nums1[-1] * nums2[-1] > nums1[0] * nums2[0]:\n            res.append(nums1.pop() * nums2.pop())\n        else:\n            res.append(nums1.pop(0) * nums2.pop(0))\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    res = []\n    for i in range(N):\n        res.append(nums1[i] * nums2[i])\n    return res\n",
    "    nums1.sort(reverse=True)\n    nums2.sort(reverse=True)\n    products = []\n    for i in range(N):\n        products.append(nums1[i] * nums2[i])\n    return products\n",
    "    nums1.sort()\n    nums2.sort()\n    nums1 = nums1[::-1]\n    nums2 = nums2[::-1]\n    res = []\n    for i in range(N):\n        if nums1[i] > nums2[i]:\n            res.append(nums1[i] * nums2[i])\n        else:\n            res.append(nums1[i] * nums2[i])\n    return res\n"
  ]
}