{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "py",
  "prompt": "from typing import List\n\ndef k_smallest_pairs(nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:\n    \"\"\"\n\tWrite a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\t\"\"\"\n",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "reworded",
  "tests": "def check(candidate):\n    assert candidate([1, 3, 7], [2, 4, 6], 2) == [[1, 2], [1, 4]]\n    assert candidate([1, 3, 7], [2, 4, 6], 1) == [[1, 2]]\n    assert candidate([1, 3, 7], [2, 4, 6], 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n\ndef test_check():\n    check(k_smallest_pairs)\n\ntest_check()\n",
  "stop_tokens": [
    "\ndef",
    "\n#",
    "\nif",
    "\nclass"
  ],
  "completions": [
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [item[1] for item in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappushpop(heap, (nums1[i] + nums2[j], i, j))\n    res = []\n    for i in range(k):\n        res.append([nums1[heap[i][1]], nums2[heap[i][2]]])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [(nums1[i], nums2[j]) for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n    res = []\n    while k > 0 and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]\n\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            res.append([nums1[i], nums2[j]])\n    res.sort(key=lambda x: x[0] + x[1])\n    return res[:k]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i]-nums2[j], nums1[i], nums2[j]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i]-nums2[j], nums1[i], nums2[j]))\n    return [[x[1], x[2]] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    n1, n2 = len(nums1), len(nums2)\n    if k > n1 * n2:\n        k = n1 * n2\n    heap = []\n    for i in range(n1):\n        for j in range(n2):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [(nums1[i], nums2[j]) for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    # Time: O(k * log(k))\n    # Space: O(k)\n    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n                else:\n                    break\n    return [[-x[0] - y[0], x[0], y[0]] for x, y in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)] if k <= len(heap) else [heapq.heappop(heap)[1] for _ in range(len(heap))]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(len(nums1), k)):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [pair[1] for pair in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)] if k < len(heap) else [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k <= 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n    res = []\n    while heap:\n        res.append([nums1[heap[0][1]], nums2[heap[0][2]]])\n        heapq.heappop(heap)\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    while k > 0:\n        res.append(heapq.heappop(heap)[1])\n        k -= 1\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n    return res[::-1]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -nums1[i] - nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(min(k, len(heap))):\n        res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    for i in range(len(heap)):\n        res.append([nums1[heap[i][1]], nums2[heap[i][2]]])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    queue = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(queue) < k:\n                heapq.heappush(queue, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < queue[0][0]:\n                    heapq.heappop(queue)\n                    heapq.heappush(queue, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [pair[1] for pair in queue]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [i[1] for i in heap]",
    "    if not nums1 or not nums2:\n        return []\n    # create a min heap\n    heap = []\n    # add the first element of each array to the heap\n    heapq.heappush(heap, (nums1[0] + nums2[0], [0, 0]))\n    # create a set to keep track of the indices we have already visited\n    visited = set()\n    # create a list to store the result\n    result = []\n    # loop k times\n    for _ in range(k):\n        # if the heap is empty, break\n        if not heap:\n            break\n        # pop the smallest element from the heap\n        _, [i, j] = heapq.heappop(heap)\n        # add the element to the result\n        result.append([nums1[i], nums2[j]])\n        # if we haven't visited the next element in nums1, add it to the heap\n        if i + 1 < len(nums1) and (i + 1, j) not in visited:\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], [i + 1, j]))\n            visited.add((i + 1, j))\n        # if we haven't visited the next element in nums2, add it to the heap\n        if j + 1 < len(nums2) and (i, j + 1) not in visited:\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], [i, j + 1]))\n            visited.add((i, j + 1))\n    return result",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n    return [(nums1[i], nums2[j]) for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    result = []\n    for i in range(k):\n        result.append(heapq.heappop(heap)[1])\n    return result\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n",
    "    # if not nums1 or not nums2:\n    #     return []\n    #\n    # heap = []\n    # for i in range(len(nums1)):\n    #     for j in range(len(nums2)):\n    #         heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    #\n    # res = []\n    # for _ in range(k):\n    #     if heap:\n    #         res.append(heapq.heappop(heap)[1])\n    #\n    # return res\n\n    # if not nums1 or not nums2:\n    #     return []\n    #\n    # heap = []\n    # for i in range(len(nums1)):\n    #     for j in range(len(nums2)):\n    #         if len(heap) < k:\n    #             heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    #         else:\n    #             if nums1[i] + nums2[j] < heap[0][0]:\n    #                 heapq.heapreplace(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    #\n    # return [heapq.heappop(heap)[1] for _ in range(k) if heap]\n\n    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heapreplace",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        res.append([nums1[heap[0][1]], nums2[heap[0][2]]])\n        heapq.heappop(heap)\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [(nums1[i], nums2[j]) for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(min(k, len(heap))):\n        res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappushpop(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[p[1]], nums2[p[2]]] for p in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappushpop(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n\n    return [x[1] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    # Time: O(klogk)\n    # Space: O(k)\n    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heapreplace(heap, (nums1[i] + nums2[j], i, j))\n    return [(nums1[i], nums2[j]) for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(min(k, len(heap))):\n        res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    import heapq\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], (nums1[i], nums2[j])))\n    res = []\n    for _ in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k >= len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [item[1] for item in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if len(nums1) == 0 or len(nums2) == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    # heapify the list of tuples\n    heap = [(nums1[i] + nums2[0], i, 0) for i in range(len(nums1))]\n    heapq.heapify(heap)\n    res = []\n    while k > 0 and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n    return res\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n\n    # heapify the first array\n    heapq.heapify(nums1)\n\n    # initialize the result list\n    result = []\n\n    # loop through the second array\n    for num in nums2:\n        # if the length of the result list is less than k\n        if len(result) < k:\n            # pop the first element from the heap\n            popped_num = heapq.heappop(nums1)\n            # add the popped element and the current element to the result list\n            result.append([popped_num, num])\n            # push the popped element back to the heap\n            heapq.heappush(nums1, popped_num)\n        # if the length of the result list is equal to k\n        else:\n            # if the sum of the first element in the heap and the current element is greater than the sum of the last element in the result list\n            if nums1[0] + num > result[-1][0] + result[-1][1]:\n                # pop the first element from the heap\n                popped_num = heapq.heappop(nums1)\n                # pop the last element from the result list\n                popped_result = result.pop()\n                # add the popped element and the current element to the result list\n                result.append([popped_num, num])\n                # push the popped element back to the heap\n                heapq.heappush(nums1, popped_num)\n                # push the popped element from the result list back to the heap\n                heapq.heappush(nums1, popped_result[0])\n            # if the sum of the first element in the heap and the current element is less than the sum of the last element in the result list\n            else:\n                # break the loop\n                break\n\n    return result\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [pair[1] for pair in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [ [nums1[i], nums2[j]] for _, i, j in heap ]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n    res = []\n    for i in range(k):\n        res.append([nums1[heap[i][1]], nums2[heap[i][2]]])\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    for _, i, j in heap:\n        res.append([nums1[i], nums2[j]])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [pair[1] for pair in heap]\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))\nprint(k_smallest_pairs([1, 1, 2], [1, 2, 3], 2))\nprint(k_smallest_pairs([1, 2], [3], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [item[1] for item in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    heapq.heappush(heap, (nums1[0] + nums2[0], 0, 0))\n    res = []\n    while k > 0 and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        if j == 0 and i + 1 < len(nums1):\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n        k -= 1\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heappush(heap, (nums1[i] + nums2[0], i, 0))\n\n    result = []\n    while heap and len(result) < k:\n        _, i, j = heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return result",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [(nums1[i], nums2[j]) for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for _ in range(k):\n        if not heap:\n            break\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n\nprint(k_smallest_pairs([1, 7, 11], [2, 4, 6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    heap = []\n    for i in range(len(nums1)):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    while k > 0 and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [heapq.heappop(heap)[1] for _ in range(len(heap))]\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    res = []\n    for i in range(k):\n        res.append(heapq.heappop(heap)[1])\n    return res\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(len(nums1), k)):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            res.append([nums1[i], nums2[j]])\n    res.sort(key=lambda x: x[0] + x[1])\n    return res[:k]\n\n",
    "    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n\n    res = []\n    for _ in range(k):\n        if heap:\n            res.append(heapq.heappop(heap)[1])\n        else:\n            break\n\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    pairs = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            pairs.append([nums1[i], nums2[j]])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [pair[1] for pair in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [heapq.heappop(heap)[1] for _ in range(k)]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]\n",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n\n    res = []\n    for _ in range(k):\n        res.append(heapq.heappop(heap)[1])\n\n    return res\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if len(nums1) * len(nums2) <= k:\n        return [[i, j] for i in nums1 for j in nums2]\n    heap = []\n    for i in range(min(len(nums1), k)):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while k > 0 and heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        k -= 1\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n            else:\n                if -heap[0][0] > nums1[i] + nums2[j]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (-nums1[i] - nums2[j], i, j))\n                else:\n                    break\n    return [[-heap[i][0] - nums2[heap[i][2]], nums2[heap[i][2]]] for i in range(k) if heap[i][1] < len(nums1)]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], [nums1[i], nums2[j]]))\n                else:\n                    break\n    return [x[1] for x in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = [(nums1[0] + nums2[0], 0, 0)]\n    result = []\n    while heap and len(result) < k:\n        _, i, j = heapq.heappop(heap)\n        result.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n        if j == 0 and i + 1 < len(nums1):\n            heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))\n    return result\n\nprint(k_smallest_pairs([1,7,11], [2,4,6], 3))",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(len(nums1), k)):\n        for j in range(min(len(nums2), k)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    if k == 0:\n        return []\n    if k > len(nums1) * len(nums2):\n        k = len(nums1) * len(nums2)\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    res = []\n    while heap:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n    return res\n\n",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    res = []\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    res = []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))\n    while heap and len(res) < k:\n        _, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        if j + 1 < len(nums2):\n            heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))\n    return res",
    "    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(min(k, len(nums1))):\n        for j in range(min(k, len(nums2))):\n            if len(heap) < k:\n                heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n            else:\n                if nums1[i] + nums2[j] < heap[0][0]:\n                    heapq.heappop(heap)\n                    heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n                else:\n                    break\n    return [[nums1[i], nums2[j]] for _, i, j in heap]"
  ]
}