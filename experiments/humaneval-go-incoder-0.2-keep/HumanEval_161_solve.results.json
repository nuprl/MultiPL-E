{
  "language": "go_test.go",
  "name": "HumanEval_161_solve",
  "results": [
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string(letter + 32)\n        } else {\n            result = result + letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4fvgkiap_test.go:23:22: invalid operation: result + letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpei05o5ob_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpei05o5ob_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7t1_skis_test.go:22:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp7t1_skis_test.go:24:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp25fu8nyq_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a') + string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gr0xb7z_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n        } else {\n            result = result + string(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7cfcbqu1_test.go:21:45: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a') + string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gr0xb7z_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))-1])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))-1])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2fzti0a4_test.go:22:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp2fzti0a4_test.go:22:43: undefined: unicode\n/tmp/tmp2fzti0a4_test.go:24:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp2fzti0a4_test.go:24:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxfh11zbf_test.go:23:13: invalid operation: result += r (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]byte{letter + 0x20})\n        } else {\n            result = result + letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1_hnlsvl_test.go:21:45: cannot use letter + 0x20 (value of type rune) as type byte in array or slice literal\n/tmp/tmp1_hnlsvl_test.go:23:22: invalid operation: result + letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn14l9acp_test.go:21:37: cannot use char - 'a' + 'A' (value of type rune) as type byte in array or slice literal\n/tmp/tmpn14l9acp_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n        } else {\n            result = result + string(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7cfcbqu1_test.go:21:45: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp21cwls2y_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp21cwls2y_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a') + string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gr0xb7z_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1:])\n        } else {\n            result += string([]rune(char)[char-'a':])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnc4luth6_test.go:22:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpnc4luth6_test.go:24:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A') + string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkzbcrs9c_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a' + 'A')\n        } else if v >= 'A' && v <= 'Z' {\n            result = result + string(v - 'A' + 'a')\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpclct_a5f_test.go:25:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a') + string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gr0xb7z_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v)\n        } else {\n            result += string(v)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#aSDFw^45', got '#AsdfW^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#$A^d', got '#$a^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxfh11zbf_test.go:23:13: invalid operation: result += r (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))-1])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))-1])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzd_thhqg_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpzd_thhqg_test.go:21:43: undefined: unicode\n/tmp/tmpzd_thhqg_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpzd_thhqg_test.go:23:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp822j0sgw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp822j0sgw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp6jlzqzw_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a' + 1)\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpejjqg27e_test.go:23:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbuupdx5l_test.go:22:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpbuupdx5l_test.go:22:43: undefined: unicode\n/tmp/tmpbuupdx5l_test.go:24:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpbuupdx5l_test.go:24:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == letter.toUpper() {\n            result += letter.toLower()\n        } else {\n            result += letter\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvr_7375v_test.go:21:29: letter.toUpper undefined (type rune has no field or method toUpper)\n/tmp/tmpvr_7375v_test.go:22:30: letter.toLower undefined (type rune has no field or method toLower)\n/tmp/tmpvr_7375v_test.go:24:13: invalid operation: result += letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a') + string(v - 'A')\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7b192i67_test.go:23:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]byte{char - 'a', char - 'A'})\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpati2maa8_test.go:21:37: cannot use char - 'a' (value of type rune) as type byte in array or slice literal\n/tmp/tmpati2maa8_test.go:21:49: cannot use char - 'A' (value of type rune) as type byte in array or slice literal\n/tmp/tmpati2maa8_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhdype1c_test.go:22:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmpnhdype1c_test.go:24:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[int('z'+char-'a')])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbktccqdu_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpbktccqdu_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp0lar4oq_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[strings.Index(strings.ToLower(string([]rune(char))), string([]rune(char))[0])])\n        } else {\n            result += string([]rune(char)[strings.Index(strings.ToUpper(string([]rune(char))), string([]rune(char))[0])])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmiehmtrw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpmiehmtrw_test.go:21:43: undefined: strings\n/tmp/tmpmiehmtrw_test.go:21:87: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpmiehmtrw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpmiehmtrw_test.go:23:43: undefined: strings\n/tmp/tmpmiehmtrw_test.go:23:87: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1])\n        } else {\n            result += string([]rune(char)[char-'A'+1])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsz6pl5fe_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpsz6pl5fe_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpulwo3e1h_test.go:23:30: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result = result + string(v - 'A') + string(v - 'a')\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpukk0a95z_test.go:25:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1])\n        } else {\n            result += string([]rune(char)[char-'A'+1])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu7kb_9ke_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpu7kb_9ke_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += char\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprsbdudlx_test.go:22:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmprsbdudlx_test.go:24:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpywxorkud_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpywxorkud_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpohq1fk8d_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[int('a')-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6g7dd58g_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp6g7dd58g_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result = result + string(v - 'A') + string((len(s) - 1) - int(v - 'A'))\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmjh8tfhp_test.go:25:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A' + 1)\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsqkykakj_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == letter.toUpper() {\n            result += letter.toLower()\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpibxn948__test.go:20:29: letter.toUpper undefined (type rune has no field or method toUpper)\n/tmp/tmpibxn948__test.go:21:30: letter.toLower undefined (type rune has no field or method toLower)\n/tmp/tmpibxn948__test.go:23:13: invalid operation: result += letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn14l9acp_test.go:21:37: cannot use char - 'a' + 'A' (value of type rune) as type byte in array or slice literal\n/tmp/tmpn14l9acp_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpulwo3e1h_test.go:23:30: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))) - 'a' + 'A'])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))) - 'a' + 'A'])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsmrdrrsu_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpsmrdrrsu_test.go:21:43: undefined: unicode\n/tmp/tmpsmrdrrsu_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpsmrdrrsu_test.go:23:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == letter.toUpper() {\n            result += letter.toLower()\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpibxn948__test.go:20:29: letter.toUpper undefined (type rune has no field or method toUpper)\n/tmp/tmpibxn948__test.go:21:30: letter.toLower undefined (type rune has no field or method toLower)\n/tmp/tmpibxn948__test.go:23:13: invalid operation: result += letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfw5mrtw9_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpfw5mrtw9_test.go:21:43: undefined: unicode\n/tmp/tmpfw5mrtw9_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpfw5mrtw9_test.go:23:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n        } else {\n            result = result + string(letter)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7cfcbqu1_test.go:21:45: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)[3:]) + string([]rune(letter)[:3])\n        } else {\n            result = result + letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp483miwtb_test.go:21:45: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp483miwtb_test.go:23:22: invalid operation: result + letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]byte{char - 'a', char - 'A'})\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfcjylex7_test.go:21:37: cannot use char - 'a' (value of type rune) as type byte in array or slice literal\n/tmp/tmpfcjylex7_test.go:21:49: cannot use char - 'A' (value of type rune) as type byte in array or slice literal\n/tmp/tmpfcjylex7_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[1::-1])\n        } else {\n            result += string([]rune(char)[1::-1])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmp2m1ptok0_test.go:21:44: 2nd index required in 3-index slice\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073498
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)])\n        } else {\n            result += string([]rune(char)[int('a')-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3_4nlkb0_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp3_4nlkb0_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpei05o5ob_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpei05o5ob_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result = result + string(v - 'A') + string(v - 'a')\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpukk0a95z_test.go:25:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp25fu8nyq_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxfh11zbf_test.go:23:13: invalid operation: result += r (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            letter = letter + 32\n        } else if letter == 'b' || letter == 'B' {\n            letter = letter - 32\n        } else if letter == 'c' || letter == 'C' {\n            letter = letter + 64\n        } else if letter == 'd' || letter == 'D' {\n            letter = letter - 64\n        } else if letter == 'e' || letter == 'E' {\n            letter = letter + 96\n        } else if letter == 'f' || letter == 'F' {\n            letter = letter - 96\n        } else if letter == 'g' || letter == 'G' {\n            letter = letter + 128\n        } else if letter == 'h' || letter == 'H' {\n            letter = letter - 128\n        } else if letter == 'i' || letter == 'I' {\n            letter = letter + 160\n        } else if letter == 'j' || letter == 'J' {\n            letter = letter - 160\n        } else if letter == 'k' || letter == 'K' {\n            letter = letter + 192\n        } else if letter == 'l' || letter == 'L' {\n            letter = letter - 192\n        } else if letter == 'm' || letter == 'M' {\n            letter = letter + 224\n        } else if letter == 'n' || letter == 'N' {\n            letter = letter - 224\n        } else if letter == 'o' || letter == 'O' {\n            letter = letter + 256\n        } else if letter == 'p' || letter == 'P' {\n            letter = letter - 256\n        } else if letter == 'q' || letter == 'Q' {\n            letter = letter + 260\n        } else if letter == 'r' || letter == 'R' {\n            letter = letter - 260\n        } else if letter == 's' || letter == 'S' {\n            letter = letter + 272\n        } else if letter == 't' || letter == 'T' {\n            letter = letter - 272\n        } else if letter == 'u' || letter == 'U' {\n            letter = letter + 288\n        } else if letter == 'v' || letter == 'V' {\n            letter = letter - 288\n        } else if letter == 'w' || letter == 'W' {\n            letter = letter + 304\n        } else if letter == 'x' || letter == 'X' {\n            letter = letter - 304\n        } else if letter == 'y' || letter == 'Y' {\n            letter = letter + 312\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments\n/tmp/tmplb4gvkih_test.go:71:6: expected '(', found TestSolve\n",
      "stdout": "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n",
      "timestamp": 1660073498
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[strings.Index(strings.ToLower(string([]rune(char))), string([]rune(char)))-1])\n        } else {\n            result += string([]rune(char)[strings.Index(strings.ToUpper(string([]rune(char))), string([]rune(char)))-1])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5lqmu2ns_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp5lqmu2ns_test.go:21:43: undefined: strings\n/tmp/tmp5lqmu2ns_test.go:21:87: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp5lqmu2ns_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp5lqmu2ns_test.go:23:43: undefined: strings\n/tmp/tmp5lqmu2ns_test.go:23:87: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a' - 'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)-('A' - 'A')])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7g5s5jv9_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp7g5s5jv9_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            letter = string(unicode.ToLower(letter))\n        }\n        if letter == 'b' || letter == 'B' {\n            letter = string(unicode.ToUpper(letter))\n        }\n        result += letter\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppnpik9h5_test.go:22:29: undefined: unicode\n/tmp/tmppnpik9h5_test.go:25:29: undefined: unicode\n/tmp/tmppnpik9h5_test.go:27:9: invalid operation: result += letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxfh11zbf_test.go:23:13: invalid operation: result += r (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v)\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmosi50gb_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(unicode.ToLower(v) + unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd9bvm917_test.go:23:30: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfw5mrtw9_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpfw5mrtw9_test.go:21:43: undefined: unicode\n/tmp/tmpfw5mrtw9_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpfw5mrtw9_test.go:23:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)])\n        } else {\n            result += string([]rune(char)[26-int(char)-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqj3se0_1_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpqj3se0_1_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A') + string('A' - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbns9uhif_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8f64fo4j_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp8f64fo4j_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp25fu8nyq_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[int('z'+char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5r1cq233_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp5r1cq233_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a') + string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9gr0xb7z_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n        } else {\n            result = result + string(letter)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpoldzwcfo_test.go:22:45: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhdype1c_test.go:22:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmpnhdype1c_test.go:24:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == letter.toUpper() {\n            result += letter.toLower()\n        } else {\n            result += letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpibxn948__test.go:20:29: letter.toUpper undefined (type rune has no field or method toUpper)\n/tmp/tmpibxn948__test.go:21:30: letter.toLower undefined (type rune has no field or method toLower)\n/tmp/tmpibxn948__test.go:23:13: invalid operation: result += letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[int('z'+char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5r1cq233_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp5r1cq233_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v)\n        } else {\n            result += string(v)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected 'aSdF', got 'AsDf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#A@c', got '#a@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#aSDFw^45', got '#AsdfW^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#$A^d', got '#$a^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpy6mgg8vk_test.go:51: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpvs9geqtq_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpvs9geqtq_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)[3:] + []rune(letter)[:3])\n        } else {\n            result = result + letter\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb3fqv_xe_test.go:22:45: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmpb3fqv_xe_test.go:24:22: invalid operation: result + letter (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)])\n        } else if char >= 'A' && char <= 'Z' {\n            result += string([]rune(char)[26-int(char)])\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1m5kii79_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp1m5kii79_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp1m5kii79_test.go:25:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v) + string(v)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected 'aSdF', got 'AAsDDf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected '4321', got '11223344'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected '#A@c', got '##a@@CC'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected '#aSDFw^45', got '##AAsdfWW^^4455'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected '2@6#', got '##66@@22'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected '#$A^d', got '##$$a^^DD'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmp7wmtsm0h_test.go:49: expected '#CCC', got '##ccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_461ic8i_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)[3:])\n        } else {\n            result += string([]rune(letter)[:3])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyba5pw6u_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmpyba5pw6u_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[strings.Index(strings.ToLower(string([]rune(char))), string([]rune(char))[0])])\n        } else {\n            result += string([]rune(char)[strings.Index(strings.ToUpper(string([]rune(char))), string([]rune(char))[0])])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmiehmtrw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpmiehmtrw_test.go:21:43: undefined: strings\n/tmp/tmpmiehmtrw_test.go:21:87: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpmiehmtrw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpmiehmtrw_test.go:23:43: undefined: strings\n/tmp/tmpmiehmtrw_test.go:23:87: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[strings.Index(strings.ToLower(string([]rune(char))), string([]rune(char))[0])])\n        } else {\n            result += string([]rune(char)[strings.Index(strings.ToUpper(string([]rune(char))), string([]rune(char))[0])])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphj88bq08_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmphj88bq08_test.go:21:43: undefined: strings\n/tmp/tmphj88bq08_test.go:21:87: cannot convert char (variable of type rune) to type []rune\n/tmp/tmphj88bq08_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmphj88bq08_test.go:23:43: undefined: strings\n/tmp/tmphj88bq08_test.go:23:87: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8f64fo4j_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp8f64fo4j_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpn14l9acp_test.go:21:37: cannot use char - 'a' + 'A' (value of type rune) as type byte in array or slice literal\n/tmp/tmpn14l9acp_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A') + string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkzbcrs9c_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A' + 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc_nuw4mn_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfw5mrtw9_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpfw5mrtw9_test.go:21:43: undefined: unicode\n/tmp/tmpfw5mrtw9_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpfw5mrtw9_test.go:23:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[int('z'-char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkf4m980w_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpkf4m980w_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073500
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp21cwls2y_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp21cwls2y_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxfh11zbf_test.go:23:13: invalid operation: result += r (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnhdype1c_test.go:22:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmpnhdype1c_test.go:24:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[int('z'+char-'a')])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbktccqdu_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpbktccqdu_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1])\n        } else {\n            result += char\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpijs3jeho_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpijs3jeho_test.go:23:13: invalid operation: result += char (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073500
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A') + string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkzbcrs9c_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1])\n        } else {\n            result += string([]rune(char)[char-'A'+1])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsz6pl5fe_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpsz6pl5fe_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpei05o5ob_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpei05o5ob_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result = result + string(v - 'a' + 1)\n        } else {\n            result = result + v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpejjqg27e_test.go:23:22: invalid operation: result + v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0zd4scd_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpr0zd4scd_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbuupdx5l_test.go:22:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpbuupdx5l_test.go:22:43: undefined: unicode\n/tmp/tmpbuupdx5l_test.go:24:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpbuupdx5l_test.go:24:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcmebwa42_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n        } else {\n            result += string([]rune(letter)...)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0_02sgzq_test.go:21:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmp0_02sgzq_test.go:23:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <= 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxfh11zbf_test.go:23:13: invalid operation: result += r (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjqjskmag_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpjqjskmag_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7co39lyf_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[int('a')-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6g7dd58g_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp6g7dd58g_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpohq1fk8d_test.go:23:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter == 'a' || letter == 'A' {\n            result += string([]rune(letter)[3:])\n        } else {\n            result += string([]rune(letter))\n        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp2orn4dx_test.go:22:37: cannot convert letter (variable of type rune) to type []rune\n/tmp/tmpp2orn4dx_test.go:24:37: cannot convert letter (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073500
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))) - 'a' + 'A'])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))) - 'a' + 'A'])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsmrdrrsu_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpsmrdrrsu_test.go:21:43: undefined: unicode\n/tmp/tmpsmrdrrsu_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmpsmrdrrsu_test.go:23:43: undefined: unicode\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073499
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' && v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxsp1ppa_test.go:25:13: invalid operation: result += v (mismatched types string and rune)\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n        } else {\n            result += string([]rune(char)[26-int(char-65)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4mqo28hw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp4mqo28hw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 1,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <= 'z' {\n            result += string(v)\n        } else {\n            result += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "Exception",
      "stderr": "",
      "stdout": "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1 (0.00s)\n        tmprix3mhcp_test.go:49: expected '4321', got 'QRST'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmprix3mhcp_test.go:49: expected 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#aSDFw^45', got 'Casdfw~TU'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n        tmprix3mhcp_test.go:49: expected '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmprix3mhcp_test.go:49: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n",
      "timestamp": 1660073494
    },
    {
      "exit_code": 2,
      "program": "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You are given a string s.\n// if s[i] is a letter, reverse its case from lower to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains no letters, reverse the string.\n// The function should return the resulted string.\n// Examples\n// solve(\"1234\") = \"4321\"\n// solve(\"ab\") = \"AB\"\n// solve(\"#a@C\") = \"#A@c\"\nfunc solve(s string) string {\n    var result string\n    for _, char := range s {\n        if char >= 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n",
      "status": "SyntaxError",
      "stderr": "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp822j0sgw_test.go:21:37: cannot convert char (variable of type rune) to type []rune\n/tmp/tmp822j0sgw_test.go:23:37: cannot convert char (variable of type rune) to type []rune\n",
      "stdout": "FAIL\tcommand-line-arguments [build failed]\nFAIL\n",
      "timestamp": 1660073496
    }
  ]
}