name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n;; >>> (count_upper \"aBCdEf\")\n;; 1\n;; >>>\
  \ (count_upper \"abcdefg\")\n;; 0\n;; >>> (count_upper \"dBBE\")\n;; 0\n(define\
  \ (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (let loop ((s s)\n             (count 0))\n    (cond\n      [(empty?\
    \ s) count]\n      [(char-upper? (car s)) (loop (cdr s) (+ count 1))]\n      [else\
    \ (loop (cdr s) count)])))\n", "  (let loop ((s s)\n             (count 0))\n\
    \    (cond\n      [(empty? s) count]\n      [(char-upper? (car s)) (loop (cdr\
    \ s) (+ count 1))]\n      [else (loop (cdr s) count)])))\n", "  (let loop ((s\
    \ s)\n             (count 0))\n    (cond\n      [(empty? s) count]\n      [(char-upper?\
    \ (car s)) (loop (cdr s) (+ count 1))]\n      [else (loop (cdr s) count)])))\n",
  "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) (+ 1 (count (char s #\\U)\
    \ '#\\U))]\n    [else (count_upper (rest s))]))\n", "  (let loop ((s s)\n    \
    \         (count 0))\n    (cond ((or (char-upper? (char-code (car s))) #f)\n \
    \          (loop (cdr s) count))\n          ((char-upper? (char-code (car s)))\
    \ (loop (cdr s) (add1 count)))\n          (else (loop (cdr s) count))))\n  count)\n",
  "  (let ((count 0))\n    (for ([i (in-range (length s))])\n      (if (even? i)\n\
    \          (if (char-upper? (char s i))\n              (set! count (+ count 1))\n\
    \              (set! count 0)))))\n  count)\n", "  (let loop ((s s)\n        \
    \     (count 0))\n    (cond ((char=? s #\\a) (add1 count))\n          ((char=?\
    \ s #\\e) (add1 count))\n          ((char=? s #\\i) (add1 count))\n          ((char=?\
    \ s #\\o) (add1 count))\n          ((char=? s #\\u) (add1 count))\n          ((char=?\
    \ s #\\A) (add1 count))\n          ((char=? s #\\E) (add1 count))\n          ((char=?\
    \ s #\\I) (add1 count))\n          ((char=? s #\\O) (add1 count))\n          ((char=?\
    \ s #\\U) (add1 count))\n          ((char=? s #\\a) (add1 count))\n          ((char=?\
    \ s #\\e) (add1 count))\n          ((char=? s #\\i) (add1 count))\n          ((char=?\
    \ s #\\o) (add1 count))\n          ((char=? s #\\u) (add1 count))\n          ((char=?\
    \ s #\\A) (add1 count))\n          ((char=? s #\\E) (add1 count))\n          ((char=?\
    \ s #\\I) (add1 count))\n          ((char=? s #\\O) (add1 count))\n          ((char=?\
    \ s #\\U) (add1 count))\n          ((char=? s #\\a) (add1 count))\n          ((char=?\
    \ s #\\e) (add1 count))\n          ((char=? s #\\i) (add1 count))\n          ((char=?\
    \ s #\\o) (add1 count))\n          ((char=? s #\\u) (add1 count))\n          ((char=?\
    \ s #\\A) (add1 count))\n          ((char=? s #\\E) (add1 count))\n          ((char=?\
    \ s #\\I) (add1 count))\n          ((char=? s #\\O) (add1 count))\n          ((char=?\
    \ s #\\U) (add1 count))\n          ((char=? s #\\a) (add1 count))\n          ((char=?\
    \ s #\\e) (add1 count))\n          ((char=? s #\\i) (add1 count))\n          ((char=?\
    \ s #\\o) (add1 count))\n          ((char=? s #\\u) (add1 count))\n          ((char=?\
    \ s #\\", "  (let ((count 0))\n    (for ([i (in-range (length s))])\n      (if\
    \ (even? i)\n          (if (char-upper? (char s i))\n              (set! count\
    \ (add1 count))\n              (set! count 0))))))\n", "  (let loop ((s s)\n \
    \            (count 0))\n    (cond\n      [(empty? s) count]\n      [(char-upper?\
    \ (car s)) (loop (cdr s) (+ count 1))]\n      [else (loop (cdr s) count)])))\n",
  "  (let loop ((i 0) (count 0))\n    (if (< i (length s))\n        (if (char=? (char-code\
    \ (char s i)) #\\A)\n            (loop (+ i 2) (+ count 1))\n            (loop\
    \ (+ i 2) count))\n        count)))\n", "  (cond\n    [(empty? s) 0]\n    [(even?\
    \ (length s)) (+ 1 (count (char s #\\U) '()))]\n    [else (+ 1 (count_upper (rest\
    \ s)))]))\n", "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) (+ 1 (count\
    \ (char #\\U (first s)) (first s)))]\n    [else (count_upper (rest s))]))\n",
  "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) (+ 1 (count (char #\\U) s))]\n\
    \    [else (count_upper (rest s))]))\n", "  (let loop ((s s)\n             (count\
    \ 0))\n    (cond\n      [(empty? s) count]\n      [(char-upper? (car s)) (loop\
    \ (cdr s) (+ count 1))]\n      [else (loop (cdr s) count)])))\n", "  (let ((count\
    \ 0))\n    (for ([i (in-range (length s))])\n      (if (even? i)\n          (if\
    \ (char-upper? (char s i))\n              (set! count (add1 count))\n        \
    \      (set! count 0))))))\n", "  (cond\n    [(empty? s) 0]\n    [(even? (length\
    \ s)) (+ 1 (count-vowels (substring s 0 (- 2 (length s)))))]\n    [else (count-vowels\
    \ (substring s 0 (- 2 (length s))))]))\n", "  (cond\n    [(empty? s) 0]\n    [(even?\
    \ (length s)) (+ 1 (count (char #\\A s) (char #\\A s)))]\n    [else (count_upper\
    \ (rest s))]))\n", "  (cond\n    [(empty? s) 0]\n    [(even? (length s)) (+ 1\
    \ (count-upper (substring s 0 2)))]\n    [else (count-upper (substring s 0 1))]))\n",
  "  (let loop ((s s)\n             (count 0))\n    (cond ((string=? s \"\")\n   \
    \        (if (zero? count)\n               0\n               (+ 1 (loop (substring\
    \ s 0 (length s) #\\Upcase) (add1 count))))\n           (loop (substring s 0 (length\
    \ s) #\\Upcase) (add1 count))))))\n", "  (let ((count 0))\n    (for ([i (in-range\
    \ (length s))])\n      (if (even? i)\n          (if (char=? (char-code (char s\
    \ i)) #\\A)\n              (add1 count)\n              (add1 0))\n          (add1\
    \ 0)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
