name: HumanEval_101_words_string
language: rkt
prompt: "#lang racket\n\n;; You will be given a string of words separated by commas\
  \ or spaces. Your task is\n;; to split the string into words and return a list of\
  \ the words.\n;; For example:\n;; >>> (words_string \"Hi, my name is John\")\n;;\
  \ (list \"Hi\" \"my\" \"name\" \"is\" \"John\")\n;; >>> (words_string \"One, two,\
  \ three, four, five, six\")\n;; (list \"One\" \"two\" \"three\" \"four\" \"five\"\
  \ \"six\")\n(define (words_string s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate words_string))\n\
  \    (check-equal? (candidate \"Hi, my name is John\") (list \"Hi\" \"my\" \"name\"\
  \ \"is\" \"John\"))\n    (check-equal? (candidate \"One, two, three, four, five,\
  \ six\") (list \"One\" \"two\" \"three\" \"four\" \"five\" \"six\"))\n    (check-equal?\
  \ (candidate \"Hi, my name\") (list \"Hi\" \"my\" \"name\"))\n    (check-equal?\
  \ (candidate \"One,, two, three, four, five, six,\") (list \"One\" \"two\" \"three\"\
  \ \"four\" \"five\" \"six\"))\n    (check-equal? (candidate \"\") (list ))\n   \
  \ (check-equal? (candidate \"ahmed     , gamal\") (list \"ahmed\" \"gamal\"))\n\
  ))\n\n(test-humaneval)"
completions: ["  (let loop ((s s)\n             (words nil))\n    (if (string-empty?\
    \ s)\n        (reverse words)\n        (loop (substring s 0 (string-length s))\n\
    \              (cons (substring s 0 (string-length s)) words)))))\n", "  (let\
    \ loop ((s s)\n             (acc '()))\n    (if (empty? s)\n        (reverse acc)\n\
    \        (loop (rest s)\n              (cons (first s) acc)))))\n", "  (let ([words\
    \ (string-split s #\",\" #\" \")])\n    (map list words words)))\n", "  (let ([words\
    \ (string-split s #\",\" #\" \")])\n    (map list words words)))\n", "  (let ([words\
    \ (string-split s #\",\" #\" \")])\n    (list words)))\n", "  (let loop ((s s)\n\
    \             (acc '()))\n    (cond\n      [(empty? s) (list acc)]\n      [else\n\
    \       (let ((word (first s)))\n         (loop (rest s)\n               (cons\
    \ word acc))]))))\n", "  (let loop ((s s)\n             (acc '()))\n    (cond\n\
    \      [(empty? s) (list acc)]\n      [(char=? (first s) ',') (loop (rest s) (cons\
    \ acc '()))]\n      [(char=? (first s) '-) (loop (rest s) (cons acc '()))]\n \
    \     [else (loop (rest s) (cons (first s) acc))]))))\n", "  (let ([words (string-split\
    \ s #\",\" #\" \")])\n    (map list words words)))\n", "  (let ([words (string-split\
    \ s #\",\" #\" \")])\n    (map list words words)))\n", "  (let loop ((s s)\n \
    \            (acc '()))\n    (if (string-empty? s)\n        (reverse acc)\n  \
    \      (loop (substring s 0 (string-length s))\n              (cons (substring\
    \ s 0 (string-length s)) acc)))))\n", "  (let loop ((s s)\n             (acc '()))\n\
    \    (if (string-empty? s)\n        (reverse acc)\n        (loop (substring s\
    \ 0 (string-length s))\n              (cons (substring s 0 (string-length s))\
    \ acc)))))\n", "  (let loop ((s s)\n             (acc '()))\n    (if (string-empty?\
    \ s)\n        (reverse acc)\n        (loop (substring s 0 (string-length s))\n\
    \              (cons (substring s 0 (string-length s)) acc)))))\n", "  (let ([words\
    \ (string-split s #\",\" #\" \")])\n    (map list words words)))\n", "  (let ([chars\
    \ (string->chars s)])\n    (if (null? chars)\n        '()\n        (append (map\
    \ (lambda (c) (if (char=? c #\\, #\\Space) '() c)) chars)\n                (words_string\
    \ (string-append (substring s 0 (string-length s))))))))\n", "  (let ([words (string->list\
    \ s)])\n    (map list words)))\n", "  (let ([words (string-split s #\",\" #\"\
    \ \")])\n    (map list words words)))\n", "  (let loop ((s s)\n             (acc\
    \ '()))\n    (if (empty? s)\n        acc\n        (loop (rest s)\n           \
    \   (cons (first s)\n                    (loop (rest s)\n                    \
    \      acc))))))\n", "  (let ([words (string->list s)])\n    (map list words (substring\
    \ s 0 (string-length s)))))\n", "  (let loop ((s s)\n             (acc '()))\n\
    \    (if (empty? s)\n        (reverse acc)\n        (loop (rest s)\n         \
    \     (cons (first s) acc)))))\n", "  (let ([chars (string->list (string-split\
    \ s #\",\"))])\n    (map (lambda (c) (cons (string->symbol (c)) (list c))) chars)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
