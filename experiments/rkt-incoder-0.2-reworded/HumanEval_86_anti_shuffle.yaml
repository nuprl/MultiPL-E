name: HumanEval_86_anti_shuffle
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a string and returns an ordered\
  \ version of it.\n;; Ordered version of string, is a string where all words (separated\
  \ by space)\n;; are replaced by a new word where all the characters arranged in\n\
  ;; ascending order based on ascii value.\n;; Note: You should keep the order of\
  \ words and blank spaces in the sentence.\n;; For example:\n;; >>> (anti_shuffle\
  \ \"Hi\")\n;; \"Hi\"\n;; >>> (anti_shuffle \"hello\")\n;; \"ehllo\"\n;; >>> (anti_shuffle\
  \ \"Hello World!!!\")\n;; \"Hello !!!Wdlor\"\n(define (anti_shuffle s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate anti_shuffle))\n\
  \    (check-equal? (candidate \"Hi\") \"Hi\")\n    (check-equal? (candidate \"hello\"\
  ) \"ehllo\")\n    (check-equal? (candidate \"number\") \"bemnru\")\n    (check-equal?\
  \ (candidate \"abcd\") \"abcd\")\n    (check-equal? (candidate \"Hello World!!!\"\
  ) \"Hello !!!Wdlor\")\n    (check-equal? (candidate \"\") \"\")\n    (check-equal?\
  \ (candidate \"Hi. My name is Mister Robot. How are you?\") \".Hi My aemn is Meirst\
  \ .Rboot How aer ?ouy\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? s) s]\n    [(equal? (first s) (last s)) (anti_shuffle\
    \ (rest s))]\n    [else (cons (first s)\n                (anti_shuffle (rest s)))]))\n",
  "  (let loop ((s s)\n             (res \"\")\n             (i 0))\n    (if (null?\
    \ s)\n        (reverse res)\n        (loop (cdr s)\n              (cons (char->integer\
    \ (char->string (car s))) res)\n              (incf i))))))\n", "  (cond\n   \
    \ [(empty? s) s]\n    [(equal? (first s) (last s)) (anti_shuffle (rest s))]\n\
    \    [else (cons (first s) (anti_shuffle (rest s)))]))\n", "  (cond\n    [(empty?\
    \ s) s]\n    [(equal? (first s) (last s)) (anti_shuffle (rest s))]\n    [else\
    \ (cons (first s)\n                (anti_shuffle (rest s)))]))\n", "  (cond [(empty?\
    \ s) s]\n        [(equal? (first s) (last s)) (anti_shuffle (rest s))]\n     \
    \   [else (cons (first s)\n                    (anti_shuffle (rest s)))]))\n",
  "  (cond\n    [(empty? s) s]\n    [(equal? (first s) (last s)) (anti_shuffle (rest\
    \ s))]\n    [else (cons (first s)\n                (anti_shuffle (rest s)))]))\n",
  "  (let ((chars (string->list s)))\n    (string-append (map anti-shuffle chars)\n\
    \                   (string->list s))))\n", "  (cond\n    [(empty? s) s]\n   \
    \ [(equal? (first s) (last s)) (anti_shuffle (rest s))]\n    [else (cons (first\
    \ s)\n                (anti_shuffle (rest s)))]))\n", "  (cond [(empty? s) s]\n\
    \        [(equal? (first s) (last s)) (anti_shuffle (rest s))]\n        [else\
    \ (cons (first s)\n                    (anti_shuffle (rest s)))]))\n", "  (if\
    \ (empty? s)\n      '()\n      (append (anti_shuffle (first s))\n            \
    \  (list (first s))\n              (anti_shuffle (rest s)))))\n", "  (cond [(empty?\
    \ s) s]\n        [(empty? (rest s)) (cons (first s) (cons (first s) empty))]\n\
    \        [else (cons (first s)\n                    (anti_shuffle (rest s))\n\
    \                    (anti_shuffle (cons (first s) empty)))]))\n", "  (if (empty?\
    \ s)\n      '()\n      (append (anti_shuffle (substring s 0 (string-length s)))\n\
    \              (list (substring s (string-length s) 0)))))\n", "  (let ([chars\
    \ (string->list (string->string s))])\n    (cond\n      [(empty? chars) s]\n \
    \     [(equal? (first chars) (last chars)) (anti_shuffle (substring s 0 (- (length\
    \ s) 1)))]\n      [else (cons (first chars) (anti_shuffle (substring s 1 (- (length\
    \ s) 1)))])])))\n", "  (cond\n    [(empty? s) s]\n    [(equal? (first s) (last\
    \ s)) (anti_shuffle (rest s))]\n    [else (cons (first s)\n                (anti_shuffle\
    \ (rest s)))]))\n", "  (let ([chars (string->list (string->string s))])\n    (cond\n\
    \      [(empty? chars) s]\n      [(string->char (first chars)) (anti_shuffle (second\
    \ chars))]\n      [(string->char (second chars)) (anti_shuffle (first chars))]\n\
    \      [else (cons (string->char (first chars)) (anti_shuffle (second chars)))])))\n",
  "  (cond\n    [(empty? s) s]\n    [(equal? (first s) (last s)) (anti_shuffle (rest\
    \ s))]\n    [else (cons (first s)\n                (anti_shuffle (rest s)))]))\n",
  "  (cond\n    [(empty? s) s]\n    [(equal? (first s) (last s)) (anti_shuffle (rest\
    \ s))]\n    [else (cons (first s)\n                (anti_shuffle (rest s)))]))\n",
  "  (if (empty? s)\n      '()\n      (append (anti_shuffle (rest (split-string (first\
    \ s) #\\Space))) (list (first s)))))\n", "  (cond\n    [(empty? s) s]\n    [(equal?\
    \ (first s) (last s)) (anti_shuffle (rest s))]\n    [else (cons (first s)\n  \
    \              (anti_shuffle (rest s)))]))\n", "  (let ([chars (string->list (string->string\
    \ s))])\n    (cond\n      [(empty? chars) s]\n      [(string->char (first chars))\
    \ (anti_shuffle (second chars))]\n      [else (cons (string->char (first chars))\
    \ (anti_shuffle (second chars)))])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
