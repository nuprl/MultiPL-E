name: HumanEval_58_common
language: rkt
prompt: "#lang racket\n\n;; Return sorted unique common elements for two lists.\n\
  ;; >>> (common (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\n;; (list 1 5 653)\n\
  ;; >>> (common (list 5 3 2 8) (list 3 2))\n;; (list 2 3)\n(define (common l1 l2)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate common))\n\
  \    (check-equal? (candidate (list 1 4 3 34 653 2 5) (list 5 7 1 5 9 653 121))\
  \ (list 1 5 653))\n    (check-equal? (candidate (list 5 3 2 8) (list 3 2)) (list\
  \ 2 3))\n    (check-equal? (candidate (list 4 3 2 8) (list 3 2 4)) (list 2 3 4))\n\
  \    (check-equal? (candidate (list 4 3 2 8) (list )) (list ))\n))\n\n(test-humaneval)"
completions: ["  (cond [(null? l1) l2]\n        [(member (car l1) l2) (common (cdr\
    \ l1) l2)]\n        [else (common (cdr l1) l2)]))\n", "  (sort (remove-duplicates\
    \ \n          (remove-if-not (lambda (x) (equal? x l1)) l2)) \n        (lambda\
    \ (x) (equal? x l1))))\n", "  (let ((l1 (sort l1 '<))\n        (l2 (sort l2 '<)))\n\
    \    (cond ((null? l1) l2)\n          ((null? l2) l1)\n          (else (and (equal?\
    \ (first l1) (first l2))\n                    (common (rest l1) (rest l2))))))))\n",
  "  (let ([l1 (sort l1 '<)\n         l2 (sort l2 '<)])\n    (if (null? l1)\n    \
    \    (reverse l2)\n        (if (null? l2)\n            (reverse l1)\n        \
    \    (if (equal? (first l1) (first l2))\n                (common (rest l1) (rest\
    \ l2))\n                (common (first l1) (rest l2))))))))\n", "  (cond\n   \
    \ [(empty? l1) l2]\n    [(empty? l2) l1]\n    [(equal? (first l1) (first l2))\
    \ (common (rest l1) (rest l2))]\n    [else (cons (first l1) (common (rest l1)\
    \ (rest l2)))]))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2) l1]\n  \
    \  [(equal? (first l1) (first l2)) (common (rest l1) (rest l2))]\n    [else (cons\
    \ (first l1) (common (rest l1) (rest l2)))]))\n", "  (sort (remove-duplicates\
    \ \n          (remove-if-not (lambda (x) (equal? (first l1) x)) l2)\n        \
    \  l1)\n        >\n        >\n        >\n        >\n        >\n        >\n   \
    \     >\n        >\n        >\n        >\n        >\n        >\n        >\n  \
    \      >\n        >\n        >\n        >\n        >\n        >\n        >\n \
    \       >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >\n\
    \        >\n        >\n        >\n        >\n        >\n        >\n        >",
  "  (cond [(empty? l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1)\
    \ (first l2)) (common (rest l1) (rest l2))]\n        [else (cons (first l1) (common\
    \ (rest l1) l2))]))\n", "  (sort (remove-duplicates \n          (remove-if-not\
    \ (lambda (x) (equal? (first l1) x)) l2)\n          l1)))\n", "  (sort (remove-duplicates\
    \ \n          (remove-if-not (lambda (x) (equal? (first l1) x)) l2)\n        \
    \  (remove-if-not (lambda (x) (equal? (first l2) x)) l1))))\n", "  (sort (remove-duplicates\
    \ \n          (remove-if-not (lambda (x) (equal? (first l1) x)) l2)\n        \
    \  l1)\n        >\n        (lambda (x) (equal? (first l1) x))))\n", "  (cond\n\
    \    [(empty? l1) l2]\n    [(empty? l2) l1]\n    [(equal? (first l1) (first l2))\
    \ (common (rest l1) (rest l2))]\n    [else (cons (first l1) (common (rest l1)\
    \ (rest l2)))]))\n", "  (let ((l1 (sort l1 <))\n        (l2 (sort l2 <)))\n  \
    \  (cond ((null? l1) l2)\n          ((null? l2) l1)\n          (else (and (equal?\
    \ (first l1) (first l2))\n                    (common (rest l1) (rest l2))))))))\n",
  "  (cond [(empty? l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1)\
    \ (first l2)) (common (rest l1) (rest l2))]\n        [else (cons (first l1) (common\
    \ (rest l1) (rest l2)))]))\n", "  (cond\n    [(empty? l1) l2]\n    [(empty? l2)\
    \ l1]\n    [(equal? (first l1) (first l2)) (common (rest l1) (rest l2))]\n   \
    \ [else (cons (first l1) (common (rest l1) (rest l2)))]))\n", "  (sort (remove-duplicates\
    \ \n          (remove-if-not (lambda (x) (equal? (first l1) x)) \n           \
    \            (remove-if-not (lambda (x) (equal? (first l2) x)) \n            \
    \                          l1))\n          (remove-if-not (lambda (x) (equal?\
    \ (first l2) x)) \n                       l2))))\n", "  (let ((l1 (sort l1 '<))\n\
    \        (l2 (sort l2 '<))\n        (result '()))\n    (if (null? l1)\n      \
    \  result\n        (if (null? l2)\n            result\n            (if (equal?\
    \ (first l1) (first l2))\n                (common (rest l1) (rest l2))\n     \
    \           (common (first l1) (rest l2))))))))\n", "  (sort (remove-duplicates\
    \ \n          (remove-if-not (lambda (x) (equal? (first l1) x)) l2)\n        \
    \  (remove-if-not (lambda (x) (equal? (first l2) x)) l1))))\n", "  (cond [(empty?\
    \ l1) l2]\n        [(empty? l2) l1]\n        [(equal? (first l1) (first l2)) (common\
    \ (rest l1) (rest l2))]\n        [else (cons (first l1) (common (rest l1) (rest\
    \ l2)))]))\n", "  (sort (remove-duplicates \n          (remove-if-not (lambda\
    \ (x) (equal? (first l1) x)) l2)\n          l1)\n        (lambda (x y) (equal?\
    \ (first l1) y))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
