name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let ([num (string->number (car value))])\n    (cond\n      [(< num\
    \ 0) (error \"Invalid input: number must be positive.\")]\n      [(< num 1) (error\
    \ \"Invalid input: number must be positive.\")]\n      [else (ceiling (- num (floor\
    \ (/ num 1)))])))\n", "  (let ([num (parse-integer value)]\n        [min (parse-integer\
    \ \"0\")])\n    (cond [(< num min) (parse-integer \"0\")]\n          [(< num 0)\
    \ (parse-integer \"0\")]\n          [(< num num) (parse-integer \"0\")]\n    \
    \      [else (parse-integer num)]))))\n", "  (let ([num (number->string value)]\n\
    \        [nums (number->list value)]\n        [min (number->string 0)]\n     \
    \   [max (number->string 0)])\n    (if (null? nums)\n        min\n        (let\
    \ ([num (first nums)])\n          (if (< (number->string num) min)\n         \
    \     (let ([num (number->string num)])\n                (if (< (number->string\
    \ num) max)\n                    (let ([min (number->string num)])\n         \
    \             (if (< (number->string num) num)\n                          (let\
    \ ([max (number->string num)])\n                            (if (< (number->string\
    \ num) min)\n                                (let ([num (number->string num)])\n\
    \                                  (if (< (number->string num) max)\n        \
    \                              (let ([min (number->string num)])\n           \
    \                             (if (< (number->string num) num)\n             \
    \                               (let ([max (number->string num)])\n          \
    \                                    (if (< (number->string num) min)\n      \
    \                                            (let ([num (number->string num)])\n\
    \                                                    (if (< (number->string num)\
    \ max)\n                                                        (let ([min (number->string\
    \ num)])\n                                                          (if (< (number->string\
    \ num) num)\n                                                              (let\
    \ ([max (number->string num)])\n                                             \
    \                   (if (< (number->string num) min)\n                       \
    \                                             (let ([num (number->string num)])\n\
    \                                                                      (if (<\
    \ (number->string num) max)\n                                                \
    \                          (let ([min (number->string num)])\n               \
    \                                                             (if (< (number->string\
    \ num) num)\n                                                                \
    \                (let ([max (number->string num)])\n                         \
    \                                                         (if (< (number->string\
    \ num) min)\n                                                                \
    \                      (let ([num (number->string num)])\n                   \
    \                                                                     (if (< (number->string\
    \ num) max)\n                                                                \
    \                            (let ([min (number->string num)])\n             \
    \                                                                            \
    \     (if (< (number->string num) num)\n                                     \
    \                                                             (let ([max (number->string\
    \ num)])\n                                                                   \
    \                                 (if (< (number->string num) min)\n         \
    \                                                                            \
    \                   (let ([num (number->string num)])\n                      \
    \                                                                            \
    \        (if (< (number->string num) max)\n                                  \
    \                                                                            (let\
    \ ([min (number->string num)])\n                                             \
    \                                                                   (if (< (number->string\
    \ num) num)\n                                                                \
    \                                                    (let ([max (number->string\
    \ num)])\n                                                                   \
    \                                                   (if (< (number->string num)\
    \ min)\n                                                                     \
    \                                                     (let ([num (number->string\
    \ num)])\n                                                                   \
    \                                                         (if (< (number", " \
    \ (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr\
    \ value))])\n      (if (and (number? x) (number? y))\n          (if (< (abs (-\
    \ x y)) 1)\n              (ceiling x)\n              (floor (- x y)))\n      \
    \    (if (< (abs (- x y)) 1)\n              (ceiling y)\n              (floor\
    \ (- x y))))))))\n", "  (let ([num (number->string value)]\n        [nums (number->list\
    \ value)]\n        [min (min nums)]\n        [max (max nums)])\n    (cond\n  \
    \    [(empty? nums) value]\n      [(< (length nums) 1) (min nums)]\n      [(<\
    \ (length nums) 2) (min nums)]\n      [(< (length nums) 3) (min nums)]\n     \
    \ [(< (length nums) 4) (min nums)]\n      [(< (length nums) 5) (min nums)]\n \
    \     [(< (length nums) 6) (min nums)]\n      [(< (length nums) 7) (min nums)]\n\
    \      [(< (length nums) 8) (min nums)]\n      [(< (length nums) 9) (min nums)]\n\
    \      [(< (length nums) 10) (min nums)]\n      [(< (length nums) 11) (min nums)]\n\
    \      [(< (length nums) 12) (min nums)]\n      [(< (length nums) 13) (min nums)]\n\
    \      [(< (length nums) 14) (min nums)]\n      [(< (length nums) 15) (min nums)]\n\
    \      [(< (length nums) 16) (min nums)]\n      [(< (length nums) 17) (min nums)]\n\
    \      [(< (length nums) 18) (min nums)]\n      [(< (length nums) 19) (min nums)]\n\
    \      [(< (length nums) 20) (min nums)]\n      [(< (length nums) 21) (min nums)]\n\
    \      [(< (length nums) 22) (min nums)]\n      [(< (length nums) 23) (min nums)]\n\
    \      [(< (length nums) 24) (min nums)]\n      [(< (length nums) 25) (min nums)]\n\
    \      [(< (length nums) 26) (min nums)]\n      [(< (length nums) 27) (min nums)]\n\
    \      [(< (length nums) 28) (min nums)]\n      [(< (length nums) 29) (min nums)]\n\
    \      [(< (length nums) 30) (min nums)]\n      [(< (length nums) 31) (min nums)]\n\
    \      [(< (length nums) 32) (min nums)]\n      [(< (length nums) 33) (min nums)]\n\
    \      [(< (length nums) 34) (min nums)]\n      [(< (length nums) 35) (min nums)]\n\
    \      [(< (length nums) 36) (min nums)]\n      [(< (length nums) 37) (min nums)]\n\
    \      [(< (length nums) 38) (min nums)]\n      [(< (length nums) 39) (min num",
  "  (let ([int-value (string->number value)]\n        [int-min (string->number '-inf)]\n\
    \        [int-max (string->number '+inf)])\n    (cond\n      [(< int-value int-min)\n\
    \       (string->number '-inf)]\n      [(< int-value int-max)\n       (string->number\
    \ '+inf)]\n      [else\n       (+ int-value int-min)]))))\n", "  (let ([integers\
    \ (map number->integer '(10 20 30 40 50 60 70 80 90 100))])\n    (let ([closest\
    \ (car integers)])\n      (if (< (abs (- value closest)) (abs (- value (cdr integers))))\n\
    \          closest\n          (closest_integer (- value (cdr integers)))))))\n",
  "  (let ([integer (parse-integer value)]\n        [integers (list integer)]\n  \
    \      [closest (car integers)])\n    (if (< (cdr integers) integer)\n       \
    \ (let ([new (+ integer 1)])\n          (if (< (cdr integers) new)\n         \
    \     (let ([new (+ new 1)])\n                (if (< (cdr integers) new)\n   \
    \                 (let ([new (+ new 1)])\n                      (if (< (cdr integers)\
    \ new)\n                          (let ([new (+ new 1)])\n                   \
    \         (if (< (cdr integers) new)\n                                (let ([new\
    \ (+ new 1)])\n                                  (if (< (cdr integers) new)\n\
    \                                      (let ([new (+ new 1)])\n              \
    \                          (if (< (cdr integers) new)\n                      \
    \                      (let ([new (+ new 1)])\n                              \
    \                (if (< (cdr integers) new)\n                                \
    \                  (let ([new (+ new 1)])\n                                  \
    \                  (if (< (cdr integers) new)\n                              \
    \                          (let ([new (+ new 1)])\n                          \
    \                                (if (< (cdr integers) new)\n                \
    \                                              (let ([new (+ new 1)])\n      \
    \                                                          (if (< (cdr integers)\
    \ new)\n                                                                    (let\
    \ ([new (+ new 1)])\n                                                        \
    \              (if (< (cdr integers) new)\n                                  \
    \                                        (let ([new (+ new 1)])\n            \
    \                                                                (if (< (cdr integers)\
    \ new)\n                                                                     \
    \         (let ([new (+ new 1)])\n                                           \
    \                                     (if (< (cdr integers) new)\n           \
    \                                                                       (let ([new\
    \ (+ new 1)])\n                                                              \
    \                      (if (< (cdr integers) new)\n                          \
    \                                                            (let ([new (+ new\
    \ 1)])\n                                                                     \
    \                   (if (< (cdr integers) new)\n                             \
    \                                                             (let ([new (+ new\
    \ 1)])\n                                                                     \
    \                       (if (< (cdr integers) new)\n                         \
    \                                                                     (let ([new\
    \ (+ new 1)])\n                                                              \
    \                                  (if (< (cdr integers) new)\n              \
    \                                                                            \
    \        (let ([new (+ new 1)])\n                                            \
    \                                                        (if (< (cdr integers)\
    \ new)\n                                                                     \
    \                                 (let ([new (+ new 1)])\n                   \
    \                                                                            \
    \         (if (< (cdr integers) new)\n                                       \
    \                                                                   (let ([new\
    \ (+ new 1)])\n                                                              \
    \                                              (if (< (cdr integers) new)\n  \
    \                                                                            \
    \                                (let ([new (+ new 1)])\n                    \
    \                                                                            \
    \                (if (< (cdr integers) new)\n                                \
    \                                                                            \
    \      (let ([new (+ new 1)])\n                                              \
    \                                                                      (if (<\
    \ (cdr integers) ", "  (let ((integer (parse-integer value)))\n    (cond ((< integer\
    \ 0) integer)\n          ((< integer 1) integer)\n          ((< integer 2) integer)\n\
    \          ((< integer 3) integer)\n          ((< integer 4) integer)\n      \
    \    ((< integer 5) integer)\n          ((< integer 6) integer)\n          ((<\
    \ integer 7) integer)\n          ((< integer 8) integer)\n          ((< integer\
    \ 9) integer)\n          ((< integer 10) integer)\n          ((< integer 11) integer)\n\
    \          ((< integer 12) integer)\n          ((< integer 13) integer)\n    \
    \      ((< integer 14) integer)\n          ((< integer 15) integer)\n        \
    \  ((< integer 16) integer)\n          ((< integer 17) integer)\n          ((<\
    \ integer 18) integer)\n          ((< integer 19) integer)\n          ((< integer\
    \ 20) integer)\n          ((< integer 21) integer)\n          ((< integer 22)\
    \ integer)\n          ((< integer 23) integer)\n          ((< integer 24) integer)\n\
    \          ((< integer 25) integer)\n          ((< integer 26) integer)\n    \
    \      ((< integer 27) integer)\n          ((< integer 28) integer)\n        \
    \  ((< integer 29) integer)\n          ((< integer 30) integer)\n          ((<\
    \ integer 31) integer)\n          ((< integer 32) integer)\n          ((< integer\
    \ 33) integer)\n          ((< integer 34) integer)\n          ((< integer 35)\
    \ integer)\n          ((< integer 36) integer)\n          ((< integer 37) integer)\n\
    \          ((< integer 38) integer)\n          ((< integer 39) integer)\n    \
    \      ((< integer 40) integer)\n          ((< integer 41) integer)\n        \
    \  ((< integer 42) integer)\n          ((< integer 43) integer)\n          ((<\
    \ integer 44) integer)\n          ((< integer 45) integer)\n          ((< integer\
    \ 46) integer)\n          ((< integer 47) integer)\n          ((< integer 48)\
    \ integer)\n          ((< integer 49) integer)\n          ((< integer 50) integer)\n\
    \          ((< integer 51) integer)\n          ((< integer 52) integer)\n    \
    \      ((< integer 53) integer)\n          ((< integer 54) integer)\n        \
    \  ((< integer 55) integer)\n          ((< integer 56", "  (let ([integers (map\
    \ number->integer [1 2 3 4 5 6 7 8 9 10])])\n    (let ([closest (first integers)])\n\
    \      (if (< (abs (- value closest)) (abs (- value integers)))\n          closest\n\
    \          (closest_integer value))))))\n", "  (define (closest-integer x y)\n\
    \    (if (= x y)\n        x\n        (if (> (abs (- x y)) (abs (- y x)))\n   \
    \         (- x y)\n            (- y x))))\n  (closest-integer 0 (+ value 1)))\n",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (if\
    \ (or (= x y)\n            (number->string value) (string-equal x y))\n      \
    \  value\n        (let ([x (number->string value)])\n          (let ([y (number->string\
    \ value)])\n            (if (or (= x y)\n                    (number->string value)\
    \ (string-equal x y))\n                value\n                (let ([x (number->string\
    \ value)])\n                  (let ([y (number->string value)])\n            \
    \        (if (or (= x y)\n                            (number->string value) (string-equal\
    \ x y))\n                        value\n                        (let ([x (number->string\
    \ value)])\n                          (let ([y (number->string value)])\n    \
    \                        (if (or (= x y)\n                                   \
    \ (number->string value) (string-equal x y))\n                               \
    \ value\n                                (let ([x (number->string value)])\n \
    \                                 (let ([y (number->string value)])\n        \
    \                            (if (or (= x y)\n                               \
    \             (number->string value) (string-equal x y))\n                   \
    \                         value\n                                            (let\
    \ ([x (number->string value)])\n                                             \
    \ (let ([y (number->string value)])\n                                        \
    \        (if (or (= x y)\n                                                   \
    \     (number->string value) (string-equal x y))\n                           \
    \                     value\n                                                (let\
    \ ([x (number->string value)])\n                                             \
    \     (let ([y (number->string value)])\n                                    \
    \                (if (or (= x y)\n                                           \
    \                 (number->string value) (string-equal x y))\n               \
    \                                         value\n                            \
    \                            (let ([x (number->string value)])\n             \
    \                                             (let ([y (number->string value)])\n\
    \                                                            (if (or (= x y)\n\
    \                                                                    (number->string\
    \ value) (string-equal x y))\n                                               \
    \                 value\n                                                    \
    \            (let ([x (number->string value)])\n                             \
    \                                     (let ([y (number->string value)])\n    \
    \                                                                (if (or (= x\
    \ y)\n                                                                       \
    \     (number->string value) (string-equal x y))\n                           \
    \                                                 value\n                    \
    \                                                        (let ([x (number->string\
    \ value)])\n                                                                 \
    \ (let ([y (number->string value)])\n                                        \
    \                            (if (or (= x y)\n                               \
    \                                             (number->string value) (string-equal\
    \ x y))\n                                                                    \
    \        value\n                                                             \
    \               (let ([x (number->string value)])\n                          \
    \                                        (let ([y (number->string value)])\n \
    \                                                                   (if (or (=\
    \ x y)\n                                                                     \
    \       (number->string value) (string-equal x y))\n                         \
    \                                                   value\n                  \
    \                                                          (let ([x", "  (let\
    \ ([x (parse-integer (string->symbol (symbol->string value)))])\n    (let ([y\
    \ (parse-integer (string->symbol (symbol->string value)))])\n      (cond\n   \
    \     ((= x y) value)\n        ((< (abs (- x y)) (abs x))\n         (parse-integer\
    \ (string->symbol (symbol->string value)))\n         (parse-integer (string->symbol\
    \ (symbol->string value)))\n         (parse-integer (string->symbol (symbol->string\
    \ value)))\n         (parse-integer (string->symbol (symbol->string value)))\n\
    \         (parse-integer (string->symbol (symbol->string value)))\n         (parse-integer\
    \ (string->symbol (symbol->string value)))\n         (parse-integer (string->symbol\
    \ (symbol->string value)))\n         (parse-integer (string->symbol (symbol->string\
    \ value)))\n         (parse-integer (string->symbol (symbol->string value)))\n\
    \         (parse-integer (string->symbol (symbol->string value)))\n         (parse-integer\
    \ (string->symbol (symbol->string value)))\n         (parse-integer (string->symbol\
    \ (symbol->string value)))\n         (parse-integer (string->symbol (symbol->string\
    \ value)))\n         (parse-integer (string->symbol (symbol->string value)))\n\
    \         (parse-integer (string->symbol (symbol->string value)))\n         (parse-integer\
    \ (string->symbol (symbol->string value)))\n         (parse-integer (string->symbol\
    \ (symbol->string value)))\n         (parse-integer (string->symbol (symbol->string\
    \ value)))\n         (parse-integer (string->symbol (symbol->string value)))\n\
    \         (parse-integer (string->symbol (symbol->string value)))\n         (parse-integer\
    \ (string->symbol (symbol->string value)))\n         (parse-integer (string->symbol\
    \ (symbol->string value)))\n         (parse-integer (string->symbol (symbol->string\
    \ value)))\n         (parse-integer (string->symbol (symbol->string value)))\n\
    \         (parse-integer (string->symbol (symbol->string value)))\n         (parse-integer\
    \ (string->symbol (symbol->string value)))\n         (parse-integer (string->symbol\
    \ (symbol->string value)))\n         (parse-integer (string->symbol (symbol->string\
    \ value)))\n         (parse-integer (string->symbol (symbol->string value)))\n\
    \         (parse-integer (string->symbol (symbol->string value)))", "  (let ([num\
    \ (parse-integer value)]\n        [min (parse-integer \"0\")]\n        [max (parse-integer\
    \ \"9\")])\n    (cond\n      [(< num max) (parse-integer \"0\")]\n      [(< num\
    \ min) (parse-integer \"9\")]\n      [(= num max) (parse-integer \"9\")]\n   \
    \   [(= num min) (parse-integer \"0\")]\n      [(= num num) (parse-integer \"\
    0\")]\n      [else (parse-integer \"0\")])))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (if (= x y)\n        (number->integer\
    \ value)\n        (let ([x (number->string value)]\n              [y (number->string\
    \ value)])\n          (if (= x y)\n              (number->integer value)\n   \
    \           (let ([x (number->string value)]\n                    [(+ (number->integer\
    \ x) (number->integer y))\n                     (- (number->integer x) (number->integer\
    \ y))])\n                (if (< x y)\n                    (number->integer value)\n\
    \                    (number->integer x))))))))\n", "  (let ((num (string->number\
    \ value)))\n    (cond\n      [(< num 0) (error \"Closest integer not possible:\
    \ value is less than zero.\")]\n      [(< num 1) (error \"Closest integer not\
    \ possible: value is less than one.\")]\n      [else (floor (+ num 1))])))\n",
  "  (let ([integers (map number->integer [1 2 3 4 5 6 7 8 9])])\n    (let ([closest\
    \ (car integers)])\n      (let ([diff (- value closest)])\n        (if (< diff\
    \ 0)\n            (if (< diff (- closest 1))\n                (if (< diff (- closest\
    \ 2))\n                    (if (< diff (- closest 3))\n                      \
    \  (if (< diff (- closest 4))\n                            (if (< diff (- closest\
    \ 5))\n                                (if (< diff (- closest 6))\n          \
    \                          (if (< diff (- closest 7))\n                      \
    \                  (if (< diff (- closest 8))\n                              \
    \              (if (< diff (- closest 9))\n                                  \
    \              (if (< diff (- closest 10))\n                                 \
    \                   (if (< diff (- closest 11))\n                            \
    \                            (if (< diff (- closest 12))\n                   \
    \                                         (if (< diff (- closest 13))\n      \
    \                                                          (if (< diff (- closest\
    \ 14))\n                                                                    (if\
    \ (< diff (- closest 15))\n                                                  \
    \                      (if (< diff (- closest 16))\n                         \
    \                                                   (if (< diff (- closest 17))\n\
    \                                                                            \
    \    (if (< diff (- closest 18))\n                                           \
    \                                         (if (< diff (- closest 19))\n      \
    \                                                                            \
    \      (if (< diff (- closest 20))\n                                         \
    \                                                   (if (< diff (- closest 21))\n\
    \                                                                            \
    \                    (if (< diff (- closest 22))\n                           \
    \                                                                         (if\
    \ (< diff (- closest 23))\n                                                  \
    \                                                      (if (< diff (- closest\
    \ 24))\n                                                                     \
    \                                       (if (< diff (- closest 25))\n        \
    \                                                                            \
    \                            (if (< diff (- closest 26))\n                   \
    \                                                                            \
    \                     (if (< diff (- closest 27))\n                          \
    \                                                                            \
    \                  (if (< diff (- closest 28))\n                             \
    \                                                                            \
    \                   (if (< diff (- closest 29))\n                            \
    \                                                                            \
    \                        (if (< diff (- closest 30))\n                       \
    \                                                                            \
    \                                 (if (< diff (- closest 31))\n              \
    \                                                                            \
    \                                              (if (< diff (- closest 32))\n \
    \                                                                            \
    \                                                               (if (< diff (-\
    \ closest 33))\n                                                             \
    \                                                                            \
    \       (if (< diff (- closest 34))\n                                        \
    \                                                                            \
    \                                (if (< diff (- closest 35))\n               \
    \                                                                            \
    \                                                             (if (< diff (- closest\
    \ 36))\n                                                                     \
    \                                                                            \
    \           (if (< diff (- closest 37))\n                                    \
    \                                                                            \
    \                                                (if (< diff (- closest 38))\n\
    \                                                                            \
    \                                                                            \
    \            (if (< diff (- closest 39))\n                                   \
    \                                                                            \
    \                                                         (if (< diff (- closest\
    \ 40))\n                                                                     \
    \                                                                            \
    \                           (if (< diff (- closest 4", "  (let ([integers (map\
    \ integer? (string->list value))])\n    (if (null? integers)\n        0\n    \
    \    (let ([closest (first integers)])\n          (if (null? integers)\n     \
    \         closest\n              (let ([closest (if (< (first integers) (first\
    \ integers)) \n                                  (first integers)\n          \
    \                        (first integers))])\n                (if (< (first integers)\
    \ (first integers)) \n                    (if (< (first integers) closest) \n\
    \                        (if (< (first integers) (first integers)) \n        \
    \                    closest\n                            (if (< (first integers)\
    \ closest) \n                                (if (< (first integers) (first integers))\
    \ \n                                    closest\n                            \
    \        (if (< (first integers) (first integers)) \n                        \
    \                closest\n                                        (if (< (first\
    \ integers) (first integers)) \n                                            closest\n\
    \                                            (if (< (first integers) (first integers))\
    \ \n                                                closest\n                \
    \                                (if (< (first integers) (first integers)) \n\
    \                                                    closest\n               \
    \                                     (if (< (first integers) (first integers))\
    \ \n                                                        closest\n        \
    \                                                (if (< (first integers) (first\
    \ integers)) \n                                                            closest\n\
    \                                                            closest)))))))))))))))))))\n",
  "  (let ([integers (map number->integer [1 2 3 4 5 6 7 8 9])])\n    (let ([closest\
    \ (first integers)])\n      (if (< (abs (- value closest)) (abs (- value integers)))\n\
    \          closest\n          integers))))\n", "  (let ([x (parse-integer (string->list\
    \ value))])\n    (cond\n      [(< x 0) (error \"Closest integer not possible:\
    \ negative number\")\n       (floor (+ x 1))]\n      [(< x 1) x]\n      [else\
    \ (error \"Closest integer not possible: equidistant numbers\")])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
