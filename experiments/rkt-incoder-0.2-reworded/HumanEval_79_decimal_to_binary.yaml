name: HumanEval_79_decimal_to_binary
language: rkt
prompt: "#lang racket\n\n;; You will be given a number in decimal form and your task\
  \ is to convert it to\n;; binary format. The function should return a string, with\
  \ each character representing a binary\n;; number. Each character in the string\
  \ will be '0' or '1'.\n;; There will be an extra couple of characters 'db' at the\
  \ beginning and at the end of the string.\n;; The extra characters are there to\
  \ help with the format.\n;; Examples:\n;; >>> (decimal_to_binary 15)\n;; \"db1111db\"\
  \n;; >>> (decimal_to_binary 32)\n;; \"db100000db\"\n(define (decimal_to_binary decimal)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate decimal_to_binary))\n\
  \    (check-equal? (candidate 0) \"db0db\")\n    (check-equal? (candidate 32) \"\
  db100000db\")\n    (check-equal? (candidate 103) \"db1100111db\")\n    (check-equal?\
  \ (candidate 15) \"db1111db\")\n))\n\n(test-humaneval)"
completions: ["  (let loop ((decimal decimal)\n             (result '()))\n    (if\
    \ (= decimal 0)\n        result\n        (loop (sub1 decimal)\n              (cons\
    \ (char->integer decimal)\n                    result)))))\n", "  (let loop ((decimal\
    \ decimal)\n             (result '()))\n    (if (= decimal 0)\n        result\n\
    \        (loop (quotient decimal 2)\n               (cons 0 (if (= (quotient decimal\
    \ 2) 0)\n                          '1\n                          '0)))\n     \
    \   (loop (quotient decimal 2)\n               (cons 1 (if (= (quotient decimal\
    \ 2) 0)\n                          '1\n                          '0))))\n    (append\
    \ result 'db)))\n", "  (define (helper decimal result)\n    (cond\n      [(= decimal\
    \ 0) result]\n      [(= decimal 1) (helper decimal (append result \"1\"))]\n \
    \     [(= decimal 2) (helper decimal (append result \"10\"))]\n      [(= decimal\
    \ 3) (helper decimal (append result \"100\"))]\n      [(= decimal 4) (helper decimal\
    \ (append result \"1000\"))]\n      [(= decimal 5) (helper decimal (append result\
    \ \"10000\"))]\n      [(= decimal 6) (helper decimal (append result \"100000\"\
    ))]\n      [(= decimal 7) (helper decimal (append result \"1000000\"))]\n    \
    \  [(= decimal 8) (helper decimal (append result \"10000000\"))]\n      [(= decimal\
    \ 9) (helper decimal (append result \"100000000\"))]\n      [(= decimal 10) (helper\
    \ decimal (append result \"1000000000\"))]\n      [(= decimal 11) (helper decimal\
    \ (append result \"10000000000\"))]\n      [(= decimal 12) (helper decimal (append\
    \ result \"100000000000\"))]\n      [(= decimal 13) (helper decimal (append result\
    \ \"1000000000000\"))]\n      [(= decimal 14) (helper decimal (append result \"\
    10000000000000\"))]\n      [(= decimal 15) (helper decimal (append result \"100000000000000\"\
    ))]\n      [(= decimal 16) (helper decimal (append result \"1000000000000000\"\
    ))]\n      [(= decimal 17) (helper decimal (append result \"10000000000000000\"\
    ))]\n      [(= decimal 18) (helper decimal (append result \"100000000000000000\"\
    ))]\n      [(= decimal 19) (helper decimal (append result \"1000000000000000000\"\
    ))]\n      [(= decimal 20) (helper decimal (append result \"10000000000000000000\"\
    ))]\n      [(= decimal 21) (helper decimal (append result \"100000000000000000000\"\
    ))]\n      [(= decimal 22) (helper decimal (append result \"1000000000000000000000\"\
    ))]\n      [(= decimal 23) (helper decimal (append result \"10000000000000000000000\"\
    ))]\n      [(= decimal 24) (helper decimal (append result \"100000000000000000000000\"\
    ))]\n      [(= decimal 25) (helper decimal (append result \"1000000000000000000000000\"\
    ))]\n      [(= decimal 26) (helper decimal (append result \"10000000000000000000000000\"\
    ))]\n      [(= decimal 27) (helper decimal (append result \"100000000000000000000000000\"\
    ))]\n      [(= decimal 28) (helper decimal (append result \"1000000000000000000000000000\"\
    ))]\n      [(= decimal 29) (helper ", "  (let ([remainder (remainder decimal 2)])\n\
    \    (if (= remainder 0)\n        (string-append \"0\" \"\")\n        (string-append\
    \ \"1\" \"\")\n      )\n    )\n  )\n", "  (define (helper decimal remainder binary)\n\
    \    (if (= decimal 0)\n        binary\n        (helper (quotient decimal 2) (quotient\
    \ decimal 2) (concat binary 'db))))\n  (helper decimal decimal '()))\n", "  (define\
    \ (helper decimal result)\n    (if (= decimal 0)\n        result\n        (helper\
    \ (quotient decimal 2) (conj result (if (= (quotient decimal 2) 0) '1\n      \
    \                                                '0)))))\n  (helper decimal '()))\n",
  "  (let ([remainder (modulo decimal 2)])\n    (if (= remainder 0)\n        (string-append\
    \ \"0\" '(1 0))\n        (string-append '(0 1) (decimal_to_binary (quotient decimal\
    \ 2))))))\n", "  (let loop ((decimal decimal)\n             (result '()))\n  \
    \  (if (= decimal 0)\n        result\n        (loop (quotient decimal 2)\n   \
    \           (cons (if (= (quotient decimal 2) 0)\n                       '0\n\
    \                       '1)\n                    result)))))\n", "  (let loop\
    \ ((decimal decimal)\n             (result '()))\n    (if (= decimal 0)\n    \
    \    (reverse result)\n        (loop (quotient decimal 2)\n              (cons\
    \ (if (= (modulo decimal 2) 0) '1 '0) result)))))\n", "  (let loop ((decimal decimal)\n\
    \             (result '()))\n    (if (= decimal 0)\n        (reverse result)\n\
    \        (loop (quotient decimal 2)\n              (cons (if (= (modulo decimal\
    \ 2) 0) '1 '0) result)))))\n", "  (define (helper decimal result)\n    (if (=\
    \ decimal 0)\n        result\n        (helper (quotient decimal 2) (conj result\
    \ (if (= (quotient decimal 2) 0) '0 '1)))))\n  (helper decimal '()))\n", "  (define\
    \ (helper decimal result)\n    (if (= decimal 0)\n        result\n        (helper\
    \ (quotient decimal 2) (concat result (list '(0 1))))))\n  (helper decimal '()))\n",
  "  (let ([remainder (remainder decimal 2)])\n    (if (= remainder 0)\n        (string-append\
    \ \"0\" \"\")\n        (string-append \"1\" \"\")\n    )\n    (let ([remainder\
    \ (remainder decimal 4)])\n      (if (= remainder 0)\n          (string-append\
    \ \"0\" \"\")\n          (string-append \"1\" \"\")\n      )\n      (let ([remainder\
    \ (remainder decimal 8)])\n        (if (= remainder 0)\n            (string-append\
    \ \"0\" \"\")\n            (string-append \"1\" \"\")\n        )\n        (let\
    \ ([remainder (remainder decimal 16)])\n          (if (= remainder 0)\n      \
    \        (string-append \"0\" \"\")\n              (string-append \"1\" \"\")\n\
    \          )\n          (string-append \"db\" \"\")\n        )\n      )\n    )\n\
    \  )\n)\n", "  (let loop ((decimal decimal)\n             (result '()))\n    (if\
    \ (= decimal 0)\n        (reverse result)\n        (loop (quotient decimal 2)\n\
    \              (cons (if (= (quotient decimal 2) 0)\n                       '0\n\
    \                       '1)\n                    result)))))\n", "  (let loop\
    \ ((decimal decimal)\n             (result '()))\n    (if (= decimal 0)\n    \
    \    result\n        (loop (quotient decimal 2)\n              (cons 0 (if (=\
    \ (quotient decimal 2) 0)\n                         '1\n                     \
    \    '0)))\n        (loop (quotient decimal 2)\n              (cons 1 (if (= (quotient\
    \ decimal 2) 0)\n                         '0\n                         '1))))))\n",
  "  (define (helper decimal acc)\n    (if (= decimal 0)\n        acc\n        (helper\
    \ (quotient decimal 2) (cond [(= (quotient decimal 2) 0) '0]\n               \
    \                        [(= (quotient decimal 2) 1) '1]\n                   \
    \                    [else 'db])))\n    (helper (quotient decimal 2) (cond [(=\
    \ (quotient decimal 2) 0) '0]\n                                     [(= (quotient\
    \ decimal 2) 1) '1]\n                                     [else 'db])))\n  (helper\
    \ decimal '()))\n", "  (let loop ((decimal decimal)\n             (result '()))\n\
    \    (if (= decimal 0)\n        result\n        (loop (quotient decimal 2)\n \
    \             (cons (if (= (modulo decimal 2) 0)\n                       '0\n\
    \                       '1)\n                    result)))))\n", "  (let ([remainder\
    \ (remainder decimal 2)])\n    (if (= remainder 0)\n        (string-append \"\
    0\" \"\")\n        (string-append \"1\" \"\")\n    )\n    (decimal_to_binary remainder)\n\
    \  )\n)\n", "  (let loop ((decimal decimal)\n             (result '()))\n    (if\
    \ (= decimal 0)\n        result\n        (loop (quotient decimal 2)\n        \
    \      (cons 0 (if (= (quotient decimal 2) 0)\n                          '1\n\
    \                          '0)))\n        (loop (quotient decimal 2)\n       \
    \       (cons '1 (if (= (quotient decimal 2) 0)\n                          '0\n\
    \                          '1))))\n    (append result 'db)))\n", "  (let loop\
    \ ((decimal decimal)\n             (result '()))\n    (if (= decimal 0)\n    \
    \    (reverse result)\n        (loop (quotient decimal 2)\n              (cons\
    \ (if (= (quotient decimal 2) 0)\n                       '0\n                \
    \       '1)\n                    result)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
