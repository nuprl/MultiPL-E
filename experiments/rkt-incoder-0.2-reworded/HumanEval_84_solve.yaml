name: HumanEval_84_solve
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer N, return the total sum of its\
  \ digits in binary.\n;; Example\n;; >>> (solve 1000)\n;; \"1\"\n;; >>> (solve 150)\n\
  ;; \"110\"\n;; >>> (solve 147)\n;; \"1100\"\n;; Variables:\n;; @N integer\n;; Constraints:\
  \ 0 \u2264 N \u2264 10000.\n;; Output:\n;; a string of binary number\n(define (solve\
  \ N)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate 1000) \"1\")\n    (check-equal? (candidate 150) \"\
  110\")\n    (check-equal? (candidate 147) \"1100\")\n    (check-equal? (candidate\
  \ 333) \"1001\")\n    (check-equal? (candidate 963) \"10010\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(= N 0) \"\"]\n    [(= N 1) (string \"1\")]\n    [else\
    \ (cons (string->list (number->string N)) (solve (sub1 N)))]))\n", "  (cond\n\
    \    [(= N 0) \"\"]\n    [(= N 1) (list '1)]\n    [else (append (solve (sub1 N))\
    \ (list (digit-value N)))]))\n", "  (if (= N 0)\n      '0\n      (let ((sum (string-append\
    \ (solve (quotient N 2)) (list (modulo N 2)))))\n        (if (= (modulo N 2) 0)\n\
    \            (string-append sum \"0\")\n            sum))))\n", "  (cond\n   \
    \ [(= N 0) \"\"]\n    [(= N 1) (list '1)]\n    [else (append (solve (quotient\
    \ N 2))\n                  (list (modulo N 2))))]\n  )\n)\n", "  (cond\n    [(=\
    \ N 0) \"\"]\n    [(= N 1) (list '1)]\n    [else (append (solve (sub1 N)) (list\
    \ (modulo (modulo (modulo N 2) 2) 10) (modulo N 10)))]))\n", "  (cond\n    [(=\
    \ N 0) \"\"]\n    [(= N 1) (list '1)]\n    [else (append (solve (sub1 N)) (list\
    \ (modulo (modulo (modulo N 2) 2) 10))]))))\n", "  (let loop ((N N) (S '()))\n\
    \    (if (= N 0)\n        S\n        (loop (quotient N 2) (append S (list (modulo\
    \ N 2)))))))\n", "  (if (= N 0)\n      '0\n      (let ((sum (string-append (solve\
    \ (quotient N 2)) (list (modulo N 2)))))\n        (if (= (modulo N 2) 0)\n   \
    \         (string-append sum \"0\")\n            (string-append sum \"1\")))))\n",
  "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) (list '1)]\n    [else (append (solve\
    \ (sub1 N)) (list (modulo (modulo N 2) 2) (modulo N 2)))]))\n", "  (if (= N 0)\n\
    \      \"0\"\n      (let ((sum (string-append (solve (quotient N 2)) (string-append\
    \ (modulo N 2) \"0\"))))\n        (if (= (modulo N 2) 0)\n            (string-append\
    \ sum \"0\")\n            sum))))\n", "  (cond\n    [(= N 0) \"\"]\n    [(= N\
    \ 1) \"1\"]\n    [else (append (solve (quotient N 2))\n                  (list\
    \ (modulo N 2))))]\n  )\n)\n", "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) (list\
    \ '1)]\n    [else (append (solve (sub1 N)) (list (digit-of-bin N)))]))\n", " \
    \ (cond\n    [(= N 0) \"\"]\n    [(= N 1) (list '1)]\n    [else (append (solve\
    \ (sub1 N)) (list (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo (modulo\
    \ (modulo (modu", "  (let loop ((N N) (S '()))\n    (if (= N 0)\n        (reverse\
    \ S)\n        (loop (quotient N 2) (cons (remainder N 2) S)))))\n", "  (cond\n\
    \    [(= N 0) \"\"]\n    [(= N 1) (string \"1\")]\n    [else (append (solve (sub1\
    \ N)) (string \"0\"))]))\n", "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) \"0\"\
    ]\n    [else (append (solve (sub1 N)) (list (char-bin N)))]))\n", "  (cond\n \
    \   [(= N 0) \"\"]\n    [(= N 1) (list '1)]\n    [(= N 2) (list '10)]\n    [(=\
    \ N 3) (list '11 10)]\n    [(= N 4) (list '11 10 100)\n              (list '11\
    \ 10 100 1000)\n              (list '11 10 100 1000 10000)]\n    [(= N 5) (list\
    \ '11 10 100 1000 10000 100000)\n              (list '11 10 100 1000 10000 100000\
    \ 1000000)\n              (list '11 10 100 1000 10000 100000 1000000 100000000)]\n\
    \    [(= N 6) (list '11 10 100 1000 10000 100000 1000000 100000000 10000000000)\n\
    \              (list '11 10 100 1000 10000 100000 1000000 100000000 10000000000\
    \ 100000000000)\n              (list '11 10 100 1000 10000 100000 1000000 100000000\
    \ 10000000000 100000000000 1000000000000)\n              (list '11 10 100 1000\
    \ 10000 100000 1000000 100000000 10000000000 100000000000 1000000000000 10000000000000)]\n\
    \    [(= N 7) (list '11 10 100 1000 10000 100000 1000000 100000000 10000000000\
    \ 100000000000 1000000000000 10000000000000 1000000000000000)\n              (list\
    \ '11 10 100 1000 10000 100000 1000000 100000000 10000000000 100000000000 1000000000000\
    \ 10000000000000 1000000000000000 10000000000000000)\n              (list '11\
    \ 10 100 1000 10000 100000 1000000 100000000 10000000000 100000000000 1000000000000\
    \ 10000000000000 1000000000000000 10000000000000000 100000000000000000)\n    \
    \          (list '11 10 100 1000 10000 100000 1000000 100000000 10000000000 100000000000\
    \ 1000000000000 10000000000000 1000000000000000 10000000000000000 100000000000000000\
    \ 1000000000000000001)]\n    [(= N 8) (list '11 10 100 1000 10000 100000 1000000\
    \ 100000000 10000000000 100000000000 1000000000000 10000000000000 1000000000000000\
    \ 10000000000000000 100000000000000000 1000000000000000001 1000000000000000010)\n\
    \              (list '11 10 100 1000 10000 100000 1000000 100000000 10000000000\
    \ 100000000000 1000000000000 10000000000000 1000000000000000 10000000000000000\
    \ 100000000000000000 1000000000000000001 1000000000000000010 10000000000000000100)\n\
    \              (list '11 10 ", "  (cond\n    [(= N 0) \"\"]\n    [(= N 1) (list\
    \ '1)]\n    [else (append (solve (sub1 N))\n                  (list (modulo (modulo\
    \ (modulo N 2) 10) 2) (modulo N 10)))]))\n", "  (cond\n    [(= N 0) \"\"]\n  \
    \  [(= N 1) (list '1)]\n    [else (append (solve (sub1 N)) (list (digit-sum (sub1\
    \ N))))]))\n", "  (if (= N 0)\n      '0\n      (let ((sum (string-append (solve\
    \ (sub1 N)) (list (digit-char (modulo N 10))))))\n        (if (= (length sum)\
    \ 2)\n            (string-append (sub1 N) sum)\n            sum))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
