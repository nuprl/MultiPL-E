name: HumanEval_65_circular_shift
language: rkt
prompt: "#lang racket\n\n;; Circular shift the digits of the integer x, shift the\
  \ digits right by shift\n;; and return the result as a string.\n;; If shift > number\
  \ of digits, return digits reversed.\n;; >>> (circular_shift 12 1)\n;; \"21\"\n\
  ;; >>> (circular_shift 12 2)\n;; \"12\"\n(define (circular_shift x shift)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate circular_shift))\n\
  \    (check-equal? (candidate 100 2) \"001\")\n    (check-equal? (candidate 12 2)\
  \ \"12\")\n    (check-equal? (candidate 97 8) \"79\")\n    (check-equal? (candidate\
  \ 12 1) \"21\")\n    (check-equal? (candidate 11 101) \"11\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(< shift (length x))\n     (reverse (subseq x 0 shift))]\n\
    \    [else\n     (subseq x 0 shift) (subseq x (+ shift (length x))\n         \
    \                         (- shift (length x)))]))\n", "  (let loop ((x x) (shift\
    \ shift) (result '()))\n    (cond ((< shift (length x))\n           (reverse result))\n\
    \          ((< shift 0)\n           (reverse result))\n          (else\n     \
    \      (loop (quotient x 10) (quotient shift 10)\n                 (cons (modulo\
    \ x 10) result))))))\n", "  (let loop ((x x) (shift shift))\n    (cond ((< shift\
    \ (length x))\n           (reverse (substring x 0 (- shift (length x))))\n   \
    \        (reverse (substring x (- shift (length x)) (length x))))\n          ((=\
    \ shift 0)\n           (reverse (substring x 0 (length x))))\n          (else\n\
    \           (loop (substring x (* shift (length x)) (* shift (length x))) (- shift\
    \ 1))))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n    (cond ((< shift\
    \ (length x))\n           (reverse digits))\n          ((< shift 0)\n        \
    \   (reverse digits))\n          (else\n           (let ((digit (modulo (modulo\
    \ x 10) (expt 10 shift))))\n             (set! digits (cons digit digits))\n \
    \            (loop (modulo x 10) (sub1 shift) (cons digit digits))))))\n", " \
    \ (let loop ((x x) (shift shift) (result '()))\n    (if (< shift (length x))\n\
    \        (loop (sub1 x) (- shift (length x)) (cons x (reverse result)))\n    \
    \    (reverse result))))\n", "  (let loop ((x x) (shift shift) (digits '()))\n\
    \    (cond\n      [(zero? x) (reverse digits)]\n      [(> shift (length digits))\
    \ (cons (car digits) digits)]\n      [else (loop (quotient x 10) (remainder x\
    \ 10) (rest digits))]\n    )))\n", "  (let loop ((x x) (shift shift) (digits '()))\n\
    \    (cond ((< shift (length x))\n           (reverse digits))\n          ((<\
    \ shift 0)\n           (reverse digits))\n          (else\n           (let ((digit\
    \ (modulo (modulo x 10) (expt 10 shift))))\n             (loop (quotient x 10)\
    \ (inc shift) (cons digit digits))))))))\n", "  (let loop ((x x) (shift shift))\n\
    \    (cond\n      [(< shift (length x))\n       (reverse (substring x 0 (- shift\
    \ (length x))))]\n      [(< shift 0)\n       (reverse (substring x 0 (- shift\
    \ (length x))))]\n      [else\n       (loop (quotient x 10) (- shift 1))]))))\n",
  "  (let loop ((x x) (shift shift))\n    (cond\n      [(< shift (length x))\n   \
    \    (reverse (substring x 0 (- shift (length x))))]\n      [(< shift 0)\n   \
    \    (reverse (substring x 0 (- shift (length x))))]\n      [else\n       (loop\
    \ (quotient x 10) (- shift 1))]))))\n", "  (let loop ((x x) (shift shift) (digits\
    \ '()))\n    (cond ((< shift (length x))\n           (reverse digits))\n     \
    \     ((< shift 0)\n           (reverse digits))\n          (else\n          \
    \ (let ((digit (modulo (modulo x 10) (* shift 10))))\n             (cond ((< digit\
    \ 9)\n                    (loop (+ digit 1) (- shift 1)))\n                  \
    \ ((< digit 0)\n                    (loop (+ digit 1) shift))\n              \
    \     (else\n                    (loop (+ digit 1) shift)))))))))\n", "  (if (<\
    \ shift (length x))\n      (let ([digits (split-string (number->string x) \"\"\
    )]\n            [result \"\"])\n        (if (= shift 0)\n            (string-append\
    \ (first digits) result)\n            (let ([remainder (modulo (first digits)\
    \ 10)])\n              (if (= remainder 0)\n                  (let ([remainder\
    \ (modulo (rest digits) 10)])\n                    (if (= remainder 0)\n     \
    \                   (let ([remainder (modulo (rest digits) 10)])\n           \
    \               (if (= remainder 0)\n                              (let ([remainder\
    \ (modulo (rest digits) 10)])\n                                (if (= remainder\
    \ 0)\n                                    (let ([remainder (modulo (rest digits)\
    \ 10)])\n                                      (if (= remainder 0)\n         \
    \                                 (let ([remainder (modulo (rest digits) 10)])\n\
    \                                            (if (= remainder 0)\n           \
    \                                     (let ([remainder (modulo (rest digits) 10)])\n\
    \                                                  (if (= remainder 0)\n     \
    \                                                 (let ([remainder (modulo (rest\
    \ digits) 10)])\n                                                        (if (=\
    \ remainder 0)\n                                                            (let\
    \ ([remainder (modulo (rest digits) 10)])\n                                  \
    \                            (if (= remainder 0)\n                           \
    \                                       (let ([remainder (modulo (rest digits)\
    \ 10)])\n                                                                    (if\
    \ (= remainder 0)\n                                                          \
    \              (let ([remainder (modulo (rest digits) 10)])\n                \
    \                                                          (if (= remainder 0)\n\
    \                                                                            \
    \  (let ([remainder (modulo (rest digits) 10)])\n                            \
    \                                                    (if (= remainder 0)\n   \
    \                                                                            \
    \     (let ([remainder (modulo (rest digits) 10)])\n                         \
    \                                                             (if (= remainder\
    \ 0)\n                                                                       \
    \                   (let ([remainder (modulo (rest digits) 10)])\n           \
    \                                                                            \
    \     (if (= remainder 0)\n                                                  \
    \                                              (let ([remainder (modulo (rest\
    \ digits) 10)])\n                                                            \
    \                                      (if (= remainder 0)\n                 \
    \                                                                            \
    \         (let ([remainder (modulo (rest digits) 10)])\n                     \
    \                                                                            \
    \       (if (= remainder 0)\n                                                \
    \                                                            (let ([remainder\
    \ (modulo (rest digits) 10)])\n                                              \
    \                                                                (if (= remainder\
    \ 0)\n                                                                       \
    \                                           (let ([remainder (modulo (rest digits)\
    \ 10)])\n                                                                    \
    \                                                (if (= remainder 0)\n       \
    \                                                                            \
    \                                     (let ([remainder (modulo (rest digits) 10)])\n\
    \                                                                            \
    \                                              (if (= remainder 0)", "  (let loop\
    \ ((x x) (shift shift))\n    (if (< shift (length x))\n        (string-append\
    \ (substring x 0 (- shift (length x)))\n                       (loop (substring\
    \ x shift) (- shift 1)))\n        (substring x 0 shift))))\n", "  (let loop ((x\
    \ x) (shift shift) (digits '()))\n    (cond ((< shift (length digits))\n     \
    \      (reverse digits))\n          ((< shift (length x))\n           (loop (sub1\
    \ x) (sub1 shift) (cons x digits)))\n          (else\n           (loop (sub1 x)\
    \ (sub1 shift) (cons x digits)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| c\
    \ |>\nThanks, I didn't know about `reverse`, but this doesn't work for negative\
    \ numbers. I added a version that works with negative numbers and fixed a bug\
    \ in it.\n<|/ c |>\n<| a tags=racket,scheme |>\n<code>", "  (let loop ((x x) (shift\
    \ shift) (result '()))\n    (cond\n      [(< shift (length x))\n       (reverse\
    \ result)]\n      [(< shift 0)\n       (reverse result)]\n      [else\n      \
    \ (loop (quotient x 10) (- shift 1) (append result (quotient x 10)))]\n      )))\n",
  "  (let loop ((x x) (shift shift))\n    (cond\n      [(< shift (length x))\n   \
    \    (reverse (substring x 0 (- shift (length x))))]\n      [(< shift (length\
    \ x))\n       (reverse (substring x (- shift (length x)) (length x)))]\n     \
    \ [else\n       (substring x (- shift (length x)) (length x))]\n      (loop (quotient\
    \ x 10) (- shift 1))]))\n", "  (if (< shift (length x))\n      (cons (substring\
    \ x 0 (- shift (length x))) (circular_shift (substring x shift) shift))\n    \
    \  (substring x 0 (- shift (length x))))) ;; #lang racket\n", "  (let loop ((x\
    \ x) (shift shift) (acc '()))\n    (cond\n      [(< shift (length x)) (cons x\
    \ (reverse acc))]\n      [else (loop (quotient x 10) (- shift (length x)) (cons\
    \ (quotient x 10) acc))])))\n", "  (let loop ((x x) (shift shift) (digits '()))\n\
    \    (cond ((< shift (length x))\n           (reverse digits))\n          ((<\
    \ shift 0)\n           (reverse digits))\n          (else\n           (let ((digit\
    \ (modulo (modulo x 10) (* 10 shift))))\n             (cond ((< shift (length\
    \ digits))\n                    (loop (quotient x 10) shift (cons digit digits))\n\
    \                    (loop (quotient x 10) shift digits))\n                  (else\n\
    \                    (loop (quotient x 10) shift digits)))))\n          (else\n\
    \           (loop (quotient x 10) shift digits)))))\n", "  (if (= shift 0)\n \
    \     (list-ref x 0)\n      (let ((digits (list-ref x 0)))\n        (if (= shift\
    \ (length digits))\n            (string-append (list-ref x 0) (list-ref x 1))\n\
    \            (string-append (list-ref x 0) (list-ref x (- shift (length digits))))\n\
    \            (string-append (list-ref x 0) (list-ref x (- shift (length digits)))\
    \ (list-ref x 1))))))\n", "  (if (= shift 0)\n      (list-ref x 0)\n      (let\
    \ ((result (list-ref x 0)))\n        (do ((i 1 (+ i shift)))\n            ((<\
    \ i length))\n          (set! result (list-ref result (- i 1))))\n        result)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
