name: HumanEval_40_triples_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; triples_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns #t if there are three distinct elements in the list that\n;; sum to\
  \ zero, and #f otherwise.\n;; >>> (triples_sum_to_zero (list 1 3 5 0))\n;; #f\n\
  ;; >>> (triples_sum_to_zero (list 1 3 -2 1))\n;; #t\n;; >>> (triples_sum_to_zero\
  \ (list 1 2 3 7))\n;; #f\n;; >>> (triples_sum_to_zero (list 2 4 -5 3 9 7))\n;; #t\n\
  ;; >>> (triples_sum_to_zero (list 1))\n;; #f\n(define (triples_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 5 -1)) #f)\n    (check-equal? (candidate (list 1 3 -2 1)) #t)\n    (check-equal?\
  \ (candidate (list 1 2 3 7)) #f)\n    (check-equal? (candidate (list 1 2 5 7)) #f)\n\
  \    (check-equal? (candidate (list 2 4 -5 3 9 7)) #t)\n    (check-equal? (candidate\
  \ (list 1)) #f)\n    (check-equal? (candidate (list 1 3 5 -100)) #f)\n    (check-equal?\
  \ (candidate (list 100 3 5 -100)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) #f]\n    [(equal? (first l) 0) #t]\n    [else\
    \ (triples_sum_to_zero (rest l))]))\n", "  (let loop ((l l) (acc 0))\n    (cond\n\
    \      [(empty? l) #f]\n      [(equal? (first l) 0) (equal? (second l) 0)\n  \
    \     (equal? (third l) 0)\n       (loop (rest l) (+ acc 1))]\n      [else (loop\
    \ (rest l) (+ acc 1))]\n      )))\n", "  (cond ((null? l) #f)\n        ((= (length\
    \ l) 3) #t)\n        (else (= (apply + (map - l (rest l))) 0)\n              \
    \ (triples_sum_to_zero (rest l)))))\n", "  (let loop ((l l) (acc #t) (seen #f\
    \ (cons 0 seen)))\n    (cond ((null? l) acc)\n          ((eqv? (car l) (cadr l))\
    \ (loop (cdr l) (not acc) (cons (car l) seen)))\n          ((eqv? (car l) (caddr\
    \ l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n          ((eqv? (car l)\
    \ (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n          ((eqv?\
    \ (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n        \
    \  ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (", "  (cond [(null? l) #f]\n        [(equal? (first l) 0) #t]\n\
    \        [(equal? (first l) (- (first l)))\n         (triples_sum_to_zero (rest\
    \ l))]\n        [else (triples_sum_to_zero (rest l))]))\n", "  (let ((x (car l))\n\
    \        (c (car l))\n        (y (if (= x 0) c 0))\n        (z (if (= y 0) c 0))\n\
    \        (w (if (= z 0) c 0)))\n    (cond ((= x 0) (= y 0) (= z 0) (= w 0))\n\
    \          ((= x 0) (= y 0) (= z 0) (= w 1))\n          ((= x 0) (= y 0) (= z\
    \ 1) (= w 0))\n          ((= x 0) (= y 0) (= z 1) (= w 1))\n          ((= x 0)\
    \ (= y 0) (= z 0) (= w 0))\n          ((= x 0) (= y 0) (= z 0) (= w 1))\n    \
    \      ((= x 0) (= y 0) (= z 1) (= w 0))\n          ((= x 0) (= y 0) (= z 1) (=\
    \ w 1))\n          ((= x 0) (= y 1) (= z 0) (= w 0))\n          ((= x 0) (= y\
    \ 1) (= z 0) (= w 1))\n          ((= x 0) (= y 1) (= z 1) (= w 0))\n         \
    \ ((= x 0) (= y 1) (= z 1) (= w 1))\n          ((= x 0) (= y 1) (= z 0) (= w 0))\n\
    \          ((= x 0) (= y 1) (= z 0) (= w 1))\n          ((= x 0) (= y 1) (= z\
    \ 1) (= w 0))\n          ((= x 0) (= y 1) (= z 1) (= w 1))\n          ((= x 1)\
    \ (= y 0) (= z 0) (= w 0))\n          ((= x 1) (= y 0) (= z 0) (= w 1))\n    \
    \      ((= x 1) (= y 0) (= z 1) (= w 0))\n          ((= x 1) (= y 0) (= z 1) (=\
    \ w 1))\n          ((= x 1) (= y 0) (= z 0) (= w 0))\n          ((= x 1) (= y\
    \ 0) (= z 0) (= w 1))\n          ((= x 1) (= y 0) (= z 1) (= w 0))\n         \
    \ ((= x 1) (= y 0) (= z 1) (= w 1))\n          ((= x 1) (= y 0) (= z 0) (= w 0))\n\
    \          ((= x 1) (= y 0) (= z ", "  (let ((x (car l))\n        (y (second l))\n\
    \        (z (third l)))\n    (cond\n      [(= x y) #t]\n      [(= x z) #f]\n \
    \     [(= y z) #f]\n      [(= x z) #f]\n      [(= y z) #f]\n      [(= x y) #t]\n\
    \      [(= x z) #f]\n      [(= y z) #f]\n      [(= x z) #f]\n      [(= y z) #f]\n\
    \      [(= x y) #t]\n      [(= x z) #f]\n      [(= y z) #f]\n      [(= x z) #f]\n\
    \      [(= y z) #f]\n      [(= x y) #t]\n      [(= x z) #f]\n      [(= y z) #f]\n\
    \      [(= x z) #f]\n      [(= y z) #f]\n      [(= x y) #t]\n      [(= x z) #f]\n\
    \      [(= y z) #f]\n      [(= x z) #f]\n      [(= y z) #f]\n      [(= x y) #t]\n\
    \      [(= x z) #f]\n      [(= y z) #f]\n      [(= x z) #f]\n      [(= y z) #f]\n\
    \      [(= x y) #t]\n      [(= x z) #f]\n      [(= y z) #f]\n      [(= x z) #f]\n\
    \      [(= y z) #f]\n      [(= x y) #t]\n      [(= x z) #f]\n      [(= y z) #f]\n\
    \      [(= x z) #f]\n      [(= y z) #f]\n      [(= x y) #t]\n      [(= x z) #f]\n\
    \      [(= y z) #f]\n      [(= x z) #f]\n      [(= y z) #f]\n      [(= x y) #t]\n\
    \      [(= x z) #f]\n      [(= y z) #f]\n      [(= x z) #f]\n      [(= y z) #f]\n\
    \      [(= x y) #t]\n      [(= x z) #f]\n      [(= y z) #f]\n      [(= x z) #f]\n",
  "  (let loop ((l l) (acc #t))\n    (cond ((null? l) acc)\n          ((= (+ (car\
    \ l) (car l)) 0)\n           (loop (cdr l) (not acc)))\n          (else\n    \
    \       (loop (cdr l) (and acc (= (+ (car l) (car l)) 0))))))\n", "  (cond\n \
    \   [(empty? l) #f]\n    [(equal? (first l) 0) #t]\n    [else (triples_sum_to_zero\
    \ (rest l))]))\n", "  (cond [(null? l) #f]\n        [(= (length l) 3) #t]\n  \
    \      [(= (length l) 2) (= (first l) 0)]\n        [else (triples_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(equal? (first l) 0) #t]\n\
    \    [else (triples_sum_to_zero (rest l))]))\n", "  (let loop ((l l) (acc #t)\
    \ (seen #f (list 0 0)))\n    (cond ((null? l) acc)\n          ((eqv? (car l) (cadr\
    \ l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n          ((eqv? (car l)\
    \ (caddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n          ((eqv? (car\
    \ l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n          ((eqv?\
    \ (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n        \
    \  ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (car l) (cadddr l)) (loop (cdr l) (not acc) (cons (car l) seen)))\n\
    \          ((eqv? (c", "  (let loop ((l l) (acc #t))\n    (cond ((null? l) acc)\n\
    \          ((= (first l) (first l)) (loop (rest l) (not acc)))\n          ((=\
    \ (first l) (first l)) acc)\n          ((= (first l) (first l)) (loop (rest l)\
    \ (not acc)))\n          (else (loop (rest l) (or (not acc) (loop (rest l) (not\
    \ acc))))))))\n", "  (cond [(null? l) #f]\n        [(= (length l) 3) #t]\n   \
    \     [else (= (apply + l) 0)]))\n", "  (cond ((null? l) #f)\n        ((equal?\
    \ (first l) 0) #t)\n        (else (triples_sum_to_zero (rest l)))))\n", "  (let\
    \ loop ((l l) (acc #t) (seen #f (list l)))\n    (cond ((null? l) acc)\n      \
    \    ((eq? (car l) (cadr l)) (loop (cdr l) (not acc (car l)) seen))\n        \
    \  ((eq? (car l) (caddr l)) (loop (cdr l) (not acc (car l)) seen))\n         \
    \ ((eq? (car l) (cadddr l)) (loop (cdr l) (not acc (car l)) seen))\n         \
    \ (else (loop (cdr l) (and acc (eq? (car l) (cadddr l))) (cons (car l) seen))))))\n",
  "  (cond ((null? l) #f)\n        ((equal? (car l) (cadr l)) #t)\n        (else (triples_sum_to_zero\
    \ (cdr l)))))\n", "  (let loop ((l l) (acc 0))\n    (cond ((null? l) acc)\n  \
    \        ((= (first l) 0) (loop (rest l) (+ acc 1)))\n          (else (loop (rest\
    \ l) (+ acc (+ (first l) (second l) (third l))))))))\n", "  (let loop ((l l) (acc\
    \ #t) (i 0))\n    (cond ((null? l) acc)\n          ((= i 3) (set! acc (not acc)))\n\
    \          ((= i (car l)) (loop (cdr l) (not acc) (inc i)))\n          (else (loop\
    \ (cdr l) (and acc (= i (car l))) (inc i))))))\n", "  (cond [(null? l) #f]\n \
    \       [(= (length l) 3) #t]\n        [else (= (apply + l) 0)]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
