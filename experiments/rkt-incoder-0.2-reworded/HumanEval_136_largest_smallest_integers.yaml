name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns a list (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as #f.\n;; Examples:\n;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))\n\
  ;; (list #f 1)\n;; >>> (largest_smallest_integers (list ))\n;; (list #f #f)\n;;\
  \ >>> (largest_smallest_integers (list 0))\n;; (list #f #f)\n(define (largest_smallest_integers\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? lst)\n         (list #f #f)] \n        [(< (first\
    \ lst) 0)\n         (list #f (first lst))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (cond [(empty? lst)\n         (list #f #f)\n         ]\n\
    \        [(integer? (car lst))\n         (cons (car lst)\n               (largest_smallest_integers\
    \ (cdr lst)))\n         ]\n        [else\n         (largest_smallest_integers\
    \ (cdr lst))\n         ]))\n", "  (cond [(empty? lst) (list #f #f)] \n       \
    \ [(< (first lst) (first rest)) (cons (first lst) (largest_smallest_integers (rest\
    \ lst)))]\n        [else (largest_smallest_integers (rest lst))]))\n", "  (cond\
    \ [(empty? lst) (list #f #f)] \n        [(> (first lst) 0)\n         (cons (first\
    \ lst) (largest_smallest_integers (rest lst)))]\n        [else (largest_smallest_integers\
    \ (rest lst))]))\n", "  (cond\n    [(empty? lst) (list #f #f)]\n    [(number?\
    \ (first lst)) (cons (first lst) (largest_smallest_integers (rest lst)))]\n  \
    \  [else (cons (first lst) (largest_smallest_integers (rest lst)))]))\n", "  (cond\n\
    \    [(empty? lst) (list #f #f)]\n    [(integer? (first lst)) (list (first lst)\
    \ (first lst))]\n    [else (let ([a (largest_smallest_integers (rest lst))])\n\
    \            (cond\n              [(empty? a) (list #f #f)]\n              [(integer?\
    \ (first a)) (list (first a) (first a))]\n              [else (let ([b (largest_smallest_integers\
    \ (rest a))])\n                      (cond\n                        [(empty? b)\
    \ (list #f #f)]\n                        [(integer? (first b)) (list (first b)\
    \ (first b))]\n                        [else (list a (first b))])))]))]))\n",
  "  (cond [(empty? lst)\n         (list #f #f)\n         ]\n        [(< (first lst)\
    \ (first lst))\n         (list (first lst) (first lst))\n         ]\n        [else\n\
    \         (largest_smallest_integers (rest lst))\n         ]\n        ))\n", " \
    \ (cond [(empty? lst)\n         (list #f #f)] \n        [(< (first lst) 0)\n \
    \        (largest_smallest_integers (rest lst))]\n        [else \n         (largest_smallest_integers\
    \ (rest lst))]))\n", "  (cond ((null? lst)\n         #f)\n        ((< (car lst)\
    \ 0)\n         (cons (car lst)\n               (largest_smallest_integers (cdr\
    \ lst))))\n        (else\n         (largest_smallest_integers (cdr lst)))))\n",
  "  (cond [(empty? lst)\n         (list #f #f)\n         ]\n        [(integer? (first\
    \ lst))\n         (cons (first lst)\n              (largest_smallest_integers\
    \ (rest lst)))]\n        [else\n         (let ([a (largest_smallest_integers (first\
    \ lst))])\n           (cond [(< a b)\n                  (cons a\n            \
    \             (largest_smallest_integers (rest lst)))]\n                 [else\n\
    \                  (cons b\n                         (largest_smallest_integers\
    \ (rest lst)))]))]))\n", "  (cond [(empty? lst)\n         (list #f #f)] \n   \
    \     [(> (first lst) 0)\n         (cons (first lst) (largest_smallest_integers\
    \ (rest lst)))]\n        [else\n         (largest_smallest_integers (rest lst))]))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(< (first lst) 0) (list #f (first\
    \ lst))]\n    [else (list (max 0 (first lst)) (min 1 (first lst)))]))\n", "  (cond\n\
    \    [(empty? lst) (list #f #f)]\n    [(< (first lst) (first lst)) (list (first\
    \ lst) (first lst))]\n    [else (largest_smallest_integers (rest lst))]))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(> (first lst) (first lst)) (list\
    \ (first lst) (first lst))]\n    [else (largest_smallest_integers (rest lst))]))\n",
  "  (cond\n    [(empty? lst) (list #f #f)]\n    [(integer? (first lst)) (list first\
    \ lst)]\n    [else (let ([a (largest_smallest_integers (rest lst))])\n       \
    \     (cond\n              [(empty? a) (list #f #f)]\n              [(integer?\
    \ (first a)) (list first a)]\n              [else (let ([b (largest_smallest_integers\
    \ (rest a))])\n                      (cond\n                        [(empty? b)\
    \ (list #f #f)]\n                        [(integer? (first b)) (list first b)]\n\
    \                        [else (cons (first a) (first b))])))]))]))\n", "  (cond\n\
    \    [(empty? lst) (list #f #f)]\n    [(> (first lst) 0) (list (first lst) #f)]\n\
    \    [else (list (first lst) (largest_smallest_integers (rest lst)))]))\n", " \
    \ (cond [(empty? lst)\n         (list #f #f)\n         (< (first lst) (first lst))\n\
    \         (largest_smallest_integers (rest lst))]\n        [(< (first lst) (first\
    \ lst))\n         (list (first lst) (first lst))\n         (largest_smallest_integers\
    \ (rest lst))]\n        [else\n         (list (first lst) (first lst))\n     \
    \    (largest_smallest_integers (rest lst))]))\n", "  (cond [(empty? lst) (list\
    \ #f #f)] \n        [(integer? (car lst)) (cons (car lst) (largest_smallest_integers\
    \ (cdr lst)))]\n        [else (largest_smallest_integers (cdr lst))]))\n", " \
    \ (cond [(empty? lst)\n         (list #f #f)\n         ]\n        [(< (first lst)\
    \ 0)\n         (largest_smallest_integers (rest lst))\n         ]\n        [else\n\
    \         (largest_smallest_integers (rest lst))\n         ]\n        ))\n", " \
    \ (cond [(empty? lst)\n         (list #f #f)\n         ]\n        [(< (first lst)\
    \ (first rest))\n         (largest_smallest_integers (rest lst))\n         ]\n\
    \        [(< (first rest) (first lst))\n         (list (first lst) (first rest))\n\
    \         ]\n        [else\n         (largest_smallest_integers (rest lst))\n\
    \         ]\n        ))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
