name: HumanEval_18_how_many_times
language: rkt
prompt: "#lang racket\n\n;; Find how many times a given substring can be found in\
  \ the original string. Count overlaping cases.\n;; >>> (how_many_times \"\" \"a\"\
  )\n;; 0\n;; >>> (how_many_times \"aaa\" \"a\")\n;; 3\n;; >>> (how_many_times \"\
  aaaa\" \"aa\")\n;; 3\n(define (how_many_times string substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n\
  \    (check-equal? (candidate \"\" \"x\") 0)\n    (check-equal? (candidate \"xyxyxyx\"\
  \ \"x\") 4)\n    (check-equal? (candidate \"cacacacac\" \"cac\") 4)\n    (check-equal?\
  \ (candidate \"john doe\" \"john\") 1)\n))\n\n(test-humaneval)"
completions: ["  (let loop ((count 0) (index 0))\n    (if (string-empty? string)\n\
    \        count\n        (if (equal? substring (string-ref string index))\n   \
    \         (loop (+ count 1) (+ index 1))\n            (loop (+ count 1) index))))))\n",
  "  (let ((count 0))\n    (for ((i 0 (+ i 1))) (if (equal? string \"\") count (if\
    \ (equal? (substring i) string) (incf count) 0)))))\n", "  (cond\n    [(empty?\
    \ string) 0]\n    [(equal? (first string) substring) (+ 1 (how_many_times (rest\
    \ string) substring))]\n    [else (+ 1 (how_many_times (rest string) substring))]))\n",
  "  (let ((count 0))\n    (loop for i from 0 to (string-length string)\n        \
    \  for j from 0 to (string-length substring)\n          when (string= (string-ref\
    \ string i) (substring-ref substring j))\n          do (incf count)\n        \
    \  finally (return count))))\n", "  (let ((count 0))\n    (loop for i from 0 to\
    \ (string-length string)\n          for j from 0 to (string-length substring)\n\
    \          when (string= (string-ref string i) (string-ref substring j))\n   \
    \       do (incf count)\n          finally (return count))))\n", "  (cond\n  \
    \  [(empty? string) 0]\n    [(equal? (first string) substring) 1]\n    [else (+\
    \ 1 (how_many_times (rest string) substring))]))\n", "  (cond\n    [(empty? string)\
    \ 0]\n    [(equal? (first string) substring) 1]\n    [else (+ 1 (how_many_times\
    \ (rest string) substring))]))\n", "  (cond [(empty? string) 0]\n        [(equal?\
    \ (first string) substring) (+ 1 (how_many_times (rest string) substring))]\n\
    \        [else (+ 1 (how_many_times (rest string) (first string)))]))\n", "  (cond\n\
    \    [(empty? string) 0]\n    [(equal? (first string) substring) 1]\n    [else\
    \ (+ (how_many_times (rest string) substring) (how_many_times string (first string)))]))\n",
  "  (cond\n    [(empty? string) 0]\n    [(equal? (first string) substring) 1]\n \
    \   [else (+ 1 (how_many_times (rest string) substring))]))\n", "  (define (how_many\
    \ substring string count)\n    (cond\n      [(empty? string) count]\n      [(equal?\
    \ substring (car string)) (how_many substring (cdr string) (+ count 1))]\n   \
    \   [else (how_many substring (cdr string) (+ count 1))]))\n  (how_many substring\
    \ string 0))\n", "  (cond [(empty? string) 0]\n        [(equal? (first string)\
    \ substring) (+ 1 (how_many_times (rest string) substring))]\n        [else (+\
    \ (how_many_times (rest string) substring) (how_many_times (first string) substring))]))\n",
  "  (cond [(empty? string) 0]\n        [(equal? (substring string) (string-ref string\
    \ 0)) 1]\n        [else (+ 1 (how_many_times (string->list string) (substring\
    \ string)))]))\n", "  (let ((count 0))\n    (for-each (lambda (c)\n          \
    \      (if (string-equal? c substring)\n                    (set! count (add1\
    \ count))\n                    (set! count 0))\n              (string-length string))\n\
    \              string)))\n", "  (cond\n    [(empty? string) 0]\n    [(equal? (substring\
    \ string) \"\") 0]\n    [else (+ 1 (how_many_times (substring string) (substring\
    \ string)))]))\n", "  (cond [(empty? string) 0]\n        [(equal? (substring string)\
    \ (string-ref string 0)) 1]\n        [else (+ 1 (how_many_times (string->list\
    \ string) (substring string)))]))\n", "  (cond\n    [(empty? string) 0]\n    [(equal?\
    \ (first string) substring) 1]\n    [else (+ 1 (how_many_times (rest string) substring))]))\n",
  "  (cond [(empty? string) 0]\n        [(equal? (substring string) (string-ref string\
    \ 0)) 1]\n        [else (+ 1 (how_many_times (string->list string) (substring\
    \ string)))]))\n", "  (cond [(empty? string) 0]\n        [(equal? (substring string)\
    \ (string-ref string 0)) 1]\n        [else (+ 1 (how_many_times (string->list\
    \ string) (substring string)))]))\n", "  (cond [(empty? string) 0]\n        [(equal?\
    \ (substring string) substring) 1]\n        [else (+ 1 (how_many_times (rest string)\
    \ substring))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
