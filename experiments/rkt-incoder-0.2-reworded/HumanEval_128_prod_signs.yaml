name: HumanEval_128_prod_signs
language: rkt
prompt: "#lang racket\n\n;; You are given a list arr of integers and you need to return\n\
  ;; sum of magnitudes of integers multiplied by product of all signs\n;; of each\
  \ number in the list, represented by 1, -1 or 0.\n;; Note: return #f for empty arr.\n\
  ;; Example:\n;; >>> (prod_signs (list 1 2 2 -4))\n;; 9\n;; >>> (prod_signs (list\
  \ 0 1))\n;; 0\n;; >>> (prod_signs (list ))\n;; #f\n(define (prod_signs arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (if (null? arr)\n      #f\n      (+ (* 1 (expt (abs (first arr))\
    \ (length (rest arr))))\n         (prod_signs (rest arr)))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(zero? (first arr)) (first arr)]\n    [else (prod_signs\
    \ (rest arr))]))\n", "  (if (null? arr)\n      #f\n      (let ((sum (+ (abs (first\
    \ arr)) (abs (second arr)))))\n        (if (= (length arr) 2)\n            (*\
    \ sum (prod_signs (rest arr)))\n            (* sum (prod_signs (rest arr))\n \
    \               (+ (* -1 1 (first arr)) (* -1 1 (second arr))))))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (first arr)) (first arr)]\n    [else (prod_signs\
    \ (rest arr))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(positive? (first arr))\
    \ (* 1 (prod_signs (rest arr)))]\n    [(negative? (first arr)) (* -1 (prod_signs\
    \ (rest arr)))]\n    [else (* 0 (prod_signs (rest arr)))]))\n", "  (cond\n   \
    \ [(empty? arr) #f]\n    [(positive? (first arr)) (* 1 (prod_signs (rest arr)))]\n\
    \    [(negative? (first arr)) (* -1 (prod_signs (rest arr)))]\n    [else (* 0\
    \ (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero?\
    \ (first arr)) (first arr)]\n    [else (+ (* (first arr) -1) (prod_signs (rest\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(number? (first arr)) (*\
    \ 1 (first arr))]\n    [else (* -1 (prod_signs (rest arr)))]))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(positive? (first arr)) (* 1 (prod_signs (rest arr)))]\n\
    \    [(negative? (first arr)) (* -1 (prod_signs (rest arr)))]\n    [else (* 0\
    \ (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero?\
    \ (first arr)) (first arr)]\n    [else (prod_signs (rest arr))]))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(= (first arr) 0) 0]\n    [else (+ (* (first arr)\
    \ -1) (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero?\
    \ (first arr)) (first arr)]\n    [else (+ (* (first arr) (prod_signs (rest arr)))\n\
    \            (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(positive? (first arr)) (* 1 (prod_signs (rest arr)))]\n    [(negative?\
    \ (first arr)) (* -1 (prod_signs (rest arr)))]\n    [else (* 0 (prod_signs (rest\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(positive? (first arr))\
    \ (* 1 (prod_signs (rest arr)))]\n    [(negative? (first arr)) (* -1 (prod_signs\
    \ (rest arr)))]\n    [else (* 0 (prod_signs (rest arr)))]))\n", "  (cond\n   \
    \ [(empty? arr) #f]\n    [(zero? (first arr)) (first arr)]\n    [else (prod_signs\
    \ (rest arr))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (first arr))\
    \ (first arr)]\n    [else (+ (* (first arr) (prod_signs (rest arr)))\n       \
    \     (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero?\
    \ (first arr)) (first arr)]\n    [else (+ (* (first arr) (prod_signs (rest arr)))\n\
    \            (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(number? (first arr)) (* 1 (first arr))]\n    [else (* -1 (prod_signs (rest\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(number? (first arr)) (*\
    \ 1 (first arr))]\n    [else (* -1 (prod_signs (rest arr)))]))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (first arr)) (first arr)]\n    [else (prod_signs\
    \ (rest arr))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
