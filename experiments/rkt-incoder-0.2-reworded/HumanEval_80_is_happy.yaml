name: HumanEval_80_is_happy
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; Your task is to check if\
  \ the string is haprkt or not.\n;; A string is haprkt if its length is at least\
  \ 3 and every 3 consecutive letters are distinct\n;; For example:\n;; >>> (is_happy\
  \ a)\n;; #f\n;; >>> (is_happy aa)\n;; #f\n;; >>> (is_happy abcd)\n;; #t\n;; >>>\
  \ (is_happy aabb)\n;; #f\n;; >>> (is_happy adb)\n;; #t\n;; >>> (is_happy xyy)\n\
  ;; #f\n(define (is_happy s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n\
  \    (check-equal? (candidate \"a\") #f)\n    (check-equal? (candidate \"aa\") #f)\n\
  \    (check-equal? (candidate \"abcd\") #t)\n    (check-equal? (candidate \"aabb\"\
  ) #f)\n    (check-equal? (candidate \"adb\") #t)\n    (check-equal? (candidate \"\
  xyy\") #f)\n    (check-equal? (candidate \"iopaxpoi\") #t)\n    (check-equal? (candidate\
  \ \"iopaxioi\") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? s) #f]\n    [(or (not (even? (length s))) (not\
    \ (even? (length s) 2)))\n     (not (equal? (first s) (last (rest s))))]\n   \
    \ [else (and (equal? (first s) (last (rest s))) (equal? (second s) (third (last\
    \ s))))]))\n", "  (and (>= (length s) 3)\n       (for/fold ([i 0])\n         \
    \         ([j 0])\n                  ([k 0])\n                  ([l 0])\n    \
    \              ([m 0])\n                  ([n 0])\n                  ([o 0])\n\
    \                  ([p 0])\n                  ([q 0])\n                  ([r 0])\n\
    \                  ([s 0])\n                  ([t 0])\n                  ([u 0])\n\
    \                  ([v 0])\n                  ([w 0])\n                  ([x 0])\n\
    \                  ([y 0])\n                  ([z 0])\n                  ([a 0])\n\
    \                  ([b 0])\n                  ([c 0])\n                  ([d 0])\n\
    \                  ([e 0])\n                  ([f 0])\n                  ([g 0])\n\
    \                  ([h 0])\n                  ([i 0])\n                  ([j 0])\n\
    \                  ([k 0])\n                  ([l 0])\n                  ([m 0])\n\
    \                  ([n 0])\n                  ([o 0])\n                  ([p 0])\n\
    \                  ([q 0])\n                  ([r 0])\n                  ([s 0])\n\
    \                  ([t 0])\n                  ([u 0])\n                  ([v 0])\n\
    \                  ([w 0])\n                  ([x 0])\n                  ([y 0])\n\
    \                  ([z 0])\n                  ([a 0])\n                  ([b 0])\n\
    \                  ([c 0])\n                  ([d 0])\n                  ([e 0])\n\
    \                  ([f 0])\n                  ([g 0])\n                  ([h 0])\n\
    \                  ([i 0])\n                  ([j 0])\n                  ([k 0])\n\
    \                  ([l 0])\n                  ([m 0])\n                  ([n 0])\n\
    \                  ([o 0])\n                  ([p 0])\n                  ([q 0])\n\
    \                  ([r 0])\n                  ([s 0])\n                  ([t 0])\n\
    \                  ([u 0])\n                  ([v 0])\n                  ([w 0])\n\
    \                  ([x 0])\n                  ([y 0])\n                  ([z 0])\n\
    \                  ([a 0])\n                  ([b 0])\n                  ([c 0])\n\
    \                  ([d 0])\n                  ([e 0])\n                  ([f 0])\n\
    \                  ([g 0])\n                  ([h 0])\n                  ([i 0])\n\
    \                  ([j 0])\n                  ([k 0])\n                  ([l 0])\n\
    \                  ([m 0])\n                  ([n 0])\n                  ([o 0])\n\
    \                  ([p 0])\n                  ([q 0])\n                  ([r 0])\n\
    \                  ([s 0])\n                  ([t 0])\n                  ([u 0])\n\
    \                  ([v 0])\n                  ([w 0])\n                  ([x 0])\n\
    \                  ([y 0])\n                  ([z 0])\n                  ([a 0])\n\
    \                  ([b 0])\n                  ([c 0])\n                  ([d 0])\n",
  "  (cond\n    [(empty? s) #f]\n    [(>= (length s) 3) #f]\n    [(distinct (subseq\
    \ s 0 2)) #t]\n    [else #f]))\n", "  (cond\n    [(empty? s) #f]\n    [(or (not\
    \ (even? (length s))) (not (even? (length s) 2))) #f]\n    [(equal? (first s)\
    \ (first s)) #f]\n    [else (or (equal? (first s) (second s)) (equal? (first s)\
    \ (third s)) (equal? (first s) (fourth s)) (equal? (first s) (fifth s)) (equal?\
    \ (first s) (sixth s)) (equal? (first s) (seventh s)) (equal? (first s) (eighth\
    \ s)) (equal? (first s) (ninth s)) (equal? (first s) (tenth s)) (equal? (first\
    \ s) (eleventh s)) (equal? (first s) (twelfth s)) (equal? (first s) (thirteenth\
    \ s)) (equal? (first s) (fourteenth s)) (equal? (first s) (fifteenth s)) (equal?\
    \ (first s) (sixteenth s)) (equal? (first s) (seventeenth s)) (equal? (first s)\
    \ (eighteenth s)) (equal? (first s) (nineteenth s)) (equal? (first s) (twentieth\
    \ s)) (equal? (first s) (thirtieth s)) (equal? (first s) (fortieth s)) (equal?\
    \ (first s) (fiftieth s)) (equal? (first s) (sixtieth s)) (equal? (first s) (seventieth\
    \ s)) (equal? (first s) (eightieth s)) (equal? (first s) (ninetieth s)) (equal?\
    \ (first s) (twentyeth s)) (equal? (first s) (thirtyeth s)) (equal? (first s)\
    \ (fortyeth s)) (equal? (first s) (fiftyeth s)) (equal? (first s) (sixtyeth s))\
    \ (equal? (first s) (seventyeth s)) (equal? (first s) (eightyeth s)) (equal? (first\
    \ s) (ninetyeth s)) (equal? (first s) (twentyoneth s)) (equal? (first s) (thirtyoneth\
    \ s)) (equal? (first s) (fortyoneth s)) (equal? (first s) (fiftyoneth s)) (equal?\
    \ (first s) (sixtyoneth s)) (equal? (first s) (seventyoneth s)) (equal? (first\
    \ s) (eightyoneth s)) (equal? (first s) (ninetyoneth s)) (equal? (first s) (twentytwoth\
    \ s)) (equal? (first s) (thirtytwoth s)) (equal? (first s) (forty", "  (and (>=\
    \ (length s) 3)\n       (for/fold ([i 0]) ([j 0]) (lambda ([x y])\n          \
    \                      (if (equal? (char-code x) (char-code y))\n            \
    \                        (set! i (add1 i))\n                                 \
    \   (set! j (add1 j))\n                                    (return (and (< i 3)\
    \ (< j 3))))))))\n", "  (and (>= (length s) 3)\n       (for/fold ((counts #{})\
    \ (letter #\\a)) ((i (length s))\n                          (if (equal? (substring\
    \ s i i) letter)\n                              (set! counts (cons letter counts))\n\
    \                              counts))\n       (not (empty? counts))))\n", " \
    \ (or (= (length s) 3)\n      (and (= (length s) 3)\n           (distinct-letters\
    \ s))))\n", "  (and (>= (length s) 3)\n       (every (lambda (x) (distinct (substring\
    \ s 0 x) (substring s x (length s))))\n               (range (length s)))))\n",
  "  (or (= (length s) 3)\n      (and (= (length s) 3)\n           (distinct-letters\
    \ s))))\n", "  (cond\n    [(empty? s) #f]\n    [(= (length s) 3) #t]\n    [(=\
    \ (length s) (* 3 2)) (= (distinct (subseq s 0 2)) (distinct (subseq s 2 4)))]\n\
    \    [else #f]))\n", "  (and (>= (length s) 3)\n       (every (lambda (x) (distinct\
    \ (substring s 0 x) (substring s x (length s))))\n               (range (length\
    \ s) 3))))\n", "  (cond\n    [(empty? s) #f]\n    [(= (length s) 3) #t]\n    [(=\
    \ (length s) (* 3 2)) #f]\n    [(= (length s) (* 3 1)) #t]\n    [(= (length s)\
    \ (* 3 0)) #t]\n    [else (and (equal? (first s) (second s)) (equal? (second s)\
    \ (third s)) (equal? (third s) (fourth s)) (equal? (fourth s) (fifth s)) (equal?\
    \ (fifth s) (sixth s)) (equal? (sixth s) (seventh s)) (equal? (seventh s) (eigth\
    \ s)) (equal? (eigth s) (ninth s)) (equal? (ninth s) (tenth s)) (equal? (tenth\
    \ s) (eleventh s)) (equal? (eleventh s) (twelfth s)) (equal? (twelfth s) (thirteenth\
    \ s)) (equal? (thirteenth s) (fourteenth s)) (equal? (fourteenth s) (fifteenth\
    \ s)) (equal? (fifteenth s) (sixteenth s)) (equal? (sixteenth s) (seventeenth\
    \ s)) (equal? (seventeenth s) (eighteenth s)) (equal? (eighteenth s) (nineteenth\
    \ s)) (equal? (nineteenth s) (twentieth s)) (equal? (twentieth s) (thirtieth s))\
    \ (equal? (thirtieth s) (fortieth s)) (equal? (fortieth s) (fiftieth s)) (equal?\
    \ (fiftieth s) (sixtieth s)) (equal? (sixtieth s) (seventieth s)) (equal? (seventieth\
    \ s) (eightieth s)) (equal? (eightieth s) (ninetieth s)) (equal? (ninetieth s)\
    \ (twennieth s)) (equal? (twennieth s) (thirnieth s)) (equal? (thirnieth s) (fornieth\
    \ s)) (equal? (fornieth s) (fiftieth s)) (equal? (fiftieth s) (sixtieth s)) (equal?\
    \ (sixtieth s) (seventieth s)) (equal? (seventieth s) (eightieth s)) (equal? (eightieth\
    \ s) (ninetieth s)) (equal? (ninetieth s) (twennieth s)) (equal? (twennieth s)\
    \ (thirnieth s)) (", "  (cond\n    [(empty? s) #f]\n    [(= (length s) 3) #t]\n\
    \    [(= (length s) 2) #t]\n    [(= (length s) 1) #t]\n    [else (and (= (length\
    \ s) 3) (distinct (subseq s 0 (- 3 (length s)))))]))\n", "  (and (>= (length s)\
    \ 3)\n       (every (lambda (x) (distinct (substring s 0 x) (substring s x 3)))\
    \ \n               (range (length s)))))\n", "  (and (>= (length s) 3)\n     \
    \  (for/fold ((counts #{}) (i 0))\n                  ((c (car s))\n          \
    \         (if (not (member (car s) counts))\n                       (set! counts\
    \ (cons (car s) counts))\n                       (set! i (+ i 1))))\n        \
    \          (= i 3)))\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your answer.\
    \ I am not allowed to use any looping constructs. I only can use recursion.\n\
    <|/ c |>\n<| c |>\nI added a solution without loops.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. I am not allowed to use any looping constructs. I only can\
    \ use recursion.\n<|/ c |>\n<| c |>\nI added a solution without loops.\n<|/ c\
    \ |>\n<| c |>\nThanks for your answer. I am not allowed to use any looping constructs.\
    \ I only can use recursion.\n<|/ c |>\n<| a tags=racket,scheme |>\n<code>", " \
    \ (cond\n    [(empty? s) #f]\n    [(>= (length s) 3) #f]\n    [(distinct (subseq\
    \ s 0 2)) #t]\n    [else #f]\n  )\n)\n", "  (cond\n    [(empty? s) #f]\n    [(>=\
    \ (length s) 3) #f]\n    [(distinct? s) #f]\n    [else (and (distinct? (substring\
    \ s 0 (length s)) (substring s (+ 0 (length s)) (+ 0 (length s))))\n         \
    \    (distinct? (substring s (+ 0 (+ 0 (length s)) (+ 0 (+ 0 (length s))))\n \
    \                       (substring s (+ 0 (+ 0 (+ 0 (length s))) (+ 0 (+ 0 (+\
    \ 0 (length s))))))])))\n", "  (and (>= (length s) 3)\n       (for/fold ((counts\
    \ #{}) (letter #\\a)) ((i (length s))\n                             ((letter (substring\
    \ s i (add1 i)))\n                              (if (not (member (letter letter)\
    \ counts))\n                                  (set! counts (cons (letter letter)\
    \ counts))\n                                  (set! letter (substring s i (add1\
    \ i))))))\n       (not (empty? counts))))\n", "  (or (= (length s) 3)\n      (and\
    \ (= (length s) 3)\n           (not (distinct-letters s)))))\n", "  (cond\n  \
    \  [(empty? s) #f]\n    [(>= (length s) 3) #f]\n    [(distinct (subseq (string\
    \ s) 0 3) (subseq (string s) 1 4)) #f]\n    [else #t]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
