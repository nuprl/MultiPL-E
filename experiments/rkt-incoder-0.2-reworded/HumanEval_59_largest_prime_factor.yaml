name: HumanEval_59_largest_prime_factor
language: rkt
prompt: "#lang racket\n\n;; Return the largest prime factor of n. Assume n > 1 and\
  \ is not a prime.\n;; >>> (largest_prime_factor 13195)\n;; 29\n;; >>> (largest_prime_factor\
  \ 2048)\n;; 2\n(define (largest_prime_factor n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_prime_factor))\n\
  \    (check-equal? (candidate 15) 5)\n    (check-equal? (candidate 27) 3)\n    (check-equal?\
  \ (candidate 63) 7)\n    (check-equal? (candidate 330) 11)\n    (check-equal? (candidate\
  \ 13195) 29)\n))\n\n(test-humaneval)"
completions: ["  (let loop ((n n) (prime 1))\n    (cond ((= n 1) prime)\n        \
    \  ((even? n) (loop (/ n 2) prime))\n          ((odd? n) (loop (* n 3) prime))\n\
    \          (else (loop (* n prime) (+ prime (quotient n prime)))))))\n", "  (cond\
    \ [(= n 1) 1]\n        [(= n 2) 2]\n        [(= n 3) 3]\n        [(= n 4) 4]\n\
    \        [(= n 5) 5]\n        [(= n 6) 6]\n        [(= n 7) 7]\n        [(= n\
    \ 8) 8]\n        [(= n 9) 9]\n        [(= n 10) 10]\n        [(= n 11) 11]\n \
    \       [(= n 12) 12]\n        [(= n 13) 13]\n        [(= n 14) 14]\n        [(=\
    \ n 15) 15]\n        [(= n 16) 16]\n        [(= n 17) 17]\n        [(= n 18) 18]\n\
    \        [(= n 19) 19]\n        [(= n 20) 20]\n        [(= n 21) 21]\n       \
    \ [(= n 22) 22]\n        [(= n 23) 23]\n        [(= n 24) 24]\n        [(= n 25)\
    \ 25]\n        [(= n 26) 26]\n        [(= n 27) 27]\n        [(= n 28) 28]\n \
    \       [(= n 29) 29]\n        [(= n 30) 30]\n        [(= n 31) 31]\n        [(=\
    \ n 32) 32]\n        [(= n 33) 33]\n        [(= n 34) 34]\n        [(= n 35) 35]\n\
    \        [(= n 36) 36]\n        [(= n 37) 37]\n        [(= n 38) 38]\n       \
    \ [(= n 39) 39]\n        [(= n 40) 40]\n        [(= n 41) 41]\n        [(= n 42)\
    \ 42]\n        [(= n 43) 43]\n        [(= n 44) 44]\n        [(= n 45) 45]\n \
    \       [(= n 46) 46]\n        [(= n 47) 47]\n        [(= n 48) 48]\n        [(=\
    \ n 49) 49]\n        [(= n 50) 50]\n        [(= n 51) 51]\n        [(= n 52) 52]\n\
    \        [(= n 53) 53]\n        [(= n 54) 54]\n        [(= n 55) 55]\n       \
    \ [(= n 56) 56]\n        [(= n 57) 57]\n        [(= n 58) 58]\n        [(= n 59)\
    \ 59", "  (let loop ((n n) (max 1) (prime (primes n)))\n    (cond ((= n 1) prime)\n\
    \          ((= n max) max)\n          ((= (modulo n prime) 0) (loop (quotient\
    \ n prime) (+ max 1) prime))\n          :else (loop (quotient n prime) (+ max\
    \ 1) (+ prime (primes n))))))\n", "  (cond [(= n 1) 1]\n        [(= n 2) 2]\n\
    \        [(= n 3) 3]\n        [(= n 4) 4]\n        [(= n 5) 5]\n        [(= n\
    \ 6) 6]\n        [(= n 7) 7]\n        [(= n 8) 8]\n        [(= n 9) 9]\n     \
    \   [(= n 10) 10]\n        [(= n 11) 11]\n        [(= n 12) 12]\n        [(= n\
    \ 13) 13]\n        [(= n 14) 14]\n        [(= n 15) 15]\n        [(= n 16) 16]\n\
    \        [(= n 17) 17]\n        [(= n 18) 18]\n        [(= n 19) 19]\n       \
    \ [(= n 20) 20]\n        [(= n 21) 21]\n        [(= n 22) 22]\n        [(= n 23)\
    \ 23]\n        [(= n 24) 24]\n        [(= n 25) 25]\n        [(= n 26) 26]\n \
    \       [(= n 27) 27]\n        [(= n 28) 28]\n        [(= n 29) 29]\n        [(=\
    \ n 30) 30]\n        [(= n 31) 31]\n        [(= n 32) 32]\n        [(= n 33) 33]\n\
    \        [(= n 34) 34]\n        [(= n 35) 35]\n        [(= n 36) 36]\n       \
    \ [(= n 37) 37]\n        [(= n 38) 38]\n        [(= n 39) 39]\n        [(= n 40)\
    \ 40]\n        [(= n 41) 41]\n        [(= n 42) 42]\n        [(= n 43) 43]\n \
    \       [(= n 44) 44]\n        [(= n 45) 45]\n        [(= n 46) 46]\n        [(=\
    \ n 47) 47]\n        [(= n 48) 48]\n        [(= n 49) 49]\n        [(= n 50) 50]\n\
    \        [(= n 51) 51]\n        [(= n 52) 52]\n        [(= n 53) 53]\n       \
    \ [(= n 54) 54]\n        [(= n 55) 55]\n        [(= n 56) 56]\n        [(= n 57)\
    \ 57]\n        [(= n 58) 58]\n        [(= n 59) 59", "  (let loop ((n n) (p 2))\n\
    \    (cond ((= n 1) p)\n          ((even? n) (loop (/ n p) (+ p 1)))\n       \
    \   ((odd? n) (loop (/ n p) (+ p 2))))\n    (loop (/ n p) p)))\n", "  (if (= n\
    \ 1)\n      n\n      (let loop ((n n) (p 2))\n        (if (= (modulo n p) 0)\n\
    \            (loop (quotient n p) (+ p 1))\n            (loop (quotient n p) (+\
    \ p 2))))))\n", "  (if (= n 1)\n      1\n      (let ((factor (prime-factors n)))\n\
    \        (if (null? factor)\n            n\n            (max (car factor) (largest_prime_factor\
    \ (cdr factor)))))))\n", "  (let loop ((n n) (prime 1))\n    (cond ((= n 1) prime)\n\
    \          ((even? n) (loop (/ n 2) prime))\n          ((odd? n) (loop (* n 3)\
    \ prime))\n          (else (loop (* n prime) (+ prime (quotient n prime)))))))\n",
  "  (cond [(= n 1) n]\n        [(= (modulo n 2) 0) (/ n 2)]\n        [else (largest_prime_factor\
    \ (quotient n 2))]))\n", "  (if (= n 1)\n      n\n      (let ((factors (prime-factors\
    \ n)))\n        (if (null? factors)\n            n\n            (let ((largest\
    \ (car factors)))\n              (if (> n largest)\n                  largest\n\
    \                  (largest_prime_factor (/ n largest))))))))\n", "  (cond [(=\
    \ n 1) 1]\n        [(= (mod n 2) 0) (largest_prime_factor (/ n 2))]\n        [else\
    \ (* n (largest_prime_factor (/ n 2)))]))\n", "  (cond [(= n 1) 2]\n        [(=\
    \ (modulo n 2) 0) (largest_prime_factor (/ n 2))]\n        [else (+ 1 (largest_prime_factor\
    \ (/ n 2)))]))\n", "  (if (= n 1)\n      n\n      (let ((factor (prime-factors\
    \ n)))\n        (if (null? factor)\n            n\n            (if (> (length\
    \ factor) 2)\n                (first factor)\n                (first factor)))))\n",
  "  (cond [(= n 1) n]\n        [(= (modulo n 2) 0) (largest_prime_factor (/ n 2))]\n\
    \        [else (* n (largest_prime_factor (/ n 2)))]))\n", "  (let loop ((n n)\
    \ (primes #{}))\n    (cond ((= n 1) (length primes))\n          ((prime? (car\
    \ primes)) (loop (cdr n) (cons (car primes) primes)))\n          (else (loop (cdr\
    \ n) (cons (car primes) primes))))))\n", "  (let loop ((n n) (prime (primes n)))\n\
    \    (cond ((= n 1) prime)\n          ((= (modulo n prime) 0) (loop (quotient\
    \ n prime) (+ prime 1)))\n          (else (loop (quotient n prime) (+ prime 1))))))\n",
  "  (let loop ((n n) (p 2))\n    (if (= n 1)\n        p\n        (loop (quotient\
    \ n p)\n              (if (= (modulo n p) 0)\n                  (+ 1 (loop (quotient\
    \ n p) (+ p 1)))\n                  (loop (quotient n p) (+ p 1))))))))\n", " \
    \ (let loop ((n n) (max 1) (prime (prime? n)))\n    (cond ((= n 1) prime)\n  \
    \        ((= n max) n)\n          ((prime? n) (loop (quotient n max) (+ max 1)\
    \ (quotient n 2)))\n          (else (loop (quotient n max) (+ max 1) prime))))))\n",
  "  (if (= n 1)\n      n\n      (let ((factor (prime-factors n)))\n        (if (null?\
    \ factor)\n            n\n            (if (> (length factor) 2)\n            \
    \    (let ((largest (car factor)))\n                  (if (= largest)\n      \
    \                n\n                      (largest_prime_factor (/ n largest))))))))\n",
  "  (let loop ((n n) (p 2))\n    (cond ((= n 1) p)\n          ((even? n) (loop (/\
    \ n p) (+ p 1)))\n          (else (loop (/ n p) (+ p 1))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
