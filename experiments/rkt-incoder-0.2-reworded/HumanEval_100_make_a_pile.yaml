name: HumanEval_100_make_a_pile
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer n, you have to make a pile of\
  \ n levels of stones.\n;; The first level has n stones.\n;; The number of stones\
  \ in the next level is:\n;; - the next odd number if n is odd.\n;; - the next even\
  \ number if n is even.\n;; Return the number of stones in each level in a list,\
  \ where element at index\n;; i represents the number of stones in the level (i+1).\n\
  ;; Examples:\n;; >>> (make_a_pile 3)\n;; (list 3 5 7)\n(define (make_a_pile n)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate make_a_pile))\n\
  \    (check-equal? (candidate 3) (list 3 5 7))\n    (check-equal? (candidate 4)\
  \ (list 4 6 8 10))\n    (check-equal? (candidate 5) (list 5 7 9 11 13))\n    (check-equal?\
  \ (candidate 6) (list 6 8 10 12 14 16))\n    (check-equal? (candidate 8) (list 8\
  \ 10 12 14 16 18 20 22))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(zero? n) '()]\n    [(odd? n) (cons (+ n (floor (/ n\
    \ 2))) (make_a_pile (- n 2)))]\n    [(even? n) (cons (+ n (floor (/ n 2))) (make_a_pile\
    \ (- n 2)))]\n    [else (make_a_pile (- n 1))]))\n", "  (cond\n    [(zero? n)\
    \ '()]\n    [(odd? n) (list (+ n 1))]\n    [(even? n) (list (+ n 2))]\n    [else\
    \ (error \"make_a_pile called with invalid argument: ~a\" n)]))\n", "  (if (zero?\
    \ n)\n      '()\n      (let ((next (if (odd? n) (add1 (modulo (+ n 2) n)) (modulo\
    \ n 2))))\n        (cons next (make_a_pile next)))))\n", "  (if (= n 0)\n    \
    \  '()\n      (let ((next (if (even? n) (+ n 1) (- n 1))))\n        (cons next\
    \ (make_a_pile next)))))\n", "  (if (= n 0)\n      '()\n      (cons (floor (/\
    \ n 2)) (make_a_pile (- n 2)))))\n", "  (if (= n 0)\n      '()\n      (cons (+\
    \ (mod n 2) (* 2 (make-a_pile (- n 1))))\n            (make_a_pile (- n 1)))))\n",
  "  (if (= n 0)\n      '()\n      (cons (- n (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor (/ n 2))\n              (floor (/ n 2))\n   \
    \           (floor (/ n 2))\n              (floor (/ n 2))\n              (floor\
    \ (/ n 2))\n              (floor", "  (cond\n    [(= n 0) '()]\n    [(odd? n)\
    \ (cons (+ n 1) (make_a_pile (/ n 2)))]\n    [(even? n) (cons (+ n 2) (make_a_pile\
    \ (/ n 2)))]\n    [else (make_a_pile (/ n 2))]))\n", "  (if (= n 0)\n      '()\n\
    \      (cons (floor (/ n 2)) (make_a_pile (- n 2)))))\n", "  (if (= n 0)\n   \
    \   '()\n      (cons (- n (floor (/ n 2))\n              (if (even? n)\n     \
    \             (floor (/ n 2))\n                  (floor (/ n 2))))\n         \
    \   (make_a_pile (- n 1)))))\n", "  (let ([stones (make-list n #f)]\n        [level\
    \ (make-list n #f)]\n        [count (make-list n #f)]\n        [pile (make-list\
    \ n #f)])\n    (set! count (make-list n #f))\n    (set! pile (make-list n #f))\n\
    \    (set! level (make-list n #f))\n    (set! stones (make-list n #f))\n    (set!\
    \ count (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count\
    \ (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list\
    \ n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n\
    \    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n    (set!\
    \ count (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count\
    \ (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list\
    \ n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n\
    \    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n    (set!\
    \ count (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count\
    \ (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list\
    \ n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n\
    \    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n    (set!\
    \ count (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count\
    \ (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list\
    \ n #f))\n    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n\
    \    (set! count (make-list n #f))\n    (set! count (make-list n #f))\n    (set!\
    \ count (make-list n #f))\n    (set! count (make-list n #f))\n    (set! count\
    \ (make-list n #f", "  (if (= n 0)\n      '()\n      (cons (- n (floor (/ n 2)))\
    \ (make_a_pile (- n 1)))))\n", "  (cond\n    [(= n 0) (list 0)]\n    [(even? n)\
    \ (list (+ n 2))]\n    [(odd? n) (list (+ n 1))]))\n", "  (if (= n 0)\n      '()\n\
    \      (let ((next (if (even? n) (+ n 2) (+ n 1))))\n        (cons next (make_a_pile\
    \ next)))))\n", "  (cond\n    [(= n 0) '()]\n    [(even? n) (cons (- n 2) (make_a_pile\
    \ (/ n 2)))]\n    [else (cons (- n 3) (make_a_pile (/ n 3)))]))\n", "  (cond\n\
    \    [(zero? n) '()]\n    [(odd? n) (cons (+ n (floor (/ n 2))) (make_a_pile (-\
    \ n 1)))]\n    [else (cons (+ n (floor (/ n 2))) (make_a_pile (- n 1)))]))\n",
  "  (if (= n 0)\n      '()\n      (cons (- n (floor (/ n 2))\n               (if\
    \ (even? n)\n                   (floor (/ n 2))\n                   (floor (/\
    \ n 2))))\n            (make_a_pile (- n 1)))))\n", "  (if (= n 0)\n      '()\n\
    \      (cons (if (even? n)\n                (* 2 (odd? n))\n                (*\
    \ 2 (even? n)))\n            (make_a_pile (- n 1)))))\n", "  (cond\n    [(= n\
    \ 0) (list 0)]\n    [(even? (modulo n 2)) (cons (+ n 1) (make_a_pile (/ n 2)))]\n\
    \    [else (cons (+ n 1) (make_a_pile (/ n 2)))]))\n", "  (cond\n    [(= n 0)\
    \ '()]\n    [(even? n) (cons (- n (odd? n)) (make_a_pile (/ n 2)))]\n    [else\
    \ (cons (- n (even? n)) (make_a_pile (/ n 2)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
