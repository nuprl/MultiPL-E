{
  "name": "mbpp_286_max_sub_array_sum_repeated",
  "language": "r",
  "prompt": "# Write a function to find the largest sum of a contiguous vector in the modified vector which is formed by repeating the given vector k times.\nmax_sub_array_sum_repeated <- function(a, n, k) {",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py",
  "prompt_terminology": "reworded",
  "tests": "test_humaneval <- function() {\ncandidate <- max_sub_array_sum_repeated\n    if(!identical(candidate(c(10, 20, -30, -1), 4, 3), 30)){quit('no', 1)}\n    if(!identical(candidate(c(-1, 10, 20), 3, 2), 59)){quit('no', 1)}\n    if(!identical(candidate(c(-1, -2, -3), 3, 3), -1)){quit('no', 1)}\n}\ntest_humaneval()",
  "stop_tokens": [
    "\n#",
    "\n```"
  ],
  "completions": [
    "\n    # kadane's algorithm to find max subarray sum\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0) {\n            max_ending_here <- 0\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far <- max_ending_here\n        }\n    }\n    # case 1: when the array has all non-negative numbers\n    if (max_so_far > 0) {\n        return (max_so_far * k)\n    }\n    # case 2: when the array has all negative numbers\n    max_so_far <- 0\n    for (i in 1:n) {\n        max_so_far <- max_so_far + a[i]\n    }\n    # case 3: when there are both positive and negative numbers in the array\n    max_prefix_sum <- 0\n    max_suffix_sum <- 0\n    prefix_sum <- 0\n    suffix_sum <- 0\n    for (i in 1:n) {\n        prefix_sum <- prefix_sum + a[i]\n        if (max_prefix_sum < prefix_sum) {\n            max_prefix_sum <- prefix_sum\n        }\n    }\n    for (i in n:1) {\n        suffix_sum <- suffix_sum + a[i]\n        if (max_suffix_sum < suffix_sum) {\n            max_suffix_sum <- suffix_sum\n        }\n    }\n    return (max(max_so_far, max_prefix_sum + max_suffix_sum + max_so_far))\n}\n",
    "\n    # Write your code here\n    max_sum <- 0\n    for (i in 1:n) {\n        curr_sum <- 0\n        for (j in i:n) {\n            curr_sum <- curr_sum + a[j]\n            max_sum <- max(max_sum, curr_sum)\n        }\n    }\n    return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n  max_element = max(a)\n  # Initialize starting point\n  start = 0\n  end = 0\n  s = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Initialize sum of this block\n    curr_max = 0\n    curr_start = i\n    # Calculate sum of this block\n    for (j in 1:n) {\n      curr_max = curr_max + a[j]\n      # If sum is less than 0, then this block cannot contribute to the sum in the contiguous subarray\n      if (curr_max < 0) {\n        curr_max = 0\n        curr_start = j + 1\n      }\n      # Update maximum sum of subarray found so far\n      if (max_so_far < curr_max) {\n        max_so_far = curr_max\n        start = curr_start\n        end = j\n      }\n    }\n  }\n  # If all numbers are negative, then return maximum element\n  if (max_so_far == 0) {\n    max_so_far = max_element\n  }\n  # Return maximum sum\n  return (max_so_far)\n}\n",
    "\n  # kadane's algorithm to find maximum sum subarray in a 1D array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Case 1: when the max sum subarray is in middle\n  max_sum <- max_so_far\n  \n  # Case 2: when the max sum subarray is split\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  \n  # max sum with corner elements will be:\n  # array-sum - (-max subarray sum of inverted array)\n  max_wrap <- max_wrap + max_sub_array_sum(a, n)\n  \n  # The maximum circular sum will be maximum of two sums\n  if (max_wrap > max_sum) {\n    max_sum <- max_wrap\n  }\n  \n  return(max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum of elements from i'th\n            # block to j'th block is more\n            # than max_sum so far, then\n            # update max_sum\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    # Return maximum sum\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # kadane's algorithm to find maximum sum subarray in a 1D array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # Case 1: when the max sum subarray crosses the midpoint\n  max_subarray_sum <- max_so_far\n  # Case 2: when the max sum subarray does not cross the midpoint\n  # Find the maximum element in the array\n  max_element <- max(a)\n  # If all the elements are negative, then the maximum element is the answer\n  if (max_element < 0) {\n    return (max_element)\n  }\n  # Case 2: when the max sum subarray does not cross the midpoint\n  # Find the maximum prefix sum\n  max_prefix_sum <- 0\n  for (i in 1:n) {\n    max_prefix_sum <- max_prefix_sum + a[i]\n    if (max_prefix_sum < 0) {\n      max_prefix_sum <- 0\n    }\n  }\n  # Find the maximum suffix sum\n  max_suffix_sum <- 0\n  for (i in n:1) {\n    max_suffix_sum <- max_suffix_sum + a[i]\n    if (max_suffix_sum < 0) {\n      max_suffix_sum <- 0\n    }\n  }\n  # Find the maximum sum by excluding the maximum prefix and the maximum suffix sums\n  max_exclude_prefix_suffix_sum <- 0\n  for (i in 1:n) {\n    max_exclude_prefix_suffix_sum <- max_exclude_prefix_suffix_sum + a[i]\n    if (max_exclude_prefix_suffix_sum < 0) {\n      max_exclude_prefix_suffix_sum <-",
    "\n    # Create a temporary array to store\n    # sum of all subarrays. temp[i] stores\n    # sum of subarray from a[0] to a[i]\n    temp <- rep(0, n)\n    temp[1] <- a[1]\n    for (i in 2:n) {\n        temp[i] <- temp[i - 1] + a[i]\n    }\n    # Create a variable to store maximum sum\n    # and initialize it as minimum value\n    max_sum <- -Inf\n    # Calculate sum of subarrays and update\n    # max_sum if required\n    for (i in 1:n) {\n        for (j in i:n) {\n            sum <- temp[j] - temp[i - 1]\n            if (i > 1) {\n                sum <- sum + (k - 1) * temp[n]\n            }\n            if (sum > max_sum) {\n                max_sum <- sum\n            }\n        }\n    }\n    return(max_sum)\n}",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0) {\n            max_ending_here <- 0\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far <- max_ending_here\n        }\n    }\n    if (k == 1) {\n        return (max_so_far)\n    }\n    max_val <- max(a)\n    if (max_val <= 0) {\n        return (max_val)\n    }\n    max_prefix_sum <- 0\n    max_suffix_sum <- 0\n    curr_prefix_sum <- 0\n    curr_suffix_sum <- 0\n    for (i in 1:n) {\n        curr_prefix_sum <- curr_prefix_sum + a[i]\n        if (max_prefix_sum < curr_prefix_sum) {\n            max_prefix_sum <- curr_prefix_sum\n        }\n    }\n    for (i in n:1) {\n        curr_suffix_sum <- curr_suffix_sum + a[i]\n        if (max_suffix_sum < curr_suffix_sum) {\n            max_suffix_sum <- curr_suffix_sum\n        }\n    }\n    ans <- max(max_so_far, max_prefix_sum + max_suffix_sum + (k - 2) * max_prefix_sum)\n    return (ans)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    current_sum = 0\n    for (j in 1:n) {\n      current_sum = current_sum + a[j]\n \n      # If i is the starting index of a block, then update max_sum\n      if (i + j - 1 == k * n) {\n        max_sum = max(max_sum, current_sum)\n        break\n      }\n    }\n  }\n  return(max_sum)\n}\n ",
    "\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n  max_element = 0\n  # Find the max sum subarray in first window of size n\n  for (i in 1:n) {\n    max_ending_here = max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here\n    }\n    if (a[i] > max_element) {\n      max_element = a[i]\n    }\n  }\n  # Compute sums of remaining windows by removing first element of previous window and adding last element of current window.\n  for (i in 2:k) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[j]\n    }\n    curr_sum = curr_sum + max_so_far\n    if (curr_sum > max_so_far) {\n      max_so_far = curr_sum\n    }\n  }\n  # Return maximum sum\n  return (max(max_so_far, max_element * k))\n}\n",
    "\n    # Initialize result\n    max_so_far = 0\n    max_ending_here = 0\n    max_element = 0\n    min_element = 0\n    min_so_far = 0\n    # Find the max sum subarray in first window of size n\n    for (i in 1:n) {\n        max_ending_here = max_ending_here + a[i]\n        if (a[i] > max_element) {\n            max_element = a[i]\n        }\n        if (a[i] < min_element) {\n            min_element = a[i]\n        }\n    }\n    # Compute sums of remaining windows by removing first element of previous window and adding last element of current window.\n    for (i in n+1:n*k) {\n        max_ending_here = max_ending_here - a[i-n] + a[i]\n        if (max_ending_here > max_so_far) {\n            max_so_far = max_ending_here\n        }\n        if (a[i] > max_element) {\n            max_element = a[i]\n        }\n        if (a[i] < min_element) {\n            min_element = a[i]\n        }\n    }\n    # If all elements are negative\n    if (max_so_far == 0) {\n        max_so_far = max_element\n    }\n    # If all elements are positive\n    if (max_so_far == 0) {\n        max_so_far = max_so_far + (k-2)*max_element\n    }\n    # If all elements are positive and at-least one element is 0\n    if (max_so_far == 0) {\n        max_so_far = max_so_far + (k-2)*max_element\n    }\n    # If all elements are negative and at-least one element is 0\n    if (max_so_far == 0) {\n        max_so_far = max_element\n    }\n    return(max_so_far)\n}\n",
    "\n  # kadane's algorithm to find maximum sum subarray in a 1D array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Case 1: when the max sum subarray is in the first k-1 elements\n  max_so_far_1 <- max_sub_array_sum(a, n)\n  \n  # Case 2: when the max sum subarray is in the last k-1 elements\n  max_so_far_2 <- max_sub_array_sum(a, n)\n  \n  # Case 3: when the max sum subarray is in between the first and last k-1 elements\n  max_so_far_3 <- max_so_far\n  \n  # return the maximum of the three cases\n  return(max(max_so_far_1, max_so_far_2, max_so_far_3))\n}\n",
    "\n  # kadane's algorithm to find max sum\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # case 1: when the array has all non-negative numbers\n  if (max_so_far > 0) {\n    return (max_so_far * k)\n  }\n  # case 2: when the array has all negative numbers\n  max_so_far <- 0\n  for (i in 1:n) {\n    max_so_far <- max_so_far + a[i]\n  }\n  # max sum is sum of the array\n  max_so_far <- max_so_far * k\n  # case 3: when there are both positive and negative numbers\n  # for this, we need to find the total sum of the array\n  # and subtract the minimum sub array sum from the total sum\n  # to find the maximum sum\n  min_so_far <- 0\n  min_ending_here <- 0\n  for (i in 1:n) {\n    min_ending_here <- min_ending_here + a[i]\n    if (min_ending_here > 0) {\n      min_ending_here <- 0\n    }\n    if (min_so_far > min_ending_here) {\n      min_so_far <- min_ending_here\n    }\n  }\n  return (max(max_so_far, sum(a) * k - min_so_far))\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum of elements from i'th\n            # to j'th is greater than max_sum\n            # update max_sum\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    # Return maximum sum\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Consider all blocks ending with j\n    for (j in i:n) {\n      # Sum of current block\n      curr_sum = curr_sum + a[j]\n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum is negative, no need to\n      # continue\n      if (curr_sum < 0) {\n        break\n      }\n      # Update result if required\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  # Return result for current test case\n  return(max_sum * k)\n}\n",
    "\n    max_sum <- 0\n    for (i in 1:n) {\n        curr_sum <- 0\n        for (j in i:n) {\n            curr_sum <- curr_sum + a[j]\n            max_sum <- max(max_sum, curr_sum)\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return (k * max_sum)\n}\n",
    "\n  # Write your code here\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_sub_array_sum <- max_so_far\n  for (i in 1:n) {\n    max_sub_array_sum <- max_sub_array_sum + a[i]\n  }\n  if (k == 1) {\n    return (max_sub_array_sum)\n  }\n  min_sub_array_sum <- 0\n  min_so_far <- 0\n  min_ending_here <- 0\n  for (i in 1:n) {\n    min_ending_here <- min_ending_here + a[i]\n    if (min_ending_here > 0) {\n      min_ending_here <- 0\n    }\n    if (min_so_far > min_ending_here) {\n      min_so_far <- min_ending_here\n    }\n  }\n  min_sub_array_sum <- min_so_far\n  for (i in 1:n) {\n    min_sub_array_sum <- min_sub_array_sum + a[i]\n  }\n  if (k == 2) {\n    return (max(max_sub_array_sum, sum(a) - min_sub_array_sum))\n  }\n  return (max(max_sub_array_sum, sum(a) * (k - 2) + max_sub_array_sum))\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (max_wrap > max_subarray_sum) {\n    max_subarray_sum <- max_wrap\n  }\n  return(max_subarray_sum)\n}\n",
    "\n    # a is the array, n is the length of the array, k is the number of times to repeat the array\n    # initialize the sum of the array\n    max_so_far <- 0\n    # initialize the sum of the array\n    max_ending_here <- 0\n    # initialize the sum of the array\n    max_element <- 0\n    # initialize the sum of the array\n    min_element <- 0\n    # initialize the sum of the array\n    sum_of_array <- 0\n    # loop through the array\n    for (i in 1:n) {\n        # add the element to the sum of the array\n        sum_of_array <- sum_of_array + a[i]\n        # if the element is greater than the max element\n        if (a[i] > max_element) {\n            # set the max element to the element\n            max_element <- a[i]\n        }\n        # if the element is less than the min element\n        if (a[i] < min_element) {\n            # set the min element to the element\n            min_element <- a[i]\n        }\n        # add the element to the sum of the array\n        max_ending_here <- max_ending_here + a[i]\n        # if the sum of the array is less than 0\n        if (max_ending_here < 0) {\n            # set the sum of the array to 0\n            max_ending_here <- 0\n        }\n        # if the sum of the array is greater than the max sum of the array\n        if (max_so_far < max_ending_here) {\n            # set the max sum of the array to the sum of the array\n            max_so_far <- max_ending_here\n        }\n    }\n    # if the sum of the array is greater than 0\n    if (sum_of_array > 0) {\n        # return the max sum of the array times the number of times to repeat the array\n        return (max_so_far * k)\n    }\n    # if the sum of the array is less than 0\n    if (sum_of_array < 0) {\n        # if the max element is greater than 0\n        if (max_element",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n\nmax_sub_array_sum_repeated(a, n, k)\n",
    "\n  # max_so_far stores the maximum sum of subarray found so far\n  max_so_far <- 0\n  # max_ending_here stores the maximum sum of subarray ending with a[i]\n  max_ending_here <- 0\n  # max_element stores the maximum element in the given array\n  max_element <- max(a)\n  # If maximum element is negative, then return maximum element\n  if (max_element < 0) {\n    return (max_element)\n  }\n  # max_subarray_sum stores the maximum sum of subarray of the original array\n  max_subarray_sum <- 0\n  # Compute the sum of the original array\n  for (i in 1:n) {\n    max_subarray_sum <- max_subarray_sum + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    max_ending_here <- max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # If maximum sum is negative, then return maximum sum\n  if (max_subarray_sum < 0) {\n    return (max_subarray_sum)\n  }\n  # Return maximum of following two possible cases:\n  # 1) Maximum subarray sum of the original array\n  # 2) Maximum subarray sum of the modified array\n  return (max(max_so_far, max_subarray_sum * k))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  # Maximum sum is sum of all elements of\n  # A when k is 1.\n  return (max_sum * k)\n}",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k - 2)\n  return (max(max_so_far, max_wrap))\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k - 2)\n  return (max(max_so_far, max_wrap))\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return(max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- a[i] * -1\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k - 1)\n  if (max_wrap > max_so_far) {\n    return(max_wrap)\n  }\n  return(max_so_far)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum < 0)\n        curr_sum = 0\n      if (curr_sum > max_sum)\n        max_sum = curr_sum\n    }\n  }\n \n  # Return maximum sum\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return(max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- a[i] * -1\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k - 1)\n  return(max(max_so_far, max_wrap))\n}\n",
    "\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n \n  # Find the maximum sum subarray in first window of size k\n  for (i in 1:k)\n    max_ending_here = max_ending_here + a[i]\n \n  # Compute sums of remaining windows by removing first element of previous\n  # window and adding last element of current window.\n  for (i in k+1:n) {\n    max_ending_here = max_ending_here + a[i] - a[i-k]\n    max_so_far = max(max_so_far, max_ending_here)\n  }\n \n  return(max_so_far)\n}\n ",
    "\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n \n  # Initialize ending index\n  end = 0\n \n  # Consider all blocks starting with i.\n  for (i in 1:n) {\n    # Initialize current sum for each block\n    curr_sum = 0\n \n    # Calculate sum of current block\n    for (j in 1:k) {\n      curr_sum = curr_sum + a[i]\n    }\n \n    # Update max_so_far, if needed\n    max_ending_here = max(max_ending_here + curr_sum, 0)\n    max_so_far = max(max_so_far, max_ending_here)\n  }\n \n  return(max_so_far)\n}\n ",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Compute sum of elements in current block\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  return(max_sum * k)\n}\n",
    "\n    # kadane's algorithm to find maximum sum subarray in a given array\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0) {\n            max_ending_here <- 0\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far <- max_ending_here\n        }\n    }\n    # Case 1: when the array elements are all negative\n    if (max_so_far == 0) {\n        max_so_far <- max(a)\n        if (max_so_far < 0) {\n            return(max_so_far)\n        }\n    }\n    # Case 2: when the array has all positive elements\n    sum_total <- sum(a)\n    if (sum_total > 0) {\n        return(sum_total * k)\n    }\n    # Case 3: when the array has both positive and negative elements\n    max_val <- max_so_far\n    min_val <- 0\n    for (i in 1:n) {\n        min_val <- min_val + a[i]\n        if (min_val > 0) {\n            min_val <- 0\n        }\n        if (min_val < max_val) {\n            max_val <- min_val\n        }\n    }\n    return(max(max_so_far, sum_total * (k - 2) + max_val))\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k - 2)\n  return (max(max_so_far, max_wrap))\n}\n",
    "\n  # Initialize result\n  max_so_far <- 0\n  max_ending_here <- 0\n  # Find the sum of subarray with k elements\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n  }\n  # Iterate through the remaining subarrays of size k and maintain the maximum sum\n  # of the subarray\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here - a[i] + a[(i + n) %% n]\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  return(max_so_far)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum of elements from i'th\n            # to j'th is more than current\n            # maximum, update it\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = -Inf\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Compute sum of elements on left of arr[i]\n    curr_sum = 0\n    for (j in 1:i) {\n      curr_sum = curr_sum + a[j]\n    }\n    \n    # Compute sum of elements between i and j\n    # j is computed such that j % n = i % n\n    j = i\n    while (j <= k * n) {\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n      \n      # Add current element to current sum\n      if (j % n == 0) {\n        curr_sum = 0\n      }\n      curr_sum = curr_sum + a[j % n + 1]\n      j = j + 1\n    }\n  }\n  \n  return(max_sum)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, 1)\n  if (max_wrap > max_so_far) {\n    return (max_wrap)\n  }\n  return (max_so_far)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # max sum is sum of max subarray sum of all blocks.\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n \n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n \n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n ",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  max_sum <- 0\n  for (i in 1:k) {\n    curr_max <- 0\n    curr_sum <- 0\n    for (j in 1:n) {\n      curr_sum <- curr_sum + a[j]\n      if (curr_sum < 0) {\n        curr_sum <- 0\n      }\n      if (curr_max < curr_sum) {\n        curr_max <- curr_sum\n      }\n    }\n    max_sum <- max_sum + curr_max\n  }\n  return(max_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum is negative, no need to\n      # continue\n      if (curr_sum < 0)\n        break\n      # Update result if required\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  # Return result for current test case\n  return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum of elements from i'th\n            # to j'th is more than current\n            # sum, update it\n            if (curr_sum > max_sum)\n                max_sum = curr_sum\n        }\n    }\n    # Return maximum sum\n    return (max_sum * k)\n}\n",
    "\n  # kadane's algorithm to find maximum subarray sum\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # Case 1: when the array has all non-negative numbers\n  if (max_so_far > 0) {\n    return (max_so_far * k)\n  }\n  # Case 2: when the array has all negative numbers\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # Case 3: when there are both positive and negative numbers\n  # The maximum element of the original array (without kadane's algorithm)\n  max_element <- max(a)\n  # The sum of the original array\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n  }\n  # The maximum sum is maximum of the following three\n  # 1) Maximum subarray sum\n  # 2) Maximum subarray sum of the modified array formed by repeating the original array once.\n  # 3) Maximum subarray sum of the modified array formed by repeating the original array twice.\n  return (max(max_so_far, max_wrap + max_so_far, max_wrap + max_so_far + max_element))\n}\n",
    "\n  max_so_far <- -Inf\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_subarray_sum(a, n, k)\n  if (k == 1) {\n    return(max(max_subarray_sum, max_wrap))\n  }\n  return(max(max_subarray_sum, max_wrap, max_subarray_sum(a, n, k - 1)))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  \n  # max sum is sum of max subarray sum of each block\n  # multiplied by k\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_so_far <- 0\n  max_ending_here <- 0\n  # Initialize starting point for all k arrays\n  start <- 0\n  end <- 0\n  s <- 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Initialize sum of this block\n    curr_max <- 0\n    # Traverse through all elements and add the\n    # elements to curr_max\n    for (j in 1:k) {\n      curr_max <- curr_max + a[(i + j - 1) %% n]\n    }\n    # Update result if required\n    if (curr_max > max_so_far) {\n      max_so_far <- curr_max\n      start <- s\n      end <- i - 1\n    }\n    # Update max_ending_here and s for next iteration\n    if (curr_max > max_ending_here) {\n      max_ending_here <- curr_max\n      s <- i\n    }\n  }\n  # Print the result\n  print(max_so_far)\n  print(start)\n  print(end)\n}\n",
    "\n  max_sum <- 0\n  for (i in 1:n) {\n    curr_sum <- 0\n    for (j in 1:k) {\n      curr_sum <- curr_sum + a[i]\n      if (curr_sum > max_sum) {\n        max_sum <- curr_sum\n      }\n    }\n  }\n  return(max_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i.\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # max sum is sum of max subarray sum of each block\n  # multiplied by k\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  # Find the sum of the first subarray\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the middle subarrays\n  max_sum <- max_so_far\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the last subarray\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the middle subarrays\n  max_sum <- max_so_far\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the last subarray\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i",
    "\n  # Find the maximum sum subarray in first k elements.\n  max_sum = 0\n  curr_sum = 0\n  for (i in 1:n) {\n    curr_sum = curr_sum + a[i]\n    if (curr_sum < 0)\n      curr_sum = 0\n    if (curr_sum > max_sum)\n      max_sum = curr_sum\n  }\n  \n  # Find the maximum sum of subarray starting with or ending with first element of the array.\n  max_wrap = 0\n  for (i in 1:n) {\n    max_wrap = max_wrap + a[i]\n    a[i] = -a[i]\n  }\n  \n  # Find the maximum sum of subarray ending with last element.\n  curr_sum = 0\n  for (i in 1:n) {\n    curr_sum = curr_sum + a[i]\n    if (curr_sum > max_sum)\n      max_sum = curr_sum\n  }\n  \n  # Find the maximum sum of subarray starting with last element.\n  curr_sum = 0\n  for (i in 1:n) {\n    curr_sum = curr_sum + a[i]\n    if (curr_sum > max_sum)\n      max_sum = curr_sum\n  }\n  \n  # Return maximum of all the above sums.\n  return (max(max_sum, max_wrap))\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (k == 2) {\n    return(max(max_subarray_sum, max_wrap))\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k - 2)\n  return(max(max_subarray_sum, max_wrap))\n}\n",
    "\n  # Find the sum of the first subarray\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # Find the sum of the middle subarrays\n  max_so_far_middle <- 0\n  max_ending_here_middle <- 0\n  for (i in 1:n) {\n    max_ending_here_middle <- max_ending_here_middle + a[i]\n    if (max_ending_here_middle < 0) {\n      max_ending_here_middle <- 0\n    }\n    if (max_so_far_middle < max_ending_here_middle) {\n      max_so_far_middle <- max_ending_here_middle\n    }\n  }\n  # Find the sum of the last subarray\n  max_so_far_last <- 0\n  max_ending_here_last <- 0\n  for (i in 1:n) {\n    max_ending_here_last <- max_ending_here_last + a[i]\n    if (max_ending_here_last < 0) {\n      max_ending_here_last <- 0\n    }\n    if (max_so_far_last < max_ending_here_last) {\n      max_so_far_last <- max_ending_here_last\n    }\n  }\n  # Find the sum of the middle subarrays\n  max_so_far_middle <- 0\n  max_ending_here_middle <- 0\n  for (i in 1:n) {\n    max_ending_here_middle <- max_ending_here_middle + a[i]\n    if (max_ending_here_middle < 0) {\n      max_ending_here_middle <- 0\n    }\n    if (max_so_far_middle < max_ending_here",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Consider all blocks ending with j\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    current_sum = 0\n \n    # Calculate sum of current block\n    for (j in i:n) {\n      current_sum = current_sum + a[j]\n \n      # Update result if required\n      if (current_sum > max_sum) {\n        max_sum = current_sum\n      }\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return(max_sum*k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum is negative, then\n            # this subarray does not\n            # contribute to sum of\n            # elements in the modified\n            # array\n            if (curr_sum < 0)\n                curr_sum = 0\n            # Update maximum sum\n            # found so far\n            max_sum = max(max_sum, curr_sum)\n        }\n    }\n    # Return maximum sum\n    return (max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum_k <- max_so_far * k\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, 1)\n  if (max_wrap > max_subarray_sum_k) {\n    return (max_wrap)\n  } else {\n    return (max_subarray_sum_k)\n  }\n}\n",
    "\n    # Find the sum of the first subarray\n    max_so_far <- sum(a[1:n])\n    max_ending_here <- max_so_far\n    \n    # Find the sum of the remaining subarrays\n    for (i in 2:k) {\n        max_ending_here <- max(max_ending_here + sum(a[1:n]) - sum(a[1:n]), sum(a[1:n]))\n        max_so_far <- max(max_so_far, max_ending_here)\n    }\n    \n    return(max_so_far)\n}\n",
    "\n  max_so_far <- -Inf\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_subarray_sum(a, n, k)\n  if (k == 2) {\n    return(max(max_subarray_sum, max_wrap))\n  }\n  else {\n    return(max(max_subarray_sum, max_wrap, max_subarray_sum(a, n, k - 1)))\n  }\n}\n",
    "\n  # Find the sum of the first subarray\n  # and initialize the result\n  max_so_far = 0\n  for (i in 1:n) {\n    max_so_far = max_so_far + a[i]\n  }\n  \n  # Initialize the sum of the elements in the\n  # previous subarray\n  max_ending_here = 0\n  \n  # Find the sum of the 2nd subarray and compare\n  # it with the maximum sum so far\n  for (i in 1:n) {\n    max_ending_here = max_ending_here + a[i]\n    max_ending_here = max_ending_here % n\n    max_so_far = max(max_so_far, max_ending_here)\n  }\n  \n  # Find the sum of the 3rd subarray and compare\n  # it with the maximum sum so far\n  for (i in 1:n) {\n    max_ending_here = max_ending_here + a[i]\n    max_ending_here = max_ending_here % n\n    max_so_far = max(max_so_far, max_ending_here)\n  }\n  \n  # Return the maximum sum of the three\n  # contiguous subarrays\n  return (max_so_far % n)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # Calculate the sum of first window of size n\n  max_sum = 0\n  for (i in 1:n) {\n    max_sum = max_sum + a[i]\n  }\n  # Compute sums of remaining windows by\n  # removing first element of previous\n  # window and adding last element of\n  # current window.\n  curr_sum = max_sum\n  for (i in n+1:length(a)) {\n    curr_sum = curr_sum + a[i] - a[i-n]\n    max_sum = max(max_sum, curr_sum)\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_so_far <- 0\n  max_ending_here <- 0\n  max_element <- -Inf\n  min_element <- Inf\n  # Find the sum of subarray [0, i] and store it in max_ending_here\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_element < a[i]) {\n      max_element <- a[i]\n    }\n    if (min_element > a[i]) {\n      min_element <- a[i]\n    }\n    # If max_ending_here is negative, set it to 0\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    # Update max_so_far\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # If all elements are negative\n  if (max_so_far == 0) {\n    max_so_far <- max_element\n  }\n  # If all elements are positive\n  if (min_element >= 0) {\n    max_so_far <- max_so_far + (k - 2) * sum(a)\n  }\n  return(max_so_far)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  # kadane's algorithm to find max subarray sum\n  max_so_far <- a[1]\n  max_ending_here <- a[1]\n  for (i in 2:n) {\n    max_ending_here <- max(a[i], max_ending_here + a[i])\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  max_subarray_sum <- max_so_far\n  \n  # find max sum of subarray formed by repeating the array k times\n  max_prefix_sum <- 0\n  max_suffix_sum <- 0\n  sum <- 0\n  for (i in 1:n) {\n    sum <- sum + a[i]\n    max_prefix_sum <- max(max_prefix_sum, sum)\n  }\n  sum <- 0\n  for (i in n:1) {\n    sum <- sum + a[i]\n    max_suffix_sum <- max(max_suffix_sum, sum)\n  }\n  max_subarray_sum_repeated <- max(max_subarray_sum, max_prefix_sum + max_suffix_sum + (k - 2) * sum)\n  return(max_subarray_sum_repeated)\n}\n",
    "\n  # Find the sum of the first subarray\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the middle subarrays\n  max_sum <- max_so_far\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the last subarray\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the middle subarrays\n  max_sum <- max_so_far\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the last subarray\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (max_wrap > max_subarray_sum) {\n    max_subarray_sum <- max_wrap\n  }\n  return(max_subarray_sum)\n}\n",
    "\n    max_kadane <- function(a, n) {\n        max_so_far <- a[1]\n        max_ending_here <- a[1]\n        for (i in 2:n) {\n            max_ending_here <- max(a[i], max_ending_here + a[i])\n            max_so_far <- max(max_so_far, max_ending_here)\n        }\n        return(max_so_far)\n    }\n    max_wrap <- function(a, n) {\n        max_wrap <- 0\n        for (i in 1:n) {\n            max_wrap <- max_wrap + a[i]\n        }\n        return(max_wrap)\n    }\n    max_kadane <- max_kadane(a, n)\n    max_wrap <- max_wrap(a, n)\n    if (k == 1) {\n        return(max_kadane)\n    }\n    return(max(max_kadane, max_wrap + (k - 2) * max_wrap))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n    # Calculate the sum of the first window of size n\n    max_sum = 0\n    for (i in 1:n) {\n        max_sum = max_sum + a[i]\n    }\n    # Compute sums of remaining windows by removing first element of previous window and adding last element of current window\n    curr_sum = max_sum\n    for (i in n+1:length(a)) {\n        curr_sum = curr_sum + a[i] - a[i-n]\n        max_sum = max(max_sum, curr_sum)\n    }\n    # The maximum sum is k times the max sum of a subarray of size n in the given array\n    return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n \n    # Calculate sum of current block\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n]\n    }\n \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n ",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum)\n                max_sum = curr_sum\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0;\n  \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0;\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j];\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum;\n      }\n    }\n  }\n  \n  # Return maximum sum\n  return (max_sum * k);\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    \n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      \n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  \n  return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_val <- max(a)\n  if (max_val <= 0) {\n    return (max_val)\n  }\n  max_prefix_sum <- 0\n  max_suffix_sum <- 0\n  curr_prefix_sum <- 0\n  curr_suffix_sum <- 0\n  for (i in 1:n) {\n    curr_prefix_sum <- curr_prefix_sum + a[i]\n    if (curr_prefix_sum > max_prefix_sum) {\n      max_prefix_sum <- curr_prefix_sum\n    }\n  }\n  for (i in n:1) {\n    curr_suffix_sum <- curr_suffix_sum + a[i]\n    if (curr_suffix_sum > max_suffix_sum) {\n      max_suffix_sum <- curr_suffix_sum\n    }\n  }\n  max_single_repeat_sum <- max_prefix_sum + max_suffix_sum\n  return (max(max_single_repeat_sum, max_so_far + (k - 2) * max_prefix_sum))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Compute sum of elements in current block\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum of elements from i'th\n      # to j'th is more than current\n      # sum, update it\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return maximum sum\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i.\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n \n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n \n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n ",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Consider all blocks ending with j\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Compute sum of elements in current block\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Compute sum of elements in current block\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum is negative, no need to\n      # continue\n      if (curr_sum < 0)\n        break\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  # Return maximum sum\n  return(max_sum * k)\n}\n",
    "\n  # max_so_far stores the maximum subarray sum found so far\n  max_so_far <- 0\n  # max_ending_here stores the maximum subarray sum ending at a[i]\n  max_ending_here <- 0\n  # max_element stores the maximum element in the array\n  max_element <- 0\n  # max_index stores the index of the maximum element in the array\n  max_index <- 0\n  # max_sum stores the maximum sum of a contiguous vector in the modified vector\n  max_sum <- 0\n  # i is used to iterate over the array\n  i <- 1\n  # j is used to iterate over the array\n  j <- 1\n  # k_count stores the number of times the array has been repeated\n  k_count <- 1\n  # n_count stores the number of elements in the array\n  n_count <- 1\n  # flag is used to check if the maximum element is at the end of the array\n  flag <- 0\n  # temp stores the maximum subarray sum ending at a[i]\n  temp <- 0\n  # temp_index stores the index of the maximum subarray sum ending at a[i]\n  temp_index <- 0\n  # temp_sum stores the maximum sum of a contiguous vector in the modified vector\n  temp_sum <- 0\n  # temp_max_sum stores the maximum sum of a contiguous vector in the modified vector\n  temp_max_sum <- 0\n  # temp_max_index stores the index of the maximum sum of a contiguous vector in the modified vector\n  temp_max_index <- 0\n  # temp_max_element stores the maximum element in the array\n  temp_max_element <- 0\n  # temp_max_index stores the index of the maximum element in the array\n  temp_max_index <- 0\n  # temp_flag is used to check if the maximum element is at the end of the array\n  temp_flag <- 0\n  # temp_k_count stores the number of times the array has been repeated\n  temp_k_count <- 1\n  # temp_n_count stores the number of elements in the array\n  temp_n_count <- 1\n  # temp_max_so_far stores the maximum subarray sum found so far\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n    }\n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n)\n  if (max_wrap > max_so_far) {\n    max_so_far <- max_wrap\n  }\n  return(max_so_far * k)\n}\n",
    "\n  # Find the sum of the first sub-array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Find the sum of the middle sub-arrays\n  max_sum <- max_so_far\n  for (i in 1:n) {\n    max_sum <- max_sum + a[i]\n  }\n  \n  # Find the sum of the last sub-array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Return the maximum of the three sums\n  max(max_sum, max_so_far)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return(max_sum * k)\n}\n ",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in 1:n) {\n            curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n            max_sum = max(max_sum, curr_sum)\n        }\n    }\n    return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (max_so_far == 0) {\n    max_so_far <- max(a)\n  }\n  max_so_far * k\n}\n",
    "\n  # Find the sum of the first subarray\n  max_so_far <- sum(a)\n  # Find the sum of the next subarray\n  max_ending_here <- sum(a)\n  # Find the sum of the next subarray\n  for (i in 2:n) {\n    max_ending_here <- max_ending_here + a[i] - a[i-n]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # Return the maximum sum of the subarray\n  return(max_so_far * k)\n}",
    "\n  # Write your code here\n  max_so_far <- a[1]\n  max_ending_here <- a[1]\n  for (i in 2:n) {\n    max_ending_here <- max(a[i], max_ending_here + a[i])\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  max_so_far * k\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n \n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n \n      # If sum is greater than maximum sum so far\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return maximum sum\n  return (max_sum * k)\n}\n ",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return(max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, 1)\n  if (max_wrap > max_so_far) {\n    return(max_wrap)\n  } else {\n    return(max_so_far)\n  }\n}\n",
    "\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n  max_element = 0\n  min_element = 0\n  # Compute sum of first window of size k\n  for (i in 1:k) {\n    max_ending_here = max_ending_here + a[i]\n    if (a[i] > max_element) {\n      max_element = a[i]\n    }\n    if (a[i] < min_element) {\n      min_element = a[i]\n    }\n  }\n  # Compute sums of remaining windows by removing first element of previous window and adding last element of current window.\n  for (i in k+1:n) {\n    max_ending_here = max_ending_here + a[i] - a[i-k]\n    if (a[i] > max_element) {\n      max_element = a[i]\n    }\n    if (a[i] < min_element) {\n      min_element = a[i]\n    }\n    if (max_ending_here > max_so_far) {\n      max_so_far = max_ending_here\n    }\n  }\n  # Return maximum sum\n  if (max_so_far == 0) {\n    return(max_element * k)\n  } else {\n    return(max_so_far)\n  }\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Calculate sum of current block\n        for (j in 1:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum is negative, reset it\n            if (curr_sum < 0) {\n                curr_sum = 0\n            }\n            # Update result if required\n            max_sum = max(max_sum, curr_sum)\n        }\n    }\n    # Return result\n    return(max_sum * k)\n}",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n    }\n \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n ",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum is negative, no need to\n      # continue\n      if (curr_sum < 0)\n        break\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  # Return maximum sum\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      \n      # Update result if required\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  \n  # Return result for current test case\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum of elements from i'th\n      # to j'th is more than current\n      # sum, update it\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return maximum sum\n  return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      if (curr_sum > max_sum)\n        max_sum = curr_sum\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return(max_sum * k)\n}",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n ",
    "\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0)\n            max_ending_here <- 0\n        if (max_so_far < max_ending_here)\n            max_so_far <- max_ending_here\n    }\n    if (max_so_far == 0) {\n        max_so_far <- max(a)\n        if (max_so_far < 0)\n            return(max_so_far)\n    }\n    max_wrap <- 0\n    for (i in 1:n) {\n        max_wrap <- max_wrap + a[i]\n        a[i] <- -a[i]\n    }\n    max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k)\n    return(max(max_so_far, max_wrap))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return(max_sum * k)\n}",
    "\n    max_sum <- 0\n    for (i in 1:n) {\n        curr_max <- 0\n        curr_sum <- 0\n        for (j in 1:k) {\n            curr_sum <- curr_sum + a[(i + j - 1) %% n + 1]\n            curr_max <- max(curr_max, curr_sum)\n        }\n        max_sum <- max(max_sum, curr_max)\n    }\n    return(max_sum)\n}\n",
    "\n  # kadane's algorithm to find max subarray sum\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # case 1: when the array has all non-negative numbers\n  if (max_so_far > 0) {\n    return (max_so_far * k)\n  }\n  # case 2: when the array has all negative numbers\n  max_so_far <- 0\n  for (i in 1:n) {\n    max_so_far <- max_so_far + a[i]\n  }\n  # case 3: when there are both positive and negative numbers in the array\n  max_prefix_sum <- 0\n  max_suffix_sum <- 0\n  for (i in 1:n) {\n    max_prefix_sum <- max_prefix_sum + a[i]\n    if (max_prefix_sum < 0) {\n      max_prefix_sum <- 0\n    }\n  }\n  for (i in n:1) {\n    max_suffix_sum <- max_suffix_sum + a[i]\n    if (max_suffix_sum < 0) {\n      max_suffix_sum <- 0\n    }\n  }\n  return (max(max_so_far, max_prefix_sum + max_suffix_sum))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n    }\n \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Find the sum of the original array\n  max_sum = 0\n  for (i in 1:n) {\n    max_sum = max_sum + a[i]\n  }\n  # Find the sum of the middle elements\n  mid_sum = 0\n  for (i in (n+1)/2:n) {\n    mid_sum = mid_sum + a[i]\n  }\n  # Initialize the result\n  max_sum = max(max_sum, mid_sum)\n  # Traverse middle elements and find the maximum sum\n  # The loop runs k times because the elements repeat k times\n  for (i in 1:(k-1)) {\n    mid_sum = mid_sum + a[n - ((n-1)/2) + i]\n    mid_sum = mid_sum - a[i]\n    max_sum = max(max_sum, mid_sum)\n  }\n  return(max_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # kadane's algorithm to find max sum subarray in 1D array\n  max_so_far <- a[1]\n  max_ending_here <- a[1]\n  for (i in 2:n) {\n    max_ending_here <- max(a[i], max_ending_here + a[i])\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  max_kadane <- max_so_far\n  \n  # case: when all elements are negative\n  if (max_kadane < 0) {\n    return (max_kadane)\n  }\n  \n  # case: when at-least one element is positive\n  # compute sum of the entire array\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n  }\n  \n  # compute max sum of subarray that can be formed by\n  # repeating the original array k times\n  max_wrap <- max_wrap * k\n  \n  # return maximum of kadane's algorithm and max wrap\n  return (max(max_kadane, max_wrap))\n}\n",
    "\n  # Write your code here\n  max_so_far <- -Inf\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n  }\n  max_sub_array_sum <- max_so_far\n  for (i in 1:n) {\n    max_sub_array_sum <- max_sub_array_sum + a[i]\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_so_far <- -Inf\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n  }\n  max_wrap <- max_wrap + max_so_far\n  if (k == 1) {\n    return(max_sub_array_sum)\n  }\n  if (max_wrap > max_sub_array_sum) {\n    return(max_wrap)\n  }\n  return(max_sub_array_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i.\n  for (i in 1:n) {\n    curr_sum = 0\n \n    # Calculate sum of current block\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n \n      # If sum is greater than maximum sum so far,\n      # update maximum sum\n      if (curr_sum > max_sum)\n        max_sum = curr_sum\n    }\n  }\n \n  # Return maximum sum\n  return (max_sum * k)\n}\n ",
    "\n  # kadane's algorithm to find max sum subarray in 1D array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Case 1: when the array elements are all negative\n  if (max_so_far == 0) {\n    max_so_far <- max(a)\n    if (max_so_far < 0) {\n      return(max_so_far)\n    }\n  }\n  \n  # Case 2: when the array has all positive elements\n  sum_total <- sum(a)\n  if (sum_total > 0) {\n    return(max(max_so_far, sum_total * k))\n  }\n  \n  # Case 3: when the array has both positive and negative elements\n  max_val <- max_so_far\n  for (i in 1:n) {\n    sum_total <- sum_total - a[i]\n    max_so_far <- max_so_far - a[i]\n    max_so_far <- max(max_so_far, sum_total)\n    max_val <- max(max_val, max_so_far)\n  }\n  return(max_val)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n    # Create a temporary array to store\n    # sum of elements of all k consecutive\n    # sub-arrays\n    temp <- rep(0, n)\n    # Compute sum of first sub-array of size k\n    for (i in 1:n) {\n        temp[i] <- a[i]\n    }\n    # Compute sums of remaining sub-arrays\n    # by removing first element of previous\n    # sub-array and adding last element of\n    # current sub-array.\n    for (i in 2:k) {\n        for (j in 1:n) {\n            temp[j] <- temp[j] + a[j]\n        }\n    }\n    # Find the maximum sum sub-array\n    max_sum <- temp[1]\n    for (i in 2:n) {\n        if (temp[i] > max_sum) {\n            max_sum <- temp[i]\n        }\n    }\n    return(max_sum)\n}\n",
    "\n  # Initialize result\n  max_so_far <- 0\n  max_ending_here <- 0\n  # Initialize starting point for current subarray\n  start <- 0\n  end <- 0\n  s <- 0\n  # Consider all blocks of size n starting with i.\n  for (i in 1:n) {\n    # Calculate sum of first n elements\n    max_ending_here <- max_ending_here + a[i]\n  }\n  # Initialize overall max sum\n  max_so_far <- max_ending_here\n  # Consider all blocks ending with j.\n  for (j in 2:k) {\n    # Calculate sum of next n elements\n    max_ending_here <- 0\n    for (i in 1:n) {\n      max_ending_here <- max_ending_here + a[i]\n    }\n    # Update overall max sum, if needed\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  return(max_so_far)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return result\n  return (max_sum * k)\n}\n",
    "\n    # kadane's algorithm to find maximum subarray sum\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0)\n            max_ending_here <- 0\n        if (max_so_far < max_ending_here)\n            max_so_far <- max_ending_here\n    }\n    # Case 1: when the subarray is part of original array.\n    max_subarray_sum <- max_so_far\n    # Case 2: when the subarray is NOT part of original array.\n    max_wrap <- 0\n    for (i in 1:n) {\n        max_wrap <- max_wrap + a[i]\n        a[i] <- -a[i]\n    }\n    # max sum with corner elements will be:\n    # array-sum - (-max subarray sum of inverted array)\n    max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, 1)\n    if (max_wrap > max_subarray_sum)\n        max_subarray_sum <- max_wrap\n    # The maximum result will be maximum of two cases\n    return(max_subarray_sum)\n}\n",
    "\n  # Find the sum of the first n elements of the array\n  max_so_far <- sum(a[1:n])\n  # Find the sum of the first n elements of the array\n  max_ending_here <- max_so_far\n  # Find the sum of the first n elements of the array\n  for (i in 2:k) {\n    max_ending_here <- max_ending_here + sum(a[1:n]) - sum(a[1:n])\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  return(max_so_far)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return(max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- a[i] * -1\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, 1)\n  if (max_wrap > max_so_far) {\n    return(max_wrap)\n  }\n  return(max_so_far)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (max_wrap > max_subarray_sum) {\n    max_subarray_sum <- max_wrap\n  }\n  return(max_subarray_sum)\n}\n",
    "\n  # Write your code here\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (max_wrap > max_subarray_sum) {\n    max_subarray_sum <- max_wrap\n  }\n  return(max_subarray_sum)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Find sum of first subarray of size n\n    for (i in 1:n) {\n        max_sum = max_sum + a[i]\n    }\n    # Use the concept of Kadane's algorithm\n    curr_sum = max_sum\n    for (i in 2:k) {\n        curr_sum = curr_sum + sum(a) - sum(a[1:(n-1)])\n        max_sum = max(curr_sum, max_sum)\n        curr_sum = curr_sum - a[1:(n-1)]\n    }\n    return(max_sum)\n}",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (max_wrap > max_subarray_sum) {\n    max_subarray_sum <- max_wrap\n  }\n  return(max_subarray_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Calculate sum of current block\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    # Compute sum of elements in current block\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n    }\n    \n    # Update max_sum if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  # kadane's algorithm\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # max sum with corner elements\n  max_corner_sum <- 0\n  for (i in 1:n) {\n    max_corner_sum <- max_corner_sum + a[i]\n  }\n  max_corner_sum <- max_corner_sum * k\n  # max sum is sum of max subarray sum and max corner sum\n  return (max(max_so_far, max_corner_sum))\n}\n",
    "\n  # Find the sum of the first window of size n\n  max_sum = 0\n  for (i in 1:n) {\n    max_sum = max_sum + a[i]\n  }\n  \n  # Compute sums of remaining windows by removing first element of previous window and adding last element of current window.\n  curr_sum = max_sum\n  for (i in n+1:length(a)) {\n    curr_sum = curr_sum + a[i] - a[i-n]\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  # The maximum sum is of size n*k\n  return (max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k - 1)\n  if (max_wrap > max_so_far) {\n    return (max_wrap)\n  } else {\n    return (max_so_far)\n  }\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum is negative, no need to\n            # continue\n            if (curr_sum < 0)\n                break\n            max_sum = max(max_sum, curr_sum)\n        }\n    }\n    # Return maximum sum\n    return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum < 0)\n        curr_sum = 0\n      max_sum = max(max_sum, curr_sum)\n    }\n \n    # If all elements are negative\n    if (max_sum == 0)\n      return max(a)\n \n    # Find maximum sum wraparound array.\n    # Initialize current max and max so far.\n    max_wrap = 0\n    curr_max = 0\n \n    # Traverse array again\n    for (i in 1:n) {\n      curr_max = curr_max + a[i]\n      if (curr_max < 0)\n        curr_max = 0\n      max_wrap = max(max_wrap, curr_max)\n    }\n \n    # Maximum sum is maximum of two sums\n    max_sum = max(max_sum, max_wrap * (k - 2) + curr_sum)\n  }\n  return max_sum\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i.\n  for (i in 1:n) {\n    curr_sum = 0\n    # Calculate sum of current block\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[j]\n    }\n    # Update result if required\n    if (curr_sum > max_sum) {\n      max_sum = curr_sum\n    }\n    # Rotate the vector by 1 for next iteration\n    temp = a[1]\n    for (j in 1:(n - 1)) {\n      a[j] = a[j + 1]\n    }\n    a[n] = temp\n  }\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n  # Initialize sum of elements in current window\n  curr_sum = 0\n  # Initialize starting and ending indexes of current window\n  start = 0\n  end = 0\n  s = 0\n  # Set initial starting index as 0\n  for (i in 1:n) {\n    curr_sum = curr_sum + a[i]\n    # Update max_so_far, if needed\n    max_so_far = max(max_so_far, curr_sum)\n    # Set max_ending_here to 0 (which represents\n    # an empty subarray) if curr_sum becomes\n    # negative\n    if (curr_sum < 0) {\n      curr_sum = 0\n      s = i + 1\n    }\n  }\n  # Store ending and starting indexes of maximum\n  # sum contiguous vector\n  end = s\n  start = end\n  # To handle all negative numbers case\n  if (max_so_far == 0) {\n    max_so_far = max(a)\n    start = which.max(a)\n    end = start\n  }\n  # Find the maximum sum by considering\n  # every subarray formed by consecutive\n  # elements of given vector\n  for (i in 1:n) {\n    max_ending_here = max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here = 0\n      t = i + 1\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here\n      start = t\n      end = i\n    }\n  }\n  # Print the subarray with maximum sum\n  # print(a[start:end])\n  # Return the maximum sum\n  return (max_so_far * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return (k * max_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum is negative, no need to\n      # continue\n      if (curr_sum < 0)\n        break\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  # Return maximum sum\n  return (max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  if (max_wrap > max_subarray_sum) {\n    return(max_wrap)\n  }\n  return(max_subarray_sum)\n}\n",
    "\n  max_sum <- 0\n  for (i in 1:n) {\n    curr_sum <- 0\n    for (j in i:n) {\n      curr_sum <- curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum <- curr_sum\n      }\n    }\n  }\n  return(max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  if (k == 1) {\n    return (max_so_far)\n  }\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, 1)\n  if (max_wrap > max_so_far) {\n    return (max_wrap)\n  }\n  return (max_so_far)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    max_ending_here <- max_ending_here + a[i]\n  }\n  if (max_wrap < 0) {\n    return(max_subarray_sum)\n  }\n  max_wrap <- max_wrap * k\n  return(max(max_wrap, max_subarray_sum))\n}\n",
    "\n  max_sum <- 0\n  for (i in 1:n) {\n    curr_sum <- 0\n    for (j in i:n) {\n      curr_sum <- curr_sum + a[j]\n      max_sum <- max(max_sum, curr_sum)\n    }\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum is negative, then\n      # this subarray does not\n      # contribute to sum of k\n      # subarrays ending with j.\n      if (curr_sum < 0) {\n        break\n      }\n      # Find maximum sum subarray\n      # crossing midpoint\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  return (max_sum * k)\n}\n",
    "\n  # Find the sum of the original array.\n  max_sum = 0\n  curr_sum = 0\n  for (i in 1:n) {\n    curr_sum = curr_sum + a[i]\n  }\n  max_sum = curr_sum\n  # Find the sum of the modified array by repeating the original array k times.\n  for (i in 1:n) {\n    curr_sum = curr_sum + (k-1)*a[i]\n    max_sum = max(max_sum, curr_sum)\n  }\n  return(max_sum)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum)\n                max_sum = curr_sum\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Calculate sum of current block\n        for (j in 1:n) {\n            curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n        }\n        # Update result if required\n        max_sum = max(max_sum, curr_sum)\n    }\n    # Return result\n    return(k * max_sum)\n}\n",
    "\n  # Find the sum of the original array\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # Find the sum of the modified array\n  max_so_far_modified <- 0\n  max_ending_here_modified <- 0\n  for (i in 1:n) {\n    max_ending_here_modified <- max_ending_here_modified + a[i]\n    if (max_ending_here_modified < 0) {\n      max_ending_here_modified <- 0\n    }\n    if (max_so_far_modified < max_ending_here_modified) {\n      max_so_far_modified <- max_ending_here_modified\n    }\n  }\n  # Find the sum of the middle part\n  middle_sum <- 0\n  for (i in 1:n) {\n    middle_sum <- middle_sum + a[i]\n  }\n  # Find the maximum of the three sums\n  max_sum <- max(max_so_far, max_so_far_modified, middle_sum + (k - 2) * middle_sum)\n  return(max_sum)\n}\n",
    "\n  # kadane's algorithm to find maximum subarray sum\n  max_so_far <- a[1]\n  max_ending_here <- a[1]\n  for (i in 2:n) {\n    max_ending_here <- max(a[i], max_ending_here + a[i])\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  max_single <- max_so_far\n  \n  # case when all elements are negative\n  if (max_single < 0) {\n    return(max_single)\n  }\n  \n  # max sum with corner elements\n  max_corner_sum <- 0\n  for (i in 1:n) {\n    max_corner_sum <- max_corner_sum + a[i]\n  }\n  \n  # max sum repeating the array\n  max_repeated_sum <- max_corner_sum * k\n  \n  # overall max sum\n  return(max(max_repeated_sum, max_single))\n}\n",
    "\n  # kadane's algorithm to find max subarray sum\n  max_so_far <- a[1]\n  max_ending_here <- a[1]\n  for (i in 2:n) {\n    max_ending_here <- max(a[i], max_ending_here + a[i])\n    max_so_far <- max(max_so_far, max_ending_here)\n  }\n  max_subarray_sum <- max_so_far\n  \n  # find max subarray sum for the modified array\n  max_wrap <- 0\n  for (i in 1:n) {\n    max_wrap <- max_wrap + a[i]\n    a[i] <- -a[i]\n  }\n  max_wrap <- max_wrap + max_sub_array_sum(a, n, k)\n  \n  # return max of the two sums\n  return(max(max_subarray_sum, max_wrap))\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # If sum is negative, no need to\n            # continue\n            if (curr_sum < 0) {\n                break\n            }\n            max_sum = max(max_sum, curr_sum)\n        }\n    }\n    # Return maximum sum\n    return(max_sum * k)\n}\n",
    "\n    # kadane's algorithm to find maximum subarray sum\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0) {\n            max_ending_here <- 0\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far <- max_ending_here\n        }\n    }\n    \n    # Case 1: when the array elements are all negative\n    if (max_so_far == 0) {\n        max_so_far <- max(a)\n        return(max_so_far * k)\n    }\n    \n    # Case 2: when the array has all positive elements\n    if (max_so_far > 0) {\n        max_prefix_sum <- 0\n        max_suffix_sum <- 0\n        curr_prefix_sum <- 0\n        curr_suffix_sum <- 0\n        for (i in 1:n) {\n            curr_prefix_sum <- curr_prefix_sum + a[i]\n            if (curr_prefix_sum > max_prefix_sum) {\n                max_prefix_sum <- curr_prefix_sum\n            }\n        }\n        for (i in n:1) {\n            curr_suffix_sum <- curr_suffix_sum + a[i]\n            if (curr_suffix_sum > max_suffix_sum) {\n                max_suffix_sum <- curr_suffix_sum\n            }\n        }\n        return(max(max_so_far, max_prefix_sum + max_suffix_sum + max_so_far * (k - 2)))\n    }\n}\n\na <- c(1, 2, 3)\nn <- length(a)\nk <- 2\nmax_sub_array_sum_repeated(a, n, k)\n\na <- c(-2, -3, 4, -1, -2, 1, 5, -3)\nn <- length(a)\nk <- 2\nmax_",
    "\n  # Write your code here\n  # Initialize result\n  max_so_far = 0\n  max_ending_here = 0\n  max_element = max(a)\n  # Iterate through the array\n  for (i in 1:n) {\n    # Calculate max_ending_here\n    max_ending_here = max_ending_here + a[i]\n    # If max_ending_here is less than 0, then set it to 0\n    if (max_ending_here < 0) {\n      max_ending_here = 0\n    }\n    # Update max_so_far\n    if (max_so_far < max_ending_here) {\n      max_so_far = max_ending_here\n    }\n  }\n  # If all elements are negative\n  if (max_so_far == 0) {\n    max_so_far = max_element\n  }\n  # Return maximum sum\n  return(max_so_far * k)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    # and ending with j\n    for (i in 1:n) {\n        curr_sum = 0\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n ",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n \n  # Return result\n  return (max_sum)\n}\n",
    "\n    # Create a temporary array to store\n    # sum of all subarrays of size k\n    temp <- rep(0, n)\n    # Compute sum of first subarray of size k\n    for (i in 1:k) {\n        temp[1] <- temp[1] + a[i]\n    }\n    # Compute sums of remaining subarrays\n    for (i in 2:n-k+1) {\n        temp[i] <- temp[i-1] + a[i+k-1] - a[i-1]\n    }\n    # Find the maximum sum subarray in temp[].\n    # The kadane() function also sets values of start and\n    # finish.  So 'sum' is sum of subarray with maximum sum,\n    # 'start' is starting index of subarray, 'finish' is ending\n    # index\n    sum <- temp[1]\n    start <- finish <- 1\n    for (i in 2:n-k+1) {\n        if (temp[i] > sum) {\n            sum <- temp[i]\n            start <- i\n            finish <- i + k - 1\n        }\n    }\n    return(list(sum=sum, start=start, finish=finish))\n}\n",
    "\n    # kadane's algorithm to find maximum subarray sum\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0) {\n            max_ending_here <- 0\n        }\n        if (max_so_far < max_ending_here) {\n            max_so_far <- max_ending_here\n        }\n    }\n    \n    # Case 1: When the array elements are all negative\n    if (max_so_far == 0) {\n        max_so_far <- max(a)\n        return(max_so_far * k)\n    }\n    \n    # Case 2: When the array has all positive elements\n    sum_total <- sum(a)\n    if (sum_total > 0) {\n        return(max(max_so_far, sum_total * k))\n    }\n    \n    # Case 3: When the array has both positive and negative elements\n    max_val <- max_so_far\n    min_val <- 0\n    for (i in 1:n) {\n        min_val <- min_val + a[i]\n        if (min_val > 0) {\n            min_val <- 0\n        }\n        max_val <- max(max_val, sum_total - min_val)\n    }\n    return(max(max_val, max_so_far))\n}\n",
    "\n  # Initialize result\n  max_so_far <- 0\n  max_ending_here <- 0\n  # Initialize starting point for all\n  # subarrays starting with i\n  start <- 0\n  end <- 0\n  s <- 0\n  # Consider all blocks of size k starting\n  # with l and ending with l+k-1\n  for (l in 1:k) {\n    # Compute sum of first k elements\n    for (i in 1:n) {\n      max_ending_here <- max_ending_here + a[i]\n      if (max_so_far < max_ending_here) {\n        max_so_far <- max_ending_here\n        start <- s\n        end <- i\n      }\n      if (max_ending_here < 0) {\n        max_ending_here <- 0\n        s <- i + 1\n      }\n    }\n  }\n  return(list(max_so_far, start, end))\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  \n  # max sum is sum of max subarray sum of all blocks.\n  max_sum = max_sum * k\n  \n  # max sum is sum of subarray with middle\n  # elements common.\n  mid_sum = 0\n  for (i in 1:n) {\n    mid_sum = mid_sum + a[i]\n  }\n  mid_sum = mid_sum * floor(k / 2)\n  \n  # If k is even\n  if (k %% 2 == 0) {\n    return (max(max_sum, mid_sum))\n  } else {\n    # If k is odd\n    return (max(max_sum, mid_sum, mid_sum + a[ceiling(n / 2)]))\n  }\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  \n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i.\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (k * max_sum)\n}\n",
    "\n    # Initialize result\n    max_sum = 0\n    # Consider all blocks starting with i\n    for (i in 1:n) {\n        curr_sum = 0\n        # Consider all blocks ending with j\n        for (j in i:n) {\n            curr_sum = curr_sum + a[j]\n            # Update result if required\n            if (curr_sum > max_sum) {\n                max_sum = curr_sum\n            }\n        }\n    }\n    return (max_sum * k)\n}\n",
    "\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  max_subarray_sum <- max_so_far\n  for (i in 1:n) {\n    max_so_far <- max_so_far + a[i]\n  }\n  max_wrap <- max_so_far\n  if (max_wrap < 0) {\n    return(max_subarray_sum)\n  }\n  max_subarray_sum_kadane <- max_subarray_sum\n  max_subarray_sum <- max(max_subarray_sum, max_wrap * (k - 2) + max_subarray_sum_kadane)\n  return(max_subarray_sum)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Consider all blocks ending with j\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return result\n  return (max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  return (max_sum * k)\n}\n",
    "\n    # kadane's algorithm to find maximum subarray sum\n    max_so_far <- 0\n    max_ending_here <- 0\n    for (i in 1:n) {\n        max_ending_here <- max_ending_here + a[i]\n        if (max_ending_here < 0)\n            max_ending_here <- 0\n        if (max_so_far < max_ending_here)\n            max_so_far <- max_ending_here\n    }\n    # Case 1: when the subarray is part of original array.\n    max_kadane <- max_so_far\n    # Case 2: when the subarray is NOT part of original array.\n    max_wrap <- 0\n    for (i in 1:n) {\n        max_wrap <- max_wrap + a[i]\n        a[i] <- -a[i]\n    }\n    # max sum with corner elements will be:\n    # array-sum - (-max subarray sum of inverted array)\n    max_wrap <- max_wrap + max_sub_array_sum_repeated(a, n, k)\n    # The maximum circular sum will be maximum of two sums\n    if (max_wrap > max_kadane)\n        return (max_wrap)\n    else\n        return (max_kadane)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    # Consider all blocks ending with j\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # Update result if required\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = -Inf\n  \n  # Consider all blocks starting with i\n  for (i in seq(1, n)) {\n    curr_sum = 0\n    # Consider all blocks ending with j\n    for (j in seq(i, n)) {\n      # Sum of current sub-vector\n      curr_sum = curr_sum + a[j]\n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      \n      # Update result if required\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  # kadane's algorithm\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # case 1: when the array has all non-negative numbers\n  if (max_so_far > 0) {\n    return (max_so_far * k)\n  }\n  # case 2: when the array has all negative numbers\n  max_so_far <- 0\n  max_ending_here <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (max_so_far < max_ending_here) {\n      max_so_far <- max_ending_here\n    }\n  }\n  # case 3: when there are both positive and negative numbers in the array\n  max_ending_here <- 0\n  min_ending_here <- 0\n  min_so_far <- 0\n  for (i in 1:n) {\n    max_ending_here <- max_ending_here + a[i]\n    min_ending_here <- min_ending_here + a[i]\n    if (max_ending_here < 0) {\n      max_ending_here <- 0\n    }\n    if (min_so_far > min_ending_here) {\n      min_so_far <- min_ending_here\n    }\n    if (min_ending_here > 0) {\n      min_ending_here <- 0\n    }\n  }\n  return (max(max_so_far, sum(a) * (k - 2) + max_ending_here))\n}\n\na <- c(1, 2, 3, 4)\nn <- length(a)\nk",
    "\n  # Initialize result\n  max_sum = 0\n  # Consider all blocks starting with i\n  # and ending with j\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in i:n) {\n      curr_sum = curr_sum + a[j]\n      # If sum of elements from i'th\n      # to j'th is more than current\n      # sum, update current sum\n      if (curr_sum > max_sum) {\n        max_sum = curr_sum\n      }\n    }\n  }\n  # Return maximum sum\n  return (max_sum * k)\n}\n",
    "\n  # Find the sum of the first subarray\n  # Store it as the maximum sum so far\n  max_so_far <- sum(a[1:n])\n  max_ending_here <- max_so_far\n  \n  # Iterate through the remaining subarrays\n  for (i in 2:k) {\n    # Find the sum of the next subarray\n    max_ending_here <- max_ending_here + sum(a[(n * i - n + 1):(n * i)])\n    \n    # Compare it to the maximum sum so far\n    # Store it as the maximum sum so far if it is greater\n    if (max_ending_here > max_so_far) {\n      max_so_far <- max_ending_here\n    }\n  }\n  \n  # Return the maximum sum\n  return(max_so_far)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n  \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    \n    # Calculate sum of current block\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n    }\n    \n    # Update result if required\n    max_sum = max(max_sum, curr_sum)\n  }\n  \n  # Return result\n  return(max_sum * k)\n}\n",
    "\n  # Initialize result\n  max_sum = 0\n \n  # Consider all blocks starting with i\n  for (i in 1:n) {\n    curr_sum = 0\n    for (j in 1:n) {\n      curr_sum = curr_sum + a[(i + j - 1) %% n + 1]\n      max_sum = max(max_sum, curr_sum)\n    }\n  }\n \n  return (max_sum * k)\n}\n"
  ]
}