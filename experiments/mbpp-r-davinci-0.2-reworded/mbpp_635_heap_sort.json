{
  "name": "mbpp_635_heap_sort",
  "language": "r",
  "prompt": "# Write a function to sort the given list.\nheap_sort <- function(iterable) {",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py",
  "prompt_terminology": "reworded",
  "tests": "test_humaneval <- function() {\ncandidate <- heap_sort\n    if(!identical(candidate(c(1, 3, 5, 7, 9, 2, 4, 6, 8, 0)), list(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))){quit('no', 1)}\n    if(!identical(candidate(c(25, 35, 22, 85, 14, 65, 75, 25, 58)), list(14, 22, 25, 25, 35, 58, 65, 75, 85))){quit('no', 1)}\n    if(!identical(candidate(c(7, 1, 9, 5)), list(1, 5, 7, 9))){quit('no', 1)}\n}\ntest_humaneval()",
  "stop_tokens": [
    "\n#",
    "\n```"
  ],
  "completions": [
    "\n  # Write your code here\n  # Return the sorted list\n}",
    "\n  # Your code here\n  return(iterable)\n}\n",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n  # Write your code here.\n  h <- as.heap(iterable)\n  return(heap_sort_helper(h))\n}\n\nheap_sort_helper <- function(h) {\n  if (is.heap(h)) {\n    if (length(h) == 0) {\n      return(c())\n    } else {\n      return(c(heap_sort_helper(delete_min(h)), h[1]))\n    }\n  } else {\n    return(h)\n  }\n}\n",
    "\n    # Your code here\n}\n",
    "\n  # Your code goes here\n  heap <- iterable\n  heapify(heap)\n  end <- length(heap)\n  while (end > 1) {\n    end <- end - 1\n    tmp <- heap[1]\n    heap[1] <- heap[end]\n    heap[end] <- tmp\n    sift_down(heap, 1, end)\n  }\n  return(heap)\n}\n",
    "\n    # Write your code here\n    n <- length(iterable)\n    for (i in floor(n/2):1) {\n        iterable <- heapify(iterable, n, i)\n    }\n    for (i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- heapify(iterable, i-1, 1)\n    }\n    return(iterable)\n}\n\nheapify <- function(iterable, n, i) {\n    l <- 2*i\n    r <- 2*i + 1\n    if (l <= n && iterable[l] > iterable[i]) {\n        largest <- l\n    } else {\n        largest <- i\n    }\n    if (r <= n && iterable[r] > iterable[largest]) {\n        largest <- r\n    }\n    if (largest != i) {\n        iterable[i] <- iterable[largest]\n        iterable[largest] <- iterable[i]\n        iterable <- heapify(iterable, n, largest)\n    }\n    return(iterable)\n}\n",
    "\n  # Write your code here.\n  n <- length(iterable)\n  for (i in floor(n/2):1) {\n    heapify(iterable, n, i)\n  }\n  for (i in n:2) {\n    iterable[1] <- iterable[i]\n    iterable[i] <- iterable[1]\n    heapify(iterable, i-1, 1)\n  }\n  iterable\n}\n\nheapify <- function(iterable, n, i) {\n  largest <- i\n  l <- 2*i\n  r <- 2*i + 1\n  if (l <= n && iterable[l] > iterable[largest]) {\n    largest <- l\n  }\n  if (r <= n && iterable[r] > iterable[largest]) {\n    largest <- r\n  }\n  if (largest != i) {\n    iterable[i] <- iterable[largest]\n    iterable[largest] <- iterable[i]\n    heapify(iterable, n, largest)\n  }\n}\n",
    "\n  # Write your code here.\n  # Return the sorted list.\n}",
    "\n  # Write your code here\n  # Return the sorted list\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    n <- length(iterable)\n    for(i in floor(n/2):1){\n        heapify(iterable, n, i)\n    }\n    for(i in n:2){\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        heapify(iterable, i-1, 1)\n    }\n    return(iterable)\n}\n\nheapify <- function(iterable, n, i){\n    largest <- i\n    l <- 2*i\n    r <- 2*i + 1\n    if(l <= n && iterable[l] > iterable[largest]){\n        largest <- l\n    }\n    if(r <= n && iterable[r] > iterable[largest]){\n        largest <- r\n    }\n    if(largest != i){\n        iterable[i] <- iterable[largest]\n        iterable[largest] <- iterable[i]\n        heapify(iterable, n, largest)\n    }\n}\n",
    "\n  # Your code goes here\n  n <- length(iterable)\n  for(i in 1:n) {\n    iterable <- heapify(iterable, n, i)\n  }\n  for(i in n:2) {\n    iterable[1] <- iterable[i]\n    iterable[i] <- iterable[1]\n    iterable <- heapify(iterable, i-1, 1)\n  }\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    # Return the sorted list\n}\n ",
    "\n    # Write your code here\n    return(iterable)\n}\n ",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Write your code here\n}\n",
    "\n  # Write your code here.\n}\n",
    "\n  # Write your code here\n}\n",
    "\n    # Create a max heap.\n    heap <- heapify(iterable)\n    # Get the size of the heap.\n    size <- length(heap)\n    # Iterate over the heap.\n    for (i in 1:(size - 1)) {\n        # Swap the first and last elements.\n        heap <- swap(heap, 1, size - i + 1)\n        # Sift down the new root element.\n        heap <- sift_down(heap, 1, size - i)\n    }\n    # Return the sorted list.\n    return(heap)\n}\n ",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n  # Your code goes here.\n  return(iterable)\n}\n",
    "\n    # Create a heap from the iterable.\n    heap <- heapify(iterable)\n    \n    # Create a new list to store the sorted elements.\n    sorted_list <- c()\n    \n    # Loop until the heap is empty.\n    while (heap$size > 0) {\n        # Pop the root element from the heap.\n        root <- heap_pop(heap)\n        \n        # Append the root element to the sorted list.\n        sorted_list <- c(sorted_list, root)\n    }\n    \n    # Return the sorted list.\n    return(sorted_list)\n}\n",
    "\n  # Your code here\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n    # Your code here\n    iterable <- as.vector(iterable)\n    n <- length(iterable)\n    for(i in floor(n/2):1) {\n        iterable <- max_heapify(iterable, i, n)\n    }\n    for(i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- max_heapify(iterable, 1, i-1)\n    }\n    return(iterable)\n}\n",
    "\n  # Your code here\n}\n",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    h <- as.heap(iterable)\n    return(as.vector(h))\n}\n",
    "\n    # YOUR CODE HERE\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Your code here\n}\n",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n  # Your code goes here\n}",
    "\n    n <- length(iterable)\n    for (i in 1:(n-1)) {\n        iterable <- heapify(iterable, n, i)\n    }\n    for (i in (n-1):1) {\n        iterable[1] <- iterable[i+1]\n        iterable[i+1] <- iterable[1]\n        iterable <- heapify(iterable, i, 1)\n    }\n    return(iterable)\n}\n",
    "\n  # Write your code here\n  # Return the sorted list\n}",
    "\n    # Your code goes here\n    n <- length(iterable)\n    for(i in floor(n/2):1){\n        heapify(iterable, i, n)\n    }\n    for(i in n:2){\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        heapify(iterable, 1, i-1)\n    }\n    return(iterable)\n}\n\nheapify <- function(iterable, i, n){\n    while(2*i <= n){\n        j <- 2*i\n        if(j < n && iterable[j] < iterable[j+1]){\n            j <- j+1\n        }\n        if(iterable[i] < iterable[j]){\n            iterable[i] <- iterable[j]\n            iterable[j] <- iterable[i]\n            i <- j\n        }\n        else{\n            break\n        }\n    }\n}\n",
    "\n    # Your code here\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n ",
    "\n    # Your code here\n}\n",
    "\n  # Write your code here.\n  return(iterable)\n}",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Create a heap from the iterable.\n    heap <- heap_from_iterable(iterable)\n    \n    # Create an empty list to store the sorted elements.\n    sorted_list <- list()\n    \n    # While the heap is not empty, pop the smallest element from the heap and append it to the sorted list.\n    while (!is_empty(heap)) {\n        sorted_list <- c(sorted_list, pop(heap))\n    }\n    \n    # Return the sorted list.\n    return(sorted_list)\n}\n",
    "\n    # Write your code here\n}\n",
    "\n  # Your code goes here\n  # You can use the heapify function you wrote above\n  # You can use the heap_pop function you wrote above\n  # You can use the heap_push function you wrote above\n  # You can use the heap_size function you wrote above\n  # You can use the heap_is_empty function you wrote above\n  # You can use the heap_is_full function you wrote above\n  # You can use the heap_peek function you wrote above\n  # You can use the heap_replace function you wrote above\n  # You can use the heap_remove function you wrote above\n}\n",
    "\n  # TODO: Write your code here\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n  # Write your code here.\n  return(iterable)\n}\n",
    "\n    # Write your code here.\n    # Return the sorted list.\n}\n ",
    "\n    # Your code goes here\n}\n ",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n  # YOUR CODE HERE\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}",
    "\n    # Create a heap from the iterable\n    heap <- make_heap(iterable)\n    # Create an empty list to store the sorted elements\n    sorted_list <- list()\n    # Iterate until the heap is empty\n    while (heap$size > 0) {\n        # Pop the smallest element from the heap\n        smallest <- heap_pop(heap)\n        # Append the smallest element to the sorted list\n        sorted_list <- c(sorted_list, smallest)\n    }\n    # Return the sorted list\n    return(sorted_list)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n  # TODO: Write your code here\n  return(iterable)\n}\n",
    "\n  # Your code here\n}\n",
    "\n  # Write your code here.\n  return(iterable)\n}\n",
    "\n    # Write your code here.\n}",
    "\n    # Write your code here\n    h <- as.heap(iterable)\n    return(as.list(h))\n}\n",
    "\n    # Write your code here\n}\n",
    "\n  # Write your code here.\n  h <- as.heap(iterable)\n  return(as.vector(h))\n}\n",
    "\n    # Write your code here\n    # Return the sorted list.\n}",
    "\n  # YOUR CODE HERE\n  h <- as.heap(iterable)\n  return(as.vector(h))\n}\n",
    "\n    # Your code here\n}\n",
    "\n  # Write your code here.\n  heapify(iterable, length(iterable))\n  end <- length(iterable)\n  while(end > 1) {\n    iterable[1] <- iterable[end]\n    end <- end - 1\n    sift_down(iterable, 1, end)\n  }\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    h <- heap(iterable)\n    heap_sort <- c()\n    while(!is.empty(h)){\n        heap_sort <- c(heap_sort, extract_min(h))\n    }\n    return(heap_sort)\n}\n ",
    "\n  # Write your code here\n  return(iterable)\n}",
    "\n    # Write your code here\n    heapify(iterable, length(iterable), 1)\n    end <- length(iterable)\n    while(end > 1) {\n        iterable[1] <- iterable[end]\n        end <- end - 1\n        sift_down(iterable, 1, end)\n    }\n    return(iterable)\n}\n\nheapify <- function(iterable, count, i) {\n    while(TRUE) {\n        left <- 2 * i\n        right <- 2 * i + 1\n        largest <- i\n        if(left <= count && iterable[left] > iterable[largest]) {\n            largest <- left\n        }\n        if(right <= count && iterable[right] > iterable[largest]) {\n            largest <- right\n        }\n        if(largest == i) {\n            break\n        }\n        iterable[i] <- iterable[largest]\n        i <- largest\n    }\n}\n\nsift_down <- function(iterable, start, end) {\n    root <- start\n    while(TRUE) {\n        child <- 2 * root\n        if(child > end) {\n            break\n        }\n        if(child + 1 <= end && iterable[child] < iterable[child + 1]) {\n            child <- child + 1\n        }\n        if(iterable[root] < iterable[child]) {\n            iterable[root] <- iterable[child]\n            root <- child\n        } else {\n            break\n        }\n    }\n}\n",
    "\n  # Create a heap from the iterable.\n  heap <- heap_from_iterable(iterable)\n  # Create a list to store the sorted elements.\n  sorted_list <- list()\n  # While the heap is not empty, pop the smallest element and append it to the list.\n  while (!is_empty(heap)) {\n    sorted_list <- c(sorted_list, pop(heap))\n  }\n  # Return the sorted list.\n  return(sorted_list)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    # Return the sorted list\n    return(iterable)\n}",
    "\n  # Write your code here.\n  return(iterable)\n}\n",
    "\n  # Write your code here\n  return(iterable)\n}\n",
    "\n  # Write your code here.\n  heap <- iterable\n  heap <- build_heap(heap)\n  for (i in length(heap):2) {\n    heap[[1]] <- heap[[i]]\n    heap[[i]] <- heap[[1]]\n    heap <- heapify(heap, 1, i - 1)\n  }\n  return(heap)\n}\n",
    "\n  # Write your code here.\n}\n",
    "\n    # Write your code here.\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Your code goes here\n    return(iterable)\n}\n",
    "\n  # Your code goes here.\n}\n",
    "\n  # Create a heap from the iterable.\n  h <- heap(iterable)\n  # Create an empty list to store the sorted elements.\n  sorted <- list()\n  # While the heap is not empty, pop the smallest element from the heap and\n  # append it to the sorted list.\n  while (!is.empty(h)) {\n    sorted <- c(sorted, pop(h))\n  }\n  # Return the sorted list.\n  return(sorted)\n}",
    "\n    # Your code here\n}\n",
    "\n  # Write your code here.\n  heap <- heapify(iterable)\n  sorted_list <- c()\n  \n  while(length(heap) > 0) {\n    sorted_list <- c(sorted_list, heap[1])\n    heap <- heap[-1]\n    heap <- heapify(heap)\n  }\n  \n  return(sorted_list)\n}\n",
    "\n    # Your code goes here\n    return(iterable)\n}\n",
    "\n  # Create a heap.\n  heap <- create_heap(iterable)\n  \n  # Sort the heap.\n  sorted_heap <- sort_heap(heap)\n  \n  # Return the sorted heap.\n  return(sorted_heap)\n}\n",
    "\n    # Create a heap from the iterable.\n    heap <- heapify(iterable)\n    # Sort the heap.\n    sorted_heap <- sort(heap)\n    # Return the sorted heap.\n    return(sorted_heap)\n}\n",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n  # Write your code here\n  # Return the sorted list\n}",
    "\n  # Your code here\n}",
    "\n  # Write your code here.\n  return(iterable)\n}\n",
    "\n  # Write your code here\n  return(iterable)\n}\n",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Write your code here.\n    heapify(iterable, length(iterable))\n    end <- length(iterable)\n    while (end > 1) {\n        iterable[1] <- iterable[end]\n        end <- end - 1\n        sift_down(iterable, 1, end)\n    }\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    heapify(iterable, length(iterable))\n    end <- length(iterable)\n    while(end > 1) {\n        iterable[1] <- iterable[end]\n        end <- end - 1\n        sift_down(iterable, 1, end)\n    }\n    return(iterable)\n}\n",
    "\n    # Create a max heap.\n    heap <- heapify(iterable)\n    # Initialize the sorted list.\n    sorted_list <- c()\n    # Iterate over the heap and append the root to the sorted list.\n    for (i in 1:length(heap)) {\n        sorted_list <- c(sorted_list, heap[1])\n        # Swap the root with the last element.\n        heap[1] <- heap[length(heap)]\n        # Remove the last element.\n        heap <- heap[-length(heap)]\n        # Heapify the heap.\n        heap <- heapify(heap)\n    }\n    # Return the sorted list.\n    return(sorted_list)\n}\n",
    "\n  # Your code here\n}",
    "\n  # Your code goes here.\n  # Return the sorted list.\n}",
    "\n    n <- length(iterable)\n    for (i in floor(n/2):1) {\n        iterable <- max_heapify(iterable, i, n)\n    }\n    for (i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- max_heapify(iterable, 1, i-1)\n    }\n    return(iterable)\n}\n",
    "\n  # Your code here\n}",
    "\n    # Write your code here.\n    return(iterable)\n}\n",
    "\n  # Create a max heap.\n  heap <- heapify(iterable)\n  \n  # Extract the root element and heapify the heap.\n  # Repeat this until the heap is empty.\n  for (i in 1:length(heap)) {\n    # Extract the root element.\n    root <- extract_root(heap)\n    \n    # Swap the root element with the last element.\n    swap(heap, 1, length(heap))\n    \n    # Remove the last element.\n    heap <- heap[-length(heap)]\n    \n    # Heapify the heap.\n    heap <- heapify(heap)\n  }\n  \n  return(heap)\n}\n",
    "\n    # Write your code here.\n    h = heapify(iterable)\n    n = length(h)\n    for (i in 1:n) {\n        h = swap(h, 1, n-i+1)\n        h = heapify(h, n-i)\n    }\n    h\n}\nheap_sort(c(5, 3, 2, 1, 4))\n",
    "\n  h <- as.heap(iterable)\n  h <- as.list(h)\n  return(h)\n}\n\nheap_sort(c(3,2,1))\n",
    "\n    # Create a heap from the iterable.\n    heap <- heapify(iterable)\n    \n    # Create a list to store the sorted elements.\n    sorted_list <- list()\n    \n    # Pop the elements from the heap and store them in the list.\n    while (heap$size > 0) {\n        sorted_list[[heap$size]] <- pop(heap)\n    }\n    \n    # Return the sorted list.\n    return(sorted_list)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    # Return the sorted list\n    return(iterable)\n}",
    "\n  # your code goes here\n  return(iterable)\n}\n",
    "\n  # Your code here\n  # Hint: You can use the heapq module\n}\n",
    "\n  # Write your code here\n  heap <- iterable\n  build_max_heap(heap)\n  for (i in length(heap):2) {\n    swap(heap, 1, i)\n    heap_size <- heap_size - 1\n    max_heapify(heap, 1)\n  }\n  return(heap)\n}\n",
    "\n    # Your code here\n}\n ",
    "\n  # Your code here\n}\n",
    "\n  # Your code here\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Your code goes here.\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    h <- as.heap(iterable)\n    return(as.vector(h))\n}\n",
    "\n    # Your code goes here\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    n <- length(iterable)\n    for (i in 1:n) {\n        iterable <- heapify(iterable, i)\n    }\n    for (i in n:1) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- heapify(iterable, 1, i-1)\n    }\n    return(iterable)\n}\n\nheapify <- function(iterable, i, n=length(iterable)) {\n    largest <- i\n    left <- 2*i\n    right <- 2*i + 1\n    if (left <= n && iterable[left] > iterable[largest]) {\n        largest <- left\n    }\n    if (right <= n && iterable[right] > iterable[largest]) {\n        largest <- right\n    }\n    if (largest != i) {\n        iterable[i] <- iterable[largest]\n        iterable[largest] <- iterable[i]\n        iterable <- heapify(iterable, largest, n)\n    }\n    return(iterable)\n}\n",
    "\n  # Your code here\n}\n",
    "\n    # Your code here\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Write your code here.\n    # Return the sorted list.\n}",
    "\n  # Write your code here.\n  h <- as.heap(iterable)\n  return(as.list(h))\n}",
    "\n    # Write your code here.\n}",
    "\n    # Write your code here\n    n <- length(iterable)\n    for (i in 1:n) {\n        heapify(iterable, n, i)\n    }\n    for (i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        heapify(iterable, i - 1, 1)\n    }\n    return(iterable)\n}\n\nheapify <- function(iterable, n, i) {\n    largest <- i\n    l <- 2 * i\n    r <- 2 * i + 1\n    if (l <= n && iterable[l] > iterable[largest]) {\n        largest <- l\n    }\n    if (r <= n && iterable[r] > iterable[largest]) {\n        largest <- r\n    }\n    if (largest != i) {\n        iterable[i] <- iterable[largest]\n        iterable[largest] <- iterable[i]\n        heapify(iterable, n, largest)\n    }\n}\n",
    "\n  # Create a heap from the iterable\n  heap <- heapify(iterable)\n  # Create a list to store the sorted elements\n  sorted_list <- list()\n  # While the heap is not empty\n  while(!is.null(heap)) {\n    # Pop the minimum element from the heap\n    minimum <- heap_pop(heap)\n    # Append the minimum element to the sorted list\n    sorted_list <- c(sorted_list, minimum)\n  }\n  # Return the sorted list\n  return(sorted_list)\n}\n",
    "\n  # Your code goes here\n  # Hint: Use heapify() and extract_max()\n  heapify(iterable)\n  for(i in length(iterable):2){\n    iterable[1] <- iterable[i]\n    iterable[i] <- extract_max(iterable[1:(i-1)])\n  }\n  return(iterable)\n}\n",
    "\n  # Your code here\n  # Hint: Use heapify() and heappop()\n  heapify(iterable)\n  for (i in length(iterable):2) {\n    iterable[i] <- iterable[1]\n    iterable[1] <- iterable[i-1]\n    iterable[i-1] <- iterable[i]\n    iterable <- iterable[-i]\n    iterable <- heappop(iterable)\n  }\n  return(iterable)\n}\n",
    "\n  # Your code goes here.\n  l <- length(iterable)\n  for (i in 1:l) {\n    iterable <- heapify(iterable, i)\n  }\n  for (i in l:2) {\n    iterable <- swap(iterable, 1, i)\n    iterable <- heapify(iterable, i-1)\n  }\n  return(iterable)\n}\n",
    "\n    # Your code here\n}\n ",
    "\n    # Write your code here\n    n <- length(iterable)\n    for (i in floor(n/2):1) {\n        iterable <- max_heapify(iterable, i, n)\n    }\n    for (i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- max_heapify(iterable, 1, i-1)\n    }\n    return(iterable)\n}\n",
    "\n  # TODO: Implement this function.\n  # Hint: Use the heapify function you implemented above.\n  # Hint: Use the pop function you implemented above.\n  # Hint: Use the push function you implemented above.\n  # Hint: Use the length function you implemented above.\n  # Hint: Use the swap function you implemented above.\n  # Hint: Use the is_empty function you implemented above.\n  # Hint: Use the is_full function you implemented above.\n  # Hint: Use the is_heap function you implemented above.\n  # Hint: Use the is_max_heap function you implemented above.\n  # Hint: Use the is_min_heap function you implemented above.\n  # Hint: Use the is_valid_heap function you implemented above.\n  # Hint: Use the is_valid_max_heap function you implemented above.\n  # Hint: Use the is_valid_min_heap function you implemented above.\n  # Hint: Use the parent function you implemented above.\n  # Hint: Use the left function you implemented above.\n  # Hint: Use the right function you implemented above.\n  # Hint: Use the max function you implemented above.\n  # Hint: Use the min function you implemented above.\n  # Hint: Use the max_heapify function you implemented above.\n  # Hint: Use the min_heapify function you implemented above.\n  # Hint: Use the build_max_heap function you implemented above.\n  # Hint: Use the build_min_heap function you implemented above.\n  # Hint: Use the heap_maximum function you implemented above.\n  # Hint: Use the heap_minimum function you implemented above.\n  # Hint: Use the heap_extract_max function you implemented above.\n  # Hint: Use the heap_extract_min function you implemented above.\n  # Hint: Use the heap_increase_key function you implemented above.\n  # Hint: Use the heap_decrease_key function you implemented above.\n  # Hint: Use the max_heap_insert function you implemented above.\n  # Hint: Use the min_",
    "\n    # Your code here\n    # Hint: Use the heapify function you wrote above.\n    # Hint: Use the heap_pop function you wrote above.\n    # Hint: Use the heap_push function you wrote above.\n    # Hint: Use the heap_size function you wrote above.\n    # Hint: Use the heap_max function you wrote above.\n    # Hint: Use the heap_replace function you wrote above.\n    # Hint: Use the heap_pushpop function you wrote above.\n    # Hint: Use the heap_heapify function you wrote above.\n    # Hint: Use the heap_pop_max function you wrote above.\n    # Hint: Use the heap_increase_key function you wrote above.\n    # Hint: Use the heap_heappush_max function you wrote above.\n    # Hint: Use the heap_heappop_max function you wrote above.\n    # Hint: Use the heap_heapreplace_max function you wrote above.\n    # Hint: Use the heap_nlargest function you wrote above.\n    # Hint: Use the heap_nsmallest function you wrote above.\n    # Hint: Use the heap_merge function you wrote above.\n    # Hint: Use the heap_nlargest function you wrote above.\n    # Hint: Use the heap_nsmallest function you wrote above.\n    # Hint: Use the heap_merge function you wrote above.\n    # Hint: Use the heap_nlargest function you wrote above.\n    # Hint: Use the heap_nsmallest function you wrote above.\n    # Hint: Use the heap_merge function you wrote above.\n    # Hint: Use the heap_nlargest function you wrote above.\n    # Hint: Use the heap_nsmallest function you wrote above.\n    # Hint: Use the heap_merge function you wrote above.\n    # Hint: Use the heap_nlargest function you wrote above.\n    # Hint: Use the heap_nsmallest function you wrote above.\n    # Hint: Use the heap_merge function you wrote above.\n    # Hint: Use the heap_nlargest function you wrote above.\n",
    "\n  # Create a max heap.\n  heap <- heapify(iterable)\n  \n  # Create a sorted list.\n  sorted <- c()\n  \n  # Pop the largest element from the heap and append it to the sorted list.\n  while (length(heap) > 0) {\n    sorted <- c(sorted, heap$pop())\n  }\n  \n  # Return the sorted list.\n  return(sorted)\n}\n",
    "\n    # Write your code here.\n    h <- as.heap(iterable)\n    return(h$heap)\n}\n",
    "\n  # Write your code here.\n  # Return the sorted list.\n}",
    "\n  # Write your code here\n  return(iterable)\n}\n",
    "\n  # Write your code here\n  return(iterable)\n}\n",
    "\n  heap <- build_heap(iterable)\n  for (i in 1:length(heap)) {\n    swap(heap, 1, length(heap) - i + 1)\n    heapify(heap, 1, length(heap) - i)\n  }\n  return(heap)\n}\n",
    "\n    # Create a heap\n    h = heap()\n    # Insert all the items into the heap\n    for (item in iterable) {\n        h.insert(item)\n    }\n    # Pop all items from the heap and return them in sorted order\n    return(h.pop_all())\n}\n",
    "\n    # Write your code here\n    heap_sort <- function(iterable) {\n        # Write your code here\n        n <- length(iterable)\n        for (i in floor(n/2):1) {\n            iterable <- heapify(iterable, i, n)\n        }\n        for (i in n:2) {\n            iterable[1] <- iterable[i]\n            iterable[i] <- iterable[1]\n            iterable <- heapify(iterable, 1, i-1)\n        }\n        return(iterable)\n    }\n    \n    heapify <- function(iterable, i, n) {\n        l <- 2*i\n        r <- 2*i+1\n        if (l <= n && iterable[l] > iterable[i]) {\n            largest <- l\n        } else {\n            largest <- i\n        }\n        if (r <= n && iterable[r] > iterable[largest]) {\n            largest <- r\n        }\n        if (largest != i) {\n            iterable[i] <- iterable[largest]\n            iterable[largest] <- iterable[i]\n            iterable <- heapify(iterable, largest, n)\n        }\n        return(iterable)\n    }\n    \n    return(heap_sort(iterable))\n}\n ",
    "\n  # Your code here\n  return(iterable)\n}\n",
    "\n    # Your code here\n}\n",
    "\n  # Your code goes here\n  return(iterable)\n}\n",
    "\n    # Write your code here.\n    return(iterable)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n ",
    "\n    # Write your code here\n    heapify(iterable, length(iterable))\n    end <- length(iterable)\n    while(end > 1) {\n        iterable[1] <- iterable[end]\n        end <- end - 1\n        sift_down(iterable, 1, end)\n    }\n    return(iterable)\n}\n",
    "\n  # Your code here\n}\n",
    "\n  # Your code goes here.\n  return(iterable)\n}\n",
    "\n  # Write your code here\n  return(iterable)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n    # Your code here\n}\n",
    "\n    # Create a max heap.\n    heap <- heapify(iterable)\n    # Swap the first and last elements.\n    heap <- swap(heap, 1, length(heap))\n    # Pop the last element.\n    heap <- heap[-length(heap)]\n    # Sift down the first element.\n    heap <- sift_down(heap, 1)\n    # Repeat the above steps until the heap is empty.\n    while (length(heap) > 0) {\n        heap <- swap(heap, 1, length(heap))\n        heap <- heap[-length(heap)]\n        heap <- sift_down(heap, 1)\n    }\n    # Return the sorted list.\n    return(heap)\n}\n",
    "\n  # Write your code here\n  n <- length(iterable)\n  for (i in floor(n/2):1) {\n    iterable <- heapify(iterable, n, i)\n  }\n  for (i in n:2) {\n    iterable <- swap(iterable, 1, i)\n    iterable <- heapify(iterable, i-1, 1)\n  }\n  return(iterable)\n}\n\nheapify <- function(iterable, n, i) {\n  largest <- i\n  l <- 2*i\n  r <- 2*i + 1\n  if (l <= n && iterable[l] > iterable[largest]) {\n    largest <- l\n  }\n  if (r <= n && iterable[r] > iterable[largest]) {\n    largest <- r\n  }\n  if (largest != i) {\n    iterable <- swap(iterable, i, largest)\n    iterable <- heapify(iterable, n, largest)\n  }\n  return(iterable)\n}\n\nswap <- function(iterable, i, j) {\n  temp <- iterable[i]\n  iterable[i] <- iterable[j]\n  iterable[j] <- temp\n  return(iterable)\n}\n",
    "\n    # Write your code here\n    # Create a heap\n    heap <- heap_create(iterable)\n    # Sort the heap\n    heap_sort <- heap_sort(heap)\n    return(heap_sort)\n}\n",
    "\n  # Create a max heap.\n  heap <- heapify(iterable)\n  # Create a sorted list.\n  sorted_list <- c()\n  # While the heap is not empty.\n  while (length(heap) > 0) {\n    # Pop the max element from the heap.\n    max_element <- heap_pop(heap)\n    # Append the max element to the sorted list.\n    sorted_list <- c(sorted_list, max_element)\n  }\n  # Return the sorted list.\n  return(sorted_list)\n}\n",
    "\n    # Your code here\n}\n ",
    "\n    # Write your code here\n    h <- as.heap(iterable)\n    return(as.vector(h))\n}\n",
    "\n  # Write your code here\n  # Return the sorted list\n}",
    "\n    # Write your code here.\n    heap = Heap(iterable)\n    heap.sort(heap)\n    return(heap.heap)\n}\n",
    "\n    # Create a max heap from the iterable.\n    heap <- heapify(iterable)\n    \n    # Create a list to store the sorted elements.\n    sorted_list <- list()\n    \n    # Pop the maximum element from the heap and append it to the sorted list.\n    # Repeat this until the heap is empty.\n    while (heap$size > 0) {\n        sorted_list <- c(sorted_list, pop(heap))\n    }\n    \n    # Return the sorted list.\n    return(sorted_list)\n}\n",
    "\n  # Write your code here.\n  h <- as.heap(iterable)\n  return(heap_sort_helper(h))\n}\n\nheap_sort_helper <- function(h) {\n  if (is.empty(h)) {\n    return(c())\n  } else {\n    return(c(pop(h), heap_sort_helper(h)))\n  }\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n  # Your code goes here\n  heap <- iterable\n  heapify(heap)\n  end <- length(heap)\n  while (end > 1) {\n    heap[1] <- heap[end]\n    end <- end - 1\n    sift_down(heap, 1, end)\n  }\n  heap\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}",
    "\n    # Create a max heap.\n    heap <- iterable\n    for (i in 1:length(heap)) {\n        heap <- heapify(heap, i)\n    }\n    \n    # Sort the heap.\n    sorted <- c()\n    for (i in length(heap):1) {\n        sorted <- c(heap[1], sorted)\n        heap[1] <- heap[i]\n        heap <- heap[-i]\n        heap <- heapify(heap, 1)\n    }\n    \n    return(sorted)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n  # Your code here\n}\n",
    "\n    n <- length(iterable)\n    for (i in floor(n/2):1) {\n        iterable <- max_heapify(iterable, i, n)\n    }\n    for (i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- max_heapify(iterable, 1, i-1)\n    }\n    return(iterable)\n}\n",
    "\n  # Your code here\n  # Return the sorted list\n}\n ",
    "\n    # Write your code here\n    heapify(iterable, length(iterable))\n    end <- length(iterable)\n    while (end > 1) {\n        iterable[1] <- iterable[end]\n        end <- end - 1\n        sift_down(iterable, 1, end)\n    }\n    return(iterable)\n}\n",
    "\n  # Create a heap from the iterable.\n  heap <- heapify(iterable)\n  # Create a vector to store the sorted elements.\n  sorted <- c()\n  # While the heap is not empty, pop the root element and append it to the sorted vector.\n  while (heap$size > 0) {\n    sorted <- c(sorted, heap$pop())\n  }\n  # Return the sorted vector.\n  return(sorted)\n}",
    "\n  # Create a heap from the iterable.\n  heap <- heapify(iterable)\n  # Create a list to store the sorted elements.\n  sorted <- list()\n  # While the heap is not empty, pop the root element and append it to the\n  # sorted list.\n  while (heap$size > 0) {\n    sorted <- c(sorted, heap$pop())\n  }\n  # Return the sorted list.\n  return(sorted)\n}\n",
    "\n  # Create a max heap.\n  for (i in 1:(length(iterable) - 1)) {\n    # Insert the new element at the end of the heap.\n    iterable[i + 1] <- iterable[i]\n    # Bubble up the new element.\n    bubble_up(iterable, i + 1)\n  }\n  \n  # Extract the root element and heapify the heap.\n  for (i in length(iterable):2) {\n    # Swap the root element with the last element.\n    iterable[1] <- iterable[i]\n    iterable[i] <- iterable[1]\n    # Heapify the heap.\n    heapify(iterable, i - 1)\n  }\n  \n  # Return the sorted list.\n  return(iterable)\n}\n",
    "\n  # Your code here\n  return(iterable)\n}",
    "\n    # Write your code here.\n    return(iterable)\n}\n",
    "\n    # Your code here\n    return(iterable)\n}\n",
    "\n    # Create a heap from the iterable.\n    heap <- heapify(iterable)\n    # Create an empty list to store the sorted elements.\n    sorted_list <- list()\n    # Iterate until the heap is empty.\n    while(!is.empty(heap)) {\n        # Pop the root element from the heap.\n        popped_element <- pop(heap)\n        # Append the popped element to the sorted list.\n        sorted_list <- c(sorted_list, popped_element)\n    }\n    # Return the sorted list.\n    return(sorted_list)\n}",
    "\n  # YOUR CODE HERE\n  return(iterable)\n}\n",
    "\n  # Your code here\n}\n",
    "\n    # Write your code here\n    h <- as.heap(iterable)\n    return(heap_sort_helper(h))\n}\n\nheap_sort_helper <- function(h) {\n    if (is.empty(h)) {\n        return(c())\n    } else {\n        return(c(pop(h), heap_sort_helper(h)))\n    }\n}\n",
    "\n  # Your code here\n}",
    "\n  # Your code here\n}\n",
    "\n  # Your code goes here.\n  heap <- iterable\n  heap <- build_max_heap(heap)\n  for (i in length(heap):2) {\n    heap[1] <- heap[i]\n    heap[i] <- heap[1]\n    heap <- heap[-i]\n    heap <- max_heapify(heap, 1)\n  }\n  return(heap)\n}\n",
    "\n    # Write your code here\n    # Return the sorted list\n    return(iterable)\n}",
    "\n  # Write your code here\n  heap <- iterable\n  build_max_heap(heap)\n  for (i in length(heap):2) {\n    swap(heap, 1, i)\n    heap_size <- heap_size - 1\n    max_heapify(heap, 1)\n  }\n  return(heap)\n}\n",
    "\n    # Write your code here\n    return(iterable)\n}\n",
    "\n    # Write your code here\n}\n",
    "\n    # Your code goes here\n    heap <- iterable\n    heapify(heap)\n    end <- length(heap)\n    while (end > 1) {\n        heap[1] <- heap[end]\n        end <- end - 1\n        sift_down(heap, 1, end)\n    }\n    return(heap)\n}\n",
    "\n  # Your code goes here\n  heap <- heapify(iterable)\n  for (i in 1:length(iterable)) {\n    iterable[i] <- heap$pop()\n  }\n  return(iterable)\n}\n",
    "\n    # Create a max heap.\n    heapify(iterable)\n    # Get the size of the heap.\n    end <- length(iterable)\n    # Iterate over the heap.\n    while (end > 1) {\n        # Swap the first and last elements.\n        iterable[1] <- iterable[end]\n        iterable[end] <- iterable[1]\n        # Decrement the size of the heap.\n        end <- end - 1\n        # Sift down the new first element.\n        sift_down(iterable, 1, end)\n    }\n    # Return the sorted list.\n    return(iterable)\n}",
    "\n    # Write your code here\n    n <- length(iterable)\n    for (i in floor(n/2):1) {\n        iterable <- max_heapify(iterable, i, n)\n    }\n    for (i in n:2) {\n        iterable[1] <- iterable[i]\n        iterable[i] <- iterable[1]\n        iterable <- max_heapify(iterable, 1, i-1)\n    }\n    iterable\n}\n\nmax_heapify <- function(iterable, i, n) {\n    l <- 2*i\n    r <- 2*i + 1\n    if (l <= n && iterable[l] > iterable[i]) {\n        largest <- l\n    } else {\n        largest <- i\n    }\n    if (r <= n && iterable[r] > iterable[largest]) {\n        largest <- r\n    }\n    if (largest != i) {\n        iterable[i] <- iterable[largest]\n        iterable[largest] <- iterable[i]\n        iterable <- max_heapify(iterable, largest, n)\n    }\n    iterable\n}\n",
    "\n  # Create a heap from the iterable.\n  heap <- heapify(iterable)\n  # Create a list to store the sorted elements.\n  sorted_list <- list()\n  # Iterate until the heap is empty.\n  while (length(heap) > 0) {\n    # Pop the minimum element from the heap.\n    min_element <- heap_pop(heap)\n    # Append the popped element to the sorted list.\n    sorted_list <- c(sorted_list, min_element)\n  }\n  # Return the sorted list.\n  return(sorted_list)\n}\n",
    "\n  # Your code here\n  return(iterable)\n}\n",
    "\n  # Write your code here\n  # You can use the heapify function defined above\n  # You can use the heap_sort_helper function defined above\n  heap_sort_helper(heapify(iterable))\n}\n",
    "\n    # Your code here\n}\n",
    "\n  h <- as.heap(iterable)\n  return(as.list(h))\n}\n"
  ]
}