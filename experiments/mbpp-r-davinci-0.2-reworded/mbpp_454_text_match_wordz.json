{
  "name": "mbpp_454_text_match_wordz",
  "language": "r",
  "prompt": "# Write a function that matches a word containing 'z'.\ntext_match_wordz <- function(text) {",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py",
  "prompt_terminology": "reworded",
  "tests": "test_humaneval <- function() {\ncandidate <- text_match_wordz\n    if(!identical(candidate('pythonz.'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('xyz.'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('  lang  .'), FALSE)){quit('no', 1)}\n}\ntest_humaneval()",
  "stop_tokens": [
    "\n#",
    "\n```"
  ],
  "completions": [
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character z literally (case sensitive).\n  # 'i' modifier makes the pattern case insensitive.\n  # '*' Quantifier \u2014 Matches between zero and unlimited times, as many times as possible, giving back as needed (greedy).\n  # 'g' modifier: global. All matches (don't return on first match).\n  # 'm' modifier: multi-line. Causes ^ and $ to match the begin/end of each line (not only begin/end of string)\n  # 'x' modifier: free-spacing and line comments (ignore whitespace and # comments)\n  # 's' modifier: single line. Dot matches newline characters.\n  # 'u' modifier: unicode. Pattern strings are treated as UTF-8.\n  # 'U' modifier: Ungreedy. Inverts the \"greedy\" modifier.\n  # '^' Assert position at start of a line.\n  # '$' Assert position at end of a line.\n  # '\\b' Word boundary.\n  # '\\B' Not a word boundary.\n  # '\\d' Match a digit [0-9].\n  # '\\D' Match a character that is not a digit.\n  # '\\s' Match a whitespace character [ \\t\\r\\n\\f].\n  # '\\S' Match a non-whitespace character.\n  # '\\w' Match a word character [a-zA-Z0-9_].\n  # '\\W' Match a non-word character.\n  # '\\n' Match a newline character.\n  # '\\t' Match a tab character.\n  # '\\v' Match a vertical tab character.\n  # '\\f' Match a form feed character.\n  # '\\r' Match a carriage return character.\n  # '\\0' Match a NUL character.\n  # '\\cx' Match a control character.\n  # '\\uxxxx' Match a character with hex code xxxx.\n  # '\\x{xxxx}' Match a character with hex code xxxx.\n  # '\\o{xxxxxx}' Match a character with oct",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # '\\\\b' is an escape sequence for the backspace character.\n  # 'z' matches the character z.\n  # 'i' makes the pattern case-insensitive.\n  # '+' matches one or more of the preceding token.\n  grepl(\"\\\\bz+\\\\b\", text, ignore.case = TRUE)\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' means that the pattern must contain the letter z.\n  # '+' means that the pattern must contain at least one z.\n  # 'i' means that the pattern is case-insensitive.\n  # 'perl = TRUE' means that we can use some regular expression syntax from Perl.\n  # 'value = TRUE' means that we want a logical vector indicating which elements of 'text' match the pattern.\n  str_detect(text, pattern = \"\\\\bz+\\\\b\", ignore_case = TRUE, perl = TRUE, value = TRUE)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character z literally (case sensitive).\n  # 'i' modifier makes the pattern case insensitive.\n  # 'g' modifier specifies global matching.\n  # 'm' modifier specifies multiline matching.\n  # 'x' modifier allows you to use comments and whitespace in the pattern.\n  # 's' modifier allows the dot to match newlines.\n  # 'u' modifier allows the pattern to match unicode.\n  # 'U' modifier allows the pattern to match unicode.\n  # 'X' modifier allows you to use comments and whitespace in the pattern.\n  # 'A' modifier forces the match to start at the beginning of the string.\n  # 'Z' modifier forces the match to end at the end of the string.\n  # 'b' modifier forces the match to occur at a word boundary.\n  # 'B' modifier forces the match to occur at a non-word boundary.\n  # '<' modifier forces the match to occur at the beginning of a word.\n  # '>' modifier forces the match to occur at the end of a word.\n  # 'y' modifier causes the pattern to stick to the previous match.\n  # '^' matches the start of string.\n  # '$' matches the end of string.\n  # '\\A' matches the start of string.\n  # '\\Z' matches the end of string.\n  # '\\z' matches the end of string.\n  # '\\G' matches the point where the last match finished.\n  # '\\b' matches a word boundary.\n  # '\\B' matches a non-word boundary.\n  # '\\A' matches the start of string.\n  # '\\Z' matches the end of string.\n  # '\\z' matches the end of string.\n  # '\\G' matches the point where the last match finished.\n  # '\\b' matches a word boundary.\n  # '\\B' matches a non-word boundary.\n  # '\\<' matches the start of a word.\n  # '\\>' matches the end of a word.\n  # '\\w' matches any word character.\n  # '",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n"
  ]
}