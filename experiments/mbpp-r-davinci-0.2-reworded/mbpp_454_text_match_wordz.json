{
  "name": "mbpp_454_text_match_wordz",
  "language": "r",
  "prompt": "# Write a function that matches a word containing 'z'.\ntext_match_wordz <- function(text) {",
  "doctests": "transform",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py",
  "prompt_terminology": "reworded",
  "tests": "test_humaneval <- function() {\ncandidate <- text_match_wordz\n    if(!identical(candidate('pythonz.'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('xyz.'), TRUE)){quit('no', 1)}\n    if(!identical(candidate('  lang  .'), FALSE)){quit('no', 1)}\n}\ntest_humaneval()",
  "stop_tokens": [
    "\n#",
    "\n```"
  ],
  "completions": [
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character z literally (case sensitive).\n  # 'i' modifier makes the pattern case insensitive.\n  # '*' Quantifier \u2014 Matches between zero and unlimited times, as many times as possible, giving back as needed (greedy).\n  # 'g' modifier: global. All matches (don't return on first match).\n  # 'm' modifier: multi-line. Causes ^ and $ to match the begin/end of each line (not only begin/end of string)\n  # 'x' modifier: free-spacing and line comments (ignore whitespace and # comments)\n  # 's' modifier: single line. Dot matches newline characters.\n  # 'u' modifier: unicode. Pattern strings are treated as UTF-8.\n  # 'U' modifier: Ungreedy. Inverts the \"greedy\" modifier.\n  # '^' Assert position at start of a line.\n  # '$' Assert position at end of a line.\n  # '\\b' Word boundary.\n  # '\\B' Not a word boundary.\n  # '\\d' Match a digit [0-9].\n  # '\\D' Match a character that is not a digit.\n  # '\\s' Match a whitespace character [ \\t\\r\\n\\f].\n  # '\\S' Match a non-whitespace character.\n  # '\\w' Match a word character [a-zA-Z0-9_].\n  # '\\W' Match a non-word character.\n  # '\\n' Match a newline character.\n  # '\\t' Match a tab character.\n  # '\\v' Match a vertical tab character.\n  # '\\f' Match a form feed character.\n  # '\\r' Match a carriage return character.\n  # '\\0' Match a NUL character.\n  # '\\cx' Match a control character.\n  # '\\uxxxx' Match a character with hex code xxxx.\n  # '\\x{xxxx}' Match a character with hex code xxxx.\n  # '\\o{xxxxxx}' Match a character with oct",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # '\\\\b' is an escape sequence for the backspace character.\n  # 'z' matches the character z.\n  # 'i' makes the pattern case-insensitive.\n  # '+' matches one or more of the preceding token.\n  grepl(\"\\\\bz+\\\\b\", text, ignore.case = TRUE)\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' means that the pattern must contain the letter z.\n  # '+' means that the pattern must contain at least one z.\n  # 'i' means that the pattern is case-insensitive.\n  # 'perl = TRUE' means that we can use some regular expression syntax from Perl.\n  # 'value = TRUE' means that we want a logical vector indicating which elements of 'text' match the pattern.\n  str_detect(text, pattern = \"\\\\bz+\\\\b\", ignore_case = TRUE, perl = TRUE, value = TRUE)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character z literally (case sensitive).\n  # 'i' modifier makes the pattern case insensitive.\n  # 'g' modifier specifies global matching.\n  # 'm' modifier specifies multiline matching.\n  # 'x' modifier allows you to use comments and whitespace in the pattern.\n  # 's' modifier allows the dot to match newlines.\n  # 'u' modifier allows the pattern to match unicode.\n  # 'U' modifier allows the pattern to match unicode.\n  # 'X' modifier allows you to use comments and whitespace in the pattern.\n  # 'A' modifier forces the match to start at the beginning of the string.\n  # 'Z' modifier forces the match to end at the end of the string.\n  # 'b' modifier forces the match to occur at a word boundary.\n  # 'B' modifier forces the match to occur at a non-word boundary.\n  # '<' modifier forces the match to occur at the beginning of a word.\n  # '>' modifier forces the match to occur at the end of a word.\n  # 'y' modifier causes the pattern to stick to the previous match.\n  # '^' matches the start of string.\n  # '$' matches the end of string.\n  # '\\A' matches the start of string.\n  # '\\Z' matches the end of string.\n  # '\\z' matches the end of string.\n  # '\\G' matches the point where the last match finished.\n  # '\\b' matches a word boundary.\n  # '\\B' matches a non-word boundary.\n  # '\\A' matches the start of string.\n  # '\\Z' matches the end of string.\n  # '\\z' matches the end of string.\n  # '\\G' matches the point where the last match finished.\n  # '\\b' matches a word boundary.\n  # '\\B' matches a non-word boundary.\n  # '\\<' matches the start of a word.\n  # '\\>' matches the end of a word.\n  # '\\w' matches any word character.\n  # '",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' followed by 'z'\n  pattern <- word(\"word\", fixed = TRUE) %R% one_or_more(\"z\")\n  str_view(text, pattern)\n}\n\ntext_match_wordz(\"The quick brown fox jumps over the lazy dog.\")",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' matches a word.\n  # 'z' matches a literal 'z'.\n  # '+' matches one or more of the preceding token.\n  # 'i' makes the match case-insensitive.\n  grepl(\"word+z\", text, ignore.case = TRUE)\n}\n",
    "\n  pattern <- \"\\\\bz\\\\w*\\\\b\"\n  match <- grepl(pattern, text)\n  return(match)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' matches a word character (a-z, A-Z, 0-9, _)\n  # '+' matches between one and unlimited times, as many times as possible, giving back as needed (greedy)\n  # 'z' matches a single character in the list z (case sensitive)\n  # 'i' modifier: insensitive. Case insensitive match (ignores case of [a-zA-Z])\n  # 'g' modifier: global. All matches (don't return on first match)\n  # 'm' modifier: multi line. Causes ^ and $ to match the begin/end of each line (not only begin/end of string)\n  grepl(\"\\\\bwordz\\\\b\", text, ignore.case = TRUE, perl = TRUE)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w+\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # '\\\\b' is an anchor that matches at a word boundary.\n  # 'z' matches the character 'z'.\n  # '\\\\w*' matches any number of word characters (equal to [a-zA-Z0-9_]).\n  # '\\\\b' is an anchor that matches at a word boundary.\n  pattern <- paste0(\"\\\\b\", \"z\", \"\\\\w*\", \"\\\\b\")\n  # Use str_view_all to return all matches.\n  str_view_all(text, pattern)\n}\n\ntext_match_wordz(\"The quick brown fox jumps over the lazy dog.\")",
    "\n  pattern <- \"\\\\bz\\\\w*\\\\b\"\n  match <- gregexpr(pattern, text, perl = TRUE)\n  if (length(match[[1]]) > 0) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_extract(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w+\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character 'z'.\n  # '+' matches between one and unlimited times, as many times as possible,\n  # giving back as needed (greedy).\n  # 'i' modifier makes the pattern case insensitive.\n  # 'g' modifier makes the pattern global, i.e. find all matches rather than\n  # stopping after the first match.\n  pattern <- word(\"z\", \"+\", ignore.case = TRUE, perl = TRUE)\n  str_view(text, pattern)\n}\n\ntext_match_wordz(\"The quick brown fox.\")\ntext_match_wordz(\"That was easy!\")\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  pattern <- \"\\\\bz\\\\w*\\\\b\"\n  match <- gregexpr(pattern, text)\n  match\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  str_view(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  str_detect(text, \"z\")\n}\n",
    "\n  str_detect(text, \"z\")\n}\n",
    "\n  pattern <- \"z\"\n  if (grepl(pattern, text)) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  if (grepl(\"z\", text)) {\n    return(TRUE)\n  } else {\n    return(FALSE)\n  }\n}\n",
    "\n  # '\\w' matches any word character (equal to [a-zA-Z0-9_])\n  # '*' matches any number of times (including zero)\n  # 'z' matches the character 'z' literally (case sensitive)\n  str_view(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # '\\\\b' is a word boundary\n  # 'z' matches the character 'z'\n  # '+' quantifies the preceding token once or more times. Equivalent to {1,}\n  # '\\\\b' is a word boundary\n  regex <- paste0(\"\\\\b\", \"z\", \"+\", \"\\\\b\")\n  return(grepl(regex, text))\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  # 'word' matches a word of letters, numbers, or underscores.\n  # 'z' matches a single character that is a 'z'.\n  # '+' matches one or more of the preceding token.\n  # 'i' makes the match case-insensitive.\n  grepl(\"word+z\", text, ignore.case = TRUE)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' means that there are word boundaries on either side\n  # of the text.\n  grepl(\"\\\\bz\\\\b\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  # '\\b' is a word boundary\n  grepl(\"\\\\bz\\\\b\", text)\n}\n",
    "\n  # 'text' is a character vector of length 1.\n  # Return a logical vector indicating if there is a match.\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' matches a word, 'z' matches the letter z, '*' matches zero or more of the preceding character\n  regex(\"wordz*\", text, ignore.case = TRUE)\n}\n",
    "\n  str_detect(text, \"z\")\n}\n",
    "\n  # '\\\\b' is the boundary between a word and a non-word\n  # 'z' matches the character 'z' literally (case sensitive)\n  # '+' Quantifier \u2014 Matches between one and unlimited times, as many times as possible, giving back as needed (greedy)\n  # '\\\\b' is the boundary between a word and a non-word\n  pattern <- paste0(\"\\\\bz+\\\\b\")\n  \n  # Detect the pattern\n  str_detect(text, pattern)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character z literally.\n  # 'i' modifier makes the pattern case insensitive.\n  # '+' quantifier matches between one and unlimited times, as many times as possible, giving back as needed.\n  # 'g' modifier performs a global match (find all matches rather than stopping after the first match).\n  pattern <- word(\"z\", ignore.case = TRUE, fixed = FALSE)\n  str_view_all(text, pattern)\n}\n\ntext_match_wordz(\"The quick brown fox jumps over the lazy dog.\")",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' matches a word, 'z' matches a literal 'z'\n  str_view(text, \"wordz\")\n}\n",
    "\n  # Write your code here\n  str_detect(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  regex <- \"\\\\bz\\\\w*\\\\b\"\n  str_view(text, regex)\n}\n\ntext_match_wordz(text)\n",
    "\n  str_view_all(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  # 'word' matches a word of letters, numbers, and underscores.\n  # 'z' matches the letter z.\n  # '+' matches one or more of the preceding token.\n  # 'i' makes the match case-insensitive.\n  regex(\"word+z\", ignore_case = TRUE)\n}\n",
    "\n  # Write your code here\n  # Use the str_detect function\n  str_detect(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  # 'word' matches a sequence of word characters\n  # 'z' matches a single character that is a 'z'\n  str_view(text, \"wordz\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # Write your code here\n  str_detect(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  # Write your code here\n  str_detect(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'z' matches any single character\n  # '+' matches one or more of the preceding token\n  # 'i' makes the match case-insensitive\n  grepl(\"z+\", text, ignore.case = TRUE)\n}\n",
    "\n    if (regexpr(\"z\", text) > -1) {\n        return(TRUE)\n    } else {\n        return(FALSE)\n    }\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\\\\w*\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  # '\\\\b' is a word boundary\n  # 'z' matches a literal 'z'\n  # '\\\\w*' matches 0 or more word characters\n  # 'i' makes the match case-insensitive\n  regex <- paste0('\\\\bz\\\\w*', collapse = '')\n  grepl(regex, text, ignore.case = TRUE)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character z literally (case sensitive).\n  # '+' Quantifier \u2014 Matches between one and unlimited times, as many times as possible, giving back as needed (greedy).\n  # 'i' Modifier \u2014 Perform case-insensitive matching.\n  # 'g' Modifier \u2014 Perform a global match (find all matches rather than stopping after the first match).\n  # 'm' Modifier \u2014 Perform multiline matching.\n  # 'x' Modifier \u2014 Allow spaces and comments.\n  # 's' Modifier \u2014 Treat string as single line.\n  # 'u' Modifier \u2014 Treat string as UTF-8.\n  # 'U' Modifier \u2014 Ungreedy pattern.\n  # 'A' Anchor \u2014 Matches only at the start of the string.\n  # 'Z' Anchor \u2014 Matches only at the end of the string or before newline at the end of the string.\n  # 'b' Word boundary.\n  # 'B' Not a word boundary.\n  # '<' Start of word.\n  # '>' End of word.\n  # 'y' Perform a \"sticky\" search that matches only from the index indicated by the lastIndex property of this regular expression in the target string.\n  # 'Y' Perform a \"sticky\" search that matches only from the index indicated by the lastIndex property of this regular expression in the target string.\n  # 'u' Unicode mode.\n  # 'U' Unicode mode.\n  # 's' Dotall mode.\n  # 'S' Dotall mode.\n  # 'd' Unicode mode.\n  # 'D' Unicode mode.\n  # 'w' Unicode mode.\n  # 'W' Unicode mode.\n  # 'G' Matches the point where the previous match finished.\n  # 'K' Keep the result of the previous match and append it to the replacement.\n  # 'J' Remove one level of line-leading tabs or spaces from the beginning of the pattern space.\n  # 'C' Remove one level of line-leading tabs or spaces from the beginning of the pattern space and append it to the replacement.\n  # '1' through '9' Backreference to",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  pattern <- \"\\\\bz\\\\w*\\\\b\"\n  match <- regexpr(pattern, text)\n  if (match > -1) {\n    return(regmatches(text, match))\n  } else {\n    return(NA)\n  }\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"\\\\bz\\\\w*\\\\b\")\n}\n",
    "\n  str_detect(text, \"\\\\w*z\\\\w*\")\n}\n",
    "\n  grepl(\"z\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # 'word' matches a word, and 'z' matches a 'z'\n  grepl(\"wordz\", text)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  if (is.na(text)) {\n    return(NA)\n  }\n  if (grepl(\"z\", text)) {\n    return(TRUE)\n  }\n  return(FALSE)\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  # Write your code here\n  # Use str_detect() to detect the pattern\n  str_detect(text, \"z\")\n}\n",
    "\n  # 'word' means that the pattern must be surrounded by word boundaries.\n  # 'z' matches the character 'z'.\n  # '+' matches between one and unlimited times, as many times as possible,\n  # giving back as needed (greedy).\n  # 'i' modifier makes the pattern case insensitive.\n  pattern <- word(\"z\", \"+\", ignore.case = TRUE)\n  str_view(text, pattern)\n}\n\ntext_match_wordz(\"The quick brown fox\")\ntext_match_wordz(\"The quick brown fox jumps over the lazy dog\")",
    "\n  str_detect(text, \"\\\\bz\\\\w*\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n",
    "\n  str_view(text, \"z\")\n}\n"
  ]
}