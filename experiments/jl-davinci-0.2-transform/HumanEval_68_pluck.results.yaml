language: jl
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    smallest_even = minimum(evens)\n    smallest_even_index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpu103g4vb.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpu103g4vb.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpu103g4vb.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu103g4vb.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu103g4vb.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpu103g4vb.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpu103g4vb.jl:40\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu103g4vb.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu103g4vb.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpu103g4vb.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [i for i in arr\
    \ if i % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpzaj2pwkp.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpzaj2pwkp.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzaj2pwkp.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzaj2pwkp.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzaj2pwkp.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpzaj2pwkp.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpzaj2pwkp.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpzaj2pwkp.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpzaj2pwkp.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpzaj2pwkp.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpr_bm1u99.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpr_bm1u99.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr_bm1u99.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_bm1u99.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_bm1u99.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpr_bm1u99.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr_bm1u99.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_bm1u99.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_bm1u99.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpr_bm1u99.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx4yvi323.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpx4yvi323.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_even_idx = findall(arr .==\
    \ min_even)[1]\n    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppb7g687_.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmppb7g687_.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppb7g687_.jl:51 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppb7g687_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmppb7g687_.jl:52\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppb7g687_.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppb7g687_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmppb7g687_.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppb7g687_.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppb7g687_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmppb7g687_.jl:55\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppb7g687_.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppb7g687_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmppb7g687_.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ arr[i])\n        end\n    end\n    if isempty(even_arr)\n        return []\n\
    \    end\n    min_even = minimum(even_arr)\n    for i in 1:length(arr)\n     \
    \   if arr[i] == min_even\n            return [min_even, i]\n        end\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_46hr4gz.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp_46hr4gz.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    sort!(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpou45_suk.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpou45_suk.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpou45_suk.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou45_suk.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpou45_suk.jl:56\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpou45_suk.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou45_suk.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpou45_suk.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpou45_suk.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou45_suk.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpou45_suk.jl:59\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpou45_suk.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpou45_suk.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpou45_suk.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    smallest_even = minimum(even_nodes)\n    return [smallest_even, findfirst(arr,\
    \ smallest_even)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpiv_2ce17.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmpiv_2ce17.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiv_2ce17.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiv_2ce17.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiv_2ce17.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpiv_2ce17.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpiv_2ce17.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpiv_2ce17.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpiv_2ce17.jl:49\ntest set:\
    \ Error During Test at /tmp/tmpiv_2ce17.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpq149x5hn.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpq149x5hn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if rem(arr[i], 2) == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    min_index = findfirst(arr,\
    \ min_value)\n    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpn_6d0oum.jl:53

    '
  stdout: "test set: Error During Test at /tmp/tmpn_6d0oum.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpn_6d0oum.jl:48\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn_6d0oum.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn_6d0oum.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpn_6d0oum.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpn_6d0oum.jl:48\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn_6d0oum.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn_6d0oum.jl:55\ntest set:\
    \ Error During Test at /tmp/tmpn_6d0oum.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfbml_1eu.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpfbml_1eu.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfbml_1eu.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfbml_1eu.jl:53\ntest set: Test Failed at /tmp/tmpfbml_1eu.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfbml_1eu.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfbml_1eu.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpfbml_1eu.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfbml_1eu.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfbml_1eu.jl:53\ntest set: Test Failed at /tmp/tmpfbml_1eu.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfbml_1eu.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfbml_1eu.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpfbml_1eu.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpr_bm1u99.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpr_bm1u99.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr_bm1u99.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_bm1u99.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_bm1u99.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpr_bm1u99.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr_bm1u99.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_bm1u99.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_bm1u99.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpr_bm1u99.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [i for i in arr\
    \ if i % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp2oaznt85.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmp2oaznt85.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp2oaznt85.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2oaznt85.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2oaznt85.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp2oaznt85.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp2oaznt85.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2oaznt85.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2oaznt85.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp2oaznt85.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp212_b6td.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp212_b6td.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test Failed at /tmp/tmp212_b6td.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp212_b6td.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test Failed at /tmp/tmp212_b6td.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp212_b6td.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmphvbyhv5w.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmphvbyhv5w.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphvbyhv5w.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphvbyhv5w.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphvbyhv5w.jl:50\ntest set:\
    \ Error During Test at /tmp/tmphvbyhv5w.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmphvbyhv5w.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmphvbyhv5w.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmphvbyhv5w.jl:50\ntest set:\
    \ Error During Test at /tmp/tmphvbyhv5w.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    even_nums_idx = []\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0\n            push!(even_nums, arr[i])\n            push!(even_nums_idx, i)\n\
    \        end\n    end\n    if length(even_nums) == 0\n        return []\n    end\n\
    \    min_even_num = minimum(even_nums)\n    min_even_num_idx = even_nums_idx[findall(even_nums\
    \ .== min_even_num)[1]]\n    return [min_even_num, min_even_num_idx]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpstbtqlek.jl:55

    '
  stdout: "test set: Test Failed at /tmp/tmpstbtqlek.jl:58\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpstbtqlek.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpstbtqlek.jl:57\ntest set: Test Failed at /tmp/tmpstbtqlek.jl:59\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpstbtqlek.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpstbtqlek.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpstbtqlek.jl:61\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpstbtqlek.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpstbtqlek.jl:57\ntest set: Test Failed at /tmp/tmpstbtqlek.jl:62\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpstbtqlek.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpstbtqlek.jl:57\ntest set: Test\
    \ Failed at /tmp/tmpstbtqlek.jl:63\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798399
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmproaxc4lr.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmproaxc4lr.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmproaxc4lr.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmproaxc4lr.jl:54\ntest set: Test Failed at /tmp/tmproaxc4lr.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmproaxc4lr.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmproaxc4lr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmproaxc4lr.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmproaxc4lr.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmproaxc4lr.jl:54\ntest set: Test Failed at /tmp/tmproaxc4lr.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmproaxc4lr.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmproaxc4lr.jl:54\ntest set: Test\
    \ Failed at /tmp/tmproaxc4lr.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_nodes) == 0\n        return []\n   \
    \ end\n    min_even = minimum(even_nodes)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpj0y76n0w.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpj0y76n0w.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpj0y76n0w.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj0y76n0w.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpj0y76n0w.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpj0y76n0w.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpj0y76n0w.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpj0y76n0w.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpj0y76n0w.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpj0y76n0w.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_arr)\n        return\
    \ []\n    end\n    even_arr = sort(even_arr, by = x -> x[1])\n    return even_arr[1]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9213bi6p.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp9213bi6p.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9213bi6p.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9213bi6p.jl:54\ntest set: Test Failed at /tmp/tmp9213bi6p.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9213bi6p.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9213bi6p.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp9213bi6p.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9213bi6p.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9213bi6p.jl:54\ntest set: Test Failed at /tmp/tmp9213bi6p.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9213bi6p.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9213bi6p.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp9213bi6p.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmp4hz6yk0h.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmp4hz6yk0h.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4hz6yk0h.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4hz6yk0h.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4hz6yk0h.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp4hz6yk0h.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4hz6yk0h.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4hz6yk0h.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4hz6yk0h.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp4hz6yk0h.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmph5r93pek.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmph5r93pek.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmph5r93pek.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph5r93pek.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph5r93pek.jl:49\ntest set:\
    \ Error During Test at /tmp/tmph5r93pek.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmph5r93pek.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph5r93pek.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph5r93pek.jl:49\ntest set:\
    \ Error During Test at /tmp/tmph5r93pek.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpkxzh20n3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpkxzh20n3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkxzh20n3.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxzh20n3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxzh20n3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpkxzh20n3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkxzh20n3.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxzh20n3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxzh20n3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpkxzh20n3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfe4n_nz1.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpfe4n_nz1.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfe4n_nz1.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfe4n_nz1.jl:42\ntest set: Test Failed at /tmp/tmpfe4n_nz1.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfe4n_nz1.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfe4n_nz1.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpfe4n_nz1.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfe4n_nz1.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfe4n_nz1.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpfe4n_nz1.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfe4n_nz1.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfe4n_nz1.jl:42\ntest set: Test Failed at /tmp/tmpfe4n_nz1.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_values = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_values) == 0\n      \
    \  return []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n \
    \   return even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppjw2hqpk.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmppjw2hqpk.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppjw2hqpk.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppjw2hqpk.jl:54\ntest set: Test Failed at /tmp/tmppjw2hqpk.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppjw2hqpk.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppjw2hqpk.jl:54\ntest set: Test\
    \ Failed at /tmp/tmppjw2hqpk.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppjw2hqpk.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppjw2hqpk.jl:54\ntest set: Test Failed at /tmp/tmppjw2hqpk.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmppjw2hqpk.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmppjw2hqpk.jl:54\ntest set: Test\
    \ Failed at /tmp/tmppjw2hqpk.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = [x for x\
    \ in arr if x % 2 == 0]\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpbojpspga.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpbojpspga.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbojpspga.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbojpspga.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbojpspga.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpbojpspga.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpbojpspga.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpbojpspga.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpbojpspga.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpbojpspga.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = [arr[i]\
    \ for i in 1:length(arr) if iseven(arr[i])]\n    if isempty(even_values)\n   \
    \     return []\n    end\n    min_value = minimum(even_values)\n    min_index\
    \ = findfirst(arr, min_value)\n    return [min_value, min_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpu_abtn_9.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpu_abtn_9.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpu_abtn_9.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu_abtn_9.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu_abtn_9.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpu_abtn_9.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpu_abtn_9.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpu_abtn_9.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpu_abtn_9.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpu_abtn_9.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    return minimum(evens)\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpklcq4ooz.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpklcq4ooz.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpklcq4ooz.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpklcq4ooz.jl:53\ntest set: Test Failed at /tmp/tmpklcq4ooz.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpklcq4ooz.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpklcq4ooz.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpklcq4ooz.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpklcq4ooz.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpklcq4ooz.jl:53\ntest set: Test Failed at /tmp/tmpklcq4ooz.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpklcq4ooz.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpklcq4ooz.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpklcq4ooz.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798399
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_value = minimum(even_arr)\n    min_index = findfirst(arr, min_value)\n\
    \    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp91yp09b9.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp91yp09b9.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp91yp09b9.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp91yp09b9.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp91yp09b9.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp91yp09b9.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp91yp09b9.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp91yp09b9.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp91yp09b9.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp91yp09b9.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmprhcxo37t.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmprhcxo37t.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprhcxo37t.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprhcxo37t.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprhcxo37t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprhcxo37t.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprhcxo37t.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprhcxo37t.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprhcxo37t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprhcxo37t.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nums = []\n\
    \    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_nums,\
    \ arr[i])\n        end\n    end\n    if length(even_nums) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_nums)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvanqqy0x.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpvanqqy0x.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvanqqy0x.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvanqqy0x.jl:58\ntest set: Test Failed at /tmp/tmpvanqqy0x.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvanqqy0x.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvanqqy0x.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpvanqqy0x.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvanqqy0x.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvanqqy0x.jl:58\ntest set: Test Failed at /tmp/tmpvanqqy0x.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvanqqy0x.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvanqqy0x.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpvanqqy0x.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa76t35us.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpa76t35us.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test Failed at /tmp/tmpa76t35us.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa76t35us.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa76t35us.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test Failed at /tmp/tmpa76t35us.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n \
    \       if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprwjt0lvu.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmprwjt0lvu.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpcy3iwaeo.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpcy3iwaeo.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpca8huey8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpca8huey8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpca8huey8.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpca8huey8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpca8huey8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpca8huey8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpca8huey8.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpca8huey8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpca8huey8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpca8huey8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx4yvi323.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpx4yvi323.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_y3nede1.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp_y3nede1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_y3nede1.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp_y3nede1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg_lw2ea7.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpg_lw2ea7.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg_lw2ea7.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg_lw2ea7.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg_lw2ea7.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpg_lw2ea7.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg_lw2ea7.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg_lw2ea7.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg_lw2ea7.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpg_lw2ea7.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_y3nede1.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp_y3nede1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_y3nede1.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp_y3nede1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7frsbe6u.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp7frsbe6u.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7frsbe6u.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7frsbe6u.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7frsbe6u.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp7frsbe6u.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7frsbe6u.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7frsbe6u.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7frsbe6u.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp7frsbe6u.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpkxzh20n3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpkxzh20n3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkxzh20n3.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxzh20n3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxzh20n3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpkxzh20n3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkxzh20n3.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkxzh20n3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkxzh20n3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpkxzh20n3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n \
    \       if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprwjt0lvu.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmprwjt0lvu.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ even_min = minimum(even_arr)\n    even_min_index = findfirst(arr, even_min)\n\
    \    return [even_min, even_min_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_sa10eja.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_sa10eja.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_sa10eja.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sa10eja.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sa10eja.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_sa10eja.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_sa10eja.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sa10eja.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sa10eja.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_sa10eja.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in arr\n        if i % 2 == 0\n            push!(even_arr, i)\n    \
    \    end\n    end\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpil0n2e8m.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpil0n2e8m.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpil0n2e8m.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpil0n2e8m.jl:58\ntest set: Test Failed at /tmp/tmpil0n2e8m.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpil0n2e8m.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpil0n2e8m.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpil0n2e8m.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpil0n2e8m.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpil0n2e8m.jl:58\ntest set: Test Failed at /tmp/tmpil0n2e8m.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpil0n2e8m.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpil0n2e8m.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpil0n2e8m.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = arr[arr .%\
    \ 2 .== 0]\n    if isempty(even_arr)\n        return []\n    end\n    min_even\
    \ = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n   \
    \ return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpomx7qo9n.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpomx7qo9n.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpomx7qo9n.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpomx7qo9n.jl:50\ntest set: Test Failed at /tmp/tmpomx7qo9n.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpomx7qo9n.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpomx7qo9n.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpomx7qo9n.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpomx7qo9n.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpomx7qo9n.jl:50\ntest set: Test Failed at /tmp/tmpomx7qo9n.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpomx7qo9n.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpomx7qo9n.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpomx7qo9n.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798402
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    if length(arr) == 0\n        return []\n  \
    \  end\n    evens = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n\
    \            push!(evens, arr[i])\n        end\n    end\n    if length(evens)\
    \ == 0\n        return []\n    end\n    min_even = minimum(evens)\n    for i in\
    \ 1:length(arr)\n        if arr[i] == min_even\n            return [min_even,\
    \ i]\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0_tahz7g.jl:57

    '
  stdout: "test set: Test Failed at /tmp/tmp0_tahz7g.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0_tahz7g.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0_tahz7g.jl:59\ntest set: Test Failed at /tmp/tmp0_tahz7g.jl:61\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0_tahz7g.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0_tahz7g.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp0_tahz7g.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0_tahz7g.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0_tahz7g.jl:59\ntest set: Test Failed at /tmp/tmp0_tahz7g.jl:64\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0_tahz7g.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0_tahz7g.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp0_tahz7g.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpck0uvx4h.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpck0uvx4h.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test Failed at /tmp/tmpck0uvx4h.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpck0uvx4h.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test Failed at /tmp/tmpck0uvx4h.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpck0uvx4h.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = []\n   \
    \ for (i, node) in enumerate(arr)\n        if node % 2 == 0\n            push!(even_nodes,\
    \ [node, i])\n        end\n    end\n    if isempty(even_nodes)\n        return\
    \ []\n    end\n    return sort!(even_nodes)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphfwj1tzj.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmphfwj1tzj.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphfwj1tzj.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphfwj1tzj.jl:53\ntest set: Test Failed at /tmp/tmphfwj1tzj.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphfwj1tzj.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphfwj1tzj.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphfwj1tzj.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphfwj1tzj.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphfwj1tzj.jl:53\ntest set: Test Failed at /tmp/tmphfwj1tzj.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphfwj1tzj.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphfwj1tzj.jl:53\ntest set: Test\
    \ Failed at /tmp/tmphfwj1tzj.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798402
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_even_value = minimum(even_values)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even_value\n            return [min_even_value, i]\n\
    \        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpav3nf7i9.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpav3nf7i9.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpav3nf7i9.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpav3nf7i9.jl:58\ntest set: Test Failed at /tmp/tmpav3nf7i9.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpav3nf7i9.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpav3nf7i9.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpav3nf7i9.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpav3nf7i9.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpav3nf7i9.jl:58\ntest set: Test Failed at /tmp/tmpav3nf7i9.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpav3nf7i9.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpav3nf7i9.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpav3nf7i9.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798402
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_idx = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgyc2p61s.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpgyc2p61s.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgyc2p61s.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgyc2p61s.jl:50\ntest set: Test Failed at /tmp/tmpgyc2p61s.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgyc2p61s.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgyc2p61s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpgyc2p61s.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgyc2p61s.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgyc2p61s.jl:50\ntest set: Test Failed at /tmp/tmpgyc2p61s.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgyc2p61s.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgyc2p61s.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpgyc2p61s.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    return [0, 0]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9l__8wct.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp9l__8wct.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9l__8wct.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9l__8wct.jl:42\ntest set: Test Failed at /tmp/tmp9l__8wct.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9l__8wct.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9l__8wct.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp9l__8wct.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9l__8wct.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9l__8wct.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp9l__8wct.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9l__8wct.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9l__8wct.jl:42\ntest set: Test Failed at /tmp/tmp9l__8wct.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    min_index = findall(arr .==\
    \ min_value)[1]\n    return [min_value, min_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdmi781zc.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpdmi781zc.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdmi781zc.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdmi781zc.jl:55\ntest set: Test Failed at /tmp/tmpdmi781zc.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdmi781zc.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdmi781zc.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpdmi781zc.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdmi781zc.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdmi781zc.jl:55\ntest set: Test Failed at /tmp/tmpdmi781zc.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdmi781zc.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdmi781zc.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpdmi781zc.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    smallest_even = minimum(evens)\n    index = findfirst(arr,\
    \ smallest_even)\n    return [smallest_even, index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp090pyfoa.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmp090pyfoa.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp090pyfoa.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp090pyfoa.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp090pyfoa.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp090pyfoa.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp090pyfoa.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp090pyfoa.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp090pyfoa.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp090pyfoa.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798404
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n \
    \           push!(evens, arr[i])\n        end\n    end\n    if length(evens) ==\
    \ 0\n        return []\n    end\n    min_even = minimum(evens)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd9kwllml.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpd9kwllml.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd9kwllml.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd9kwllml.jl:55\ntest set: Test Failed at /tmp/tmpd9kwllml.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd9kwllml.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd9kwllml.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpd9kwllml.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd9kwllml.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd9kwllml.jl:55\ntest set: Test Failed at /tmp/tmpd9kwllml.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd9kwllml.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd9kwllml.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpd9kwllml.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_index = findfirst(arr, min_even)\n    return [min_even,\
    \ min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpqwk0fu8p.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpqwk0fu8p.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqwk0fu8p.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqwk0fu8p.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqwk0fu8p.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpqwk0fu8p.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpqwk0fu8p.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpqwk0fu8p.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpqwk0fu8p.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpqwk0fu8p.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798405
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmprhcxo37t.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmprhcxo37t.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprhcxo37t.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprhcxo37t.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprhcxo37t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprhcxo37t.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprhcxo37t.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprhcxo37t.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprhcxo37t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprhcxo37t.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_values)\n        return\
    \ []\n    end\n    even_values = sort(even_values, by = x -> x[1])\n    return\
    \ even_values[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpubu0zs4k.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpubu0zs4k.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpubu0zs4k.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpubu0zs4k.jl:54\ntest set: Test Failed at /tmp/tmpubu0zs4k.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubu0zs4k.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubu0zs4k.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpubu0zs4k.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpubu0zs4k.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpubu0zs4k.jl:54\ntest set: Test Failed at /tmp/tmpubu0zs4k.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpubu0zs4k.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpubu0zs4k.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpubu0zs4k.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    return [min_even_node, findfirst(arr,\
    \ min_even_node)]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t\
    @test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_7hm3sbz.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmp_7hm3sbz.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_7hm3sbz.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_7hm3sbz.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_7hm3sbz.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp_7hm3sbz.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_7hm3sbz.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_7hm3sbz.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_7hm3sbz.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp_7hm3sbz.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798405
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [i for i in arr\
    \ if i % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_0cx1ebu.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_0cx1ebu.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_0cx1ebu.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_0cx1ebu.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_0cx1ebu.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_0cx1ebu.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_0cx1ebu.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_0cx1ebu.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_0cx1ebu.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_0cx1ebu.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798405
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx4yvi323.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpx4yvi323.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # YOUR CODE HERE\n    if length(arr) == 0\n        return []\n    end\n\
    \    evens = []\n    for i in 1:length(arr)\n        if arr[i] % 2 == 0\n    \
    \        push!(evens, arr[i])\n        end\n    end\n    if length(evens) == 0\n\
    \        return []\n    end\n    min_even = minimum(evens)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1xsw1s5w.jl:57

    '
  stdout: "test set: Test Failed at /tmp/tmp1xsw1s5w.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1xsw1s5w.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1xsw1s5w.jl:59\ntest set: Test Failed at /tmp/tmp1xsw1s5w.jl:61\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1xsw1s5w.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1xsw1s5w.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp1xsw1s5w.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1xsw1s5w.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1xsw1s5w.jl:59\ntest set: Test Failed at /tmp/tmp1xsw1s5w.jl:64\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1xsw1s5w.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1xsw1s5w.jl:59\ntest set: Test\
    \ Failed at /tmp/tmp1xsw1s5w.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    min_index = findfirst(arr,\
    \ min_value)\n    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp6476cksr.jl:53

    '
  stdout: "test set: Error During Test at /tmp/tmp6476cksr.jl:56\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6476cksr.jl:48\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6476cksr.jl:56 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6476cksr.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp6476cksr.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6476cksr.jl:48\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6476cksr.jl:57 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6476cksr.jl:55\ntest set:\
    \ Error During Test at /tmp/tmp6476cksr.jl:59\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798405
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_nodes = [node\
    \ for node in arr if node % 2 == 0]\n    if length(even_nodes) == 0\n        return\
    \ []\n    end\n    min_even_node = minimum(even_nodes)\n    min_even_node_index\
    \ = findfirst(arr, min_even_node)\n    return [min_even_node, min_even_node_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpacr0t_7q.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpacr0t_7q.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpacr0t_7q.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpacr0t_7q.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpacr0t_7q.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpacr0t_7q.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpacr0t_7q.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpacr0t_7q.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpacr0t_7q.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpacr0t_7q.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    sort!(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnicrm6q3.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpnicrm6q3.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnicrm6q3.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnicrm6q3.jl:54\ntest set: Test Failed at /tmp/tmpnicrm6q3.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnicrm6q3.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnicrm6q3.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnicrm6q3.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnicrm6q3.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnicrm6q3.jl:54\ntest set: Test Failed at /tmp/tmpnicrm6q3.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnicrm6q3.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnicrm6q3.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpnicrm6q3.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798404
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpq149x5hn.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpq149x5hn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmp4hz6yk0h.jl:44

    '
  stdout: "test set: Error During Test at /tmp/tmp4hz6yk0h.jl:47\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4hz6yk0h.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4hz6yk0h.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4hz6yk0h.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp4hz6yk0h.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4hz6yk0h.jl:39\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4hz6yk0h.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4hz6yk0h.jl:46\ntest set:\
    \ Error During Test at /tmp/tmp4hz6yk0h.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_y3nede1.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp_y3nede1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_y3nede1.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp_y3nede1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_node = minimum(even_nodes)\n    min_even_node_index = findfirst(arr,\
    \ min_even_node)\n    return [min_even_node, min_even_node_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpg_lw2ea7.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpg_lw2ea7.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg_lw2ea7.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg_lw2ea7.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg_lw2ea7.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpg_lw2ea7.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpg_lw2ea7.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpg_lw2ea7.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpg_lw2ea7.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpg_lw2ea7.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa76t35us.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpa76t35us.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test Failed at /tmp/tmpa76t35us.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa76t35us.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa76t35us.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test Failed at /tmp/tmpa76t35us.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code goes here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm98g8zf8.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpm98g8zf8.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm98g8zf8.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm98g8zf8.jl:42\ntest set: Test Failed at /tmp/tmpm98g8zf8.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm98g8zf8.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm98g8zf8.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm98g8zf8.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm98g8zf8.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm98g8zf8.jl:42\ntest set: Test Failed at /tmp/tmpm98g8zf8.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: Int64[]\
    \ == [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm98g8zf8.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm98g8zf8.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm98g8zf8.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1."
  timestamp: 1659798404
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [i for i\
    \ in arr if i % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdgo71s7h.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpdgo71s7h.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdgo71s7h.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdgo71s7h.jl:50\ntest set: Test Failed at /tmp/tmpdgo71s7h.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdgo71s7h.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdgo71s7h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpdgo71s7h.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdgo71s7h.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdgo71s7h.jl:50\ntest set: Test Failed at /tmp/tmpdgo71s7h.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdgo71s7h.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdgo71s7h.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpdgo71s7h.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798404
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx4yvi323.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpx4yvi323.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp1ldztgdy.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp1ldztgdy.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ldztgdy.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ldztgdy.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ldztgdy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp1ldztgdy.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ldztgdy.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ldztgdy.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ldztgdy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp1ldztgdy.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    smallest_even_value\
    \ = nothing\n    smallest_even_index = nothing\n    for i in 1:length(arr)\n \
    \       if arr[i] % 2 == 0\n            if smallest_even_value == nothing\n  \
    \              smallest_even_value = arr[i]\n                smallest_even_index\
    \ = i\n            elseif arr[i] < smallest_even_value\n                smallest_even_value\
    \ = arr[i]\n                smallest_even_index = i\n            end\n       \
    \ end\n    end\n    if smallest_even_value == nothing\n        return []\n   \
    \ end\n    return [smallest_even_value, smallest_even_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3iva41pi.jl:58

    '
  stdout: "test set: Test Failed at /tmp/tmp3iva41pi.jl:61\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3iva41pi.jl:61 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3iva41pi.jl:60\ntest set: Test Failed at /tmp/tmp3iva41pi.jl:62\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3iva41pi.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3iva41pi.jl:60\ntest set: Test\
    \ Failed at /tmp/tmp3iva41pi.jl:64\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3iva41pi.jl:64 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3iva41pi.jl:60\ntest set: Test Failed at /tmp/tmp3iva41pi.jl:65\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3iva41pi.jl:65 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3iva41pi.jl:60\ntest set: Test\
    \ Failed at /tmp/tmp3iva41pi.jl:66\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798405
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcoyogz45.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpcoyogz45.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcoyogz45.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcoyogz45.jl:50\ntest set: Test Failed at /tmp/tmpcoyogz45.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcoyogz45.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcoyogz45.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpcoyogz45.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpcoyogz45.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpcoyogz45.jl:50\ntest set: Test Failed at /tmp/tmpcoyogz45.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcoyogz45.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcoyogz45.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpcoyogz45.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_values)\n        return []\n    end\n\
    \    min_even_value = minimum(even_values)\n    min_even_index = findfirst(arr\
    \ .== min_even_value)\n    return [min_even_value, min_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm4nabtcu.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpm4nabtcu.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm4nabtcu.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm4nabtcu.jl:50\ntest set: Test Failed at /tmp/tmpm4nabtcu.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm4nabtcu.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm4nabtcu.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpm4nabtcu.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm4nabtcu.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm4nabtcu.jl:50\ntest set: Test Failed at /tmp/tmpm4nabtcu.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm4nabtcu.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm4nabtcu.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpm4nabtcu.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_y3nede1.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp_y3nede1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_y3nede1.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp_y3nede1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ arr[i])\n        end\n    end\n    if length(even_arr) == 0\n        return\
    \ []\n    end\n    smallest_even = even_arr[1]\n    smallest_even_index = 0\n\
    \    for i in 1:length(even_arr)\n        if even_arr[i] < smallest_even\n   \
    \         smallest_even = even_arr[i]\n            smallest_even_index = i\n \
    \       end\n    end\n    return [smallest_even, smallest_even_index]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9kpl9t8r.jl:59

    '
  stdout: "test set: Test Failed at /tmp/tmp9kpl9t8r.jl:62\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9kpl9t8r.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9kpl9t8r.jl:61\ntest set: Test Failed at /tmp/tmp9kpl9t8r.jl:63\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9kpl9t8r.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9kpl9t8r.jl:61\ntest set: Test\
    \ Failed at /tmp/tmp9kpl9t8r.jl:65\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9kpl9t8r.jl:65 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9kpl9t8r.jl:61\ntest set: Test Failed at /tmp/tmp9kpl9t8r.jl:66\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 2] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9kpl9t8r.jl:66 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9kpl9t8r.jl:61\ntest set: Test\
    \ Failed at /tmp/tmp9kpl9t8r.jl:67\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 0] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798405
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmprzxxkxd0.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmprzxxkxd0.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprzxxkxd0.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprzxxkxd0.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprzxxkxd0.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprzxxkxd0.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprzxxkxd0.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprzxxkxd0.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprzxxkxd0.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprzxxkxd0.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    if min_even == Inf\n        return []\n    end\n \
    \   return [min_even, findfirst(arr, min_even)]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmp8phz7y8j.jl:46

    '
  stdout: "test set: Error During Test at /tmp/tmp8phz7y8j.jl:49\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8phz7y8j.jl:42\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8phz7y8j.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8phz7y8j.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp8phz7y8j.jl:50\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp8phz7y8j.jl:42\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp8phz7y8j.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp8phz7y8j.jl:48\ntest set:\
    \ Error During Test at /tmp/tmp8phz7y8j.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798408
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_indices = findall(arr\
    \ .% 2 .== 0)\n    if length(even_indices) == 0\n        return []\n    end\n\
    \    even_values = arr[even_indices]\n    min_value = minimum(even_values)\n \
    \   min_index = findfirst(even_values .== min_value)\n    return [min_value, even_indices[min_index]]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpci_xw41b.jl:49

    '
  stdout: "test set: Test Failed at /tmp/tmpci_xw41b.jl:52\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpci_xw41b.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpci_xw41b.jl:51\ntest set: Test Failed at /tmp/tmpci_xw41b.jl:53\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpci_xw41b.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpci_xw41b.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpci_xw41b.jl:55\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpci_xw41b.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpci_xw41b.jl:51\ntest set: Test Failed at /tmp/tmpci_xw41b.jl:56\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpci_xw41b.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpci_xw41b.jl:51\ntest set: Test\
    \ Failed at /tmp/tmpci_xw41b.jl:57\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpck0uvx4h.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpck0uvx4h.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test Failed at /tmp/tmpck0uvx4h.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpck0uvx4h.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test Failed at /tmp/tmpck0uvx4h.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpck0uvx4h.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpcy3iwaeo.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpcy3iwaeo.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return [0, 0]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpa76t35us.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpa76t35us.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test Failed at /tmp/tmpa76t35us.jl:44\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [0, 0] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa76t35us.jl:45\n  Expression: candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([])\n   Evaluated: [0, 0] == Int64[]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpa76t35us.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 0] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpa76t35us.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpa76t35us.jl:42\ntest set: Test Failed at /tmp/tmpa76t35us.jl:47\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 0] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/s"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_idx = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp1ldztgdy.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp1ldztgdy.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ldztgdy.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ldztgdy.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ldztgdy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp1ldztgdy.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp1ldztgdy.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp1ldztgdy.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp1ldztgdy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp1ldztgdy.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if isempty(evens)\n        return\
    \ []\n    end\n    smallest = minimum(evens)\n    index = findfirst(arr, smallest)\n\
    \    return [smallest, index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp9esxlz9q.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmp9esxlz9q.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp9esxlz9q.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9esxlz9q.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9esxlz9q.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp9esxlz9q.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp9esxlz9q.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9esxlz9q.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9esxlz9q.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp9esxlz9q.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    even_arr = sort(even_arr)\n    even_arr = even_arr[1]\n    return [even_arr,\
    \ findfirst(arr, even_arr)[1]]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp19xyid2f.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp19xyid2f.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp19xyid2f.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp19xyid2f.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp19xyid2f.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp19xyid2f.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp19xyid2f.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp19xyid2f.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp19xyid2f.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp19xyid2f.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpq149x5hn.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpq149x5hn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpq149x5hn.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpq149x5hn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyi7euljz.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpyi7euljz.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyi7euljz.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyi7euljz.jl:50\ntest set: Test Failed at /tmp/tmpyi7euljz.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyi7euljz.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyi7euljz.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpyi7euljz.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyi7euljz.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyi7euljz.jl:50\ntest set: Test Failed at /tmp/tmpyi7euljz.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyi7euljz.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyi7euljz.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpyi7euljz.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ arr[i])\n        end\n    end\n    if isempty(even_arr)\n        return []\n\
    \    end\n    min_even = minimum(even_arr)\n    for i in 1:length(arr)\n     \
    \   if arr[i] == min_even\n            return [min_even, i]\n        end\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_46hr4gz.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp_46hr4gz.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:60\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:62 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:63\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: [0, 4] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_46hr4gz.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_46hr4gz.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp_46hr4gz.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/ce"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ min_value = minimum(evens)\n    min_index = findall(arr .== min_value)[1]\n\
    \    return [min_value, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2rzvv_ec.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmp2rzvv_ec.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2rzvv_ec.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2rzvv_ec.jl:55\ntest set: Test Failed at /tmp/tmp2rzvv_ec.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2rzvv_ec.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2rzvv_ec.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp2rzvv_ec.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2rzvv_ec.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2rzvv_ec.jl:55\ntest set: Test Failed at /tmp/tmp2rzvv_ec.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2rzvv_ec.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2rzvv_ec.jl:55\ntest set: Test\
    \ Failed at /tmp/tmp2rzvv_ec.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7pxywhjs.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp7pxywhjs.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_y3nede1.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp_y3nede1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_y3nede1.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp_y3nede1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    even_arr = [i for i in arr if i % 2 == 0]\n    if isempty(even_arr)\n\
    \        return []\n    else\n        min_even = minimum(even_arr)\n        return\
    \ [min_even, findfirst(arr, min_even)]\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp61h8i6zk.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmp61h8i6zk.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61h8i6zk.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61h8i6zk.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61h8i6zk.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp61h8i6zk.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp61h8i6zk.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp61h8i6zk.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp61h8i6zk.jl:47\ntest set:\
    \ Error During Test at /tmp/tmp61h8i6zk.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpcy3iwaeo.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpcy3iwaeo.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7pxywhjs.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp7pxywhjs.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpxym45e70.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpxym45e70.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxym45e70.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxym45e70.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxym45e70.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxym45e70.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxym45e70.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxym45e70.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxym45e70.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxym45e70.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpt416p9lz.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmpt416p9lz.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt416p9lz.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt416p9lz.jl:53\ntest set: Test Failed at /tmp/tmpt416p9lz.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt416p9lz.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt416p9lz.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpt416p9lz.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt416p9lz.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt416p9lz.jl:53\ntest set: Test Failed at /tmp/tmpt416p9lz.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt416p9lz.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt416p9lz.jl:53\ntest set: Test\
    \ Failed at /tmp/tmpt416p9lz.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp212_b6td.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp212_b6td.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test Failed at /tmp/tmp212_b6td.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp212_b6td.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test Failed at /tmp/tmp212_b6td.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp212_b6td.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findall(arr .== min_even)[1]\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpg45xz4cn.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpg45xz4cn.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpg45xz4cn.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpg45xz4cn.jl:50\ntest set: Test Failed at /tmp/tmpg45xz4cn.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg45xz4cn.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg45xz4cn.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpg45xz4cn.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpg45xz4cn.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpg45xz4cn.jl:50\ntest set: Test Failed at /tmp/tmpg45xz4cn.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpg45xz4cn.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpg45xz4cn.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpg45xz4cn.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ (i, v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v,\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    return sort!(evens)[1]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_sh5xffm.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmp_sh5xffm.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_sh5xffm.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_sh5xffm.jl:53\ntest set: Test Failed at /tmp/tmp_sh5xffm.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_sh5xffm.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_sh5xffm.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp_sh5xffm.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_sh5xffm.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_sh5xffm.jl:53\ntest set: Test Failed at /tmp/tmp_sh5xffm.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp_sh5xffm.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp_sh5xffm.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp_sh5xffm.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798407
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    evens = filter(x -> x % 2 == 0, arr)\n    if length(evens) == 0\n    \
    \    return []\n    end\n    min_even = minimum(evens)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpv2oedss0.jl:45

    '
  stdout: "test set: Error During Test at /tmp/tmpv2oedss0.jl:48\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpv2oedss0.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv2oedss0.jl:48 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv2oedss0.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpv2oedss0.jl:49\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpv2oedss0.jl:40\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpv2oedss0.jl:49 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpv2oedss0.jl:47\ntest set:\
    \ Error During Test at /tmp/tmpv2oedss0.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_idx = findall(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_idx)\n        return []\n    end\n\
    \    min_even = minimum(arr[even_idx])\n    min_even_idx = findfirst(arr .== min_even)\n\
    \    return [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmv9p1ish.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmpmv9p1ish.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmv9p1ish.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpmv9p1ish.jl:50\ntest set: Test Failed at /tmp/tmpmv9p1ish.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmv9p1ish.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmv9p1ish.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpmv9p1ish.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmv9p1ish.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpmv9p1ish.jl:50\ntest set: Test Failed at /tmp/tmpmv9p1ish.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmv9p1ish.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmv9p1ish.jl:50\ntest set: Test\
    \ Failed at /tmp/tmpmv9p1ish.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798408
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # if the array is empty, return empty array\n    if length(arr) == 0\n\
    \        return []\n    end\n    \n    # find the smallest even value\n    smallest_even\
    \ = minimum(filter(x -> x % 2 == 0, arr))\n    \n    # find the index of the smallest\
    \ even value\n    smallest_even_index = findfirst(arr, smallest_even)\n    \n\
    \    # return the smallest even value and its index\n    return [smallest_even,\
    \ smallest_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpkwsm_iu9.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpkwsm_iu9.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkwsm_iu9.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkwsm_iu9.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkwsm_iu9.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpkwsm_iu9.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpkwsm_iu9.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpkwsm_iu9.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpkwsm_iu9.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpkwsm_iu9.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx4yvi323.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpx4yvi323.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7pxywhjs.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp7pxywhjs.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    for i in 1:length(arr)\n        if arr[i]\
    \ == min_even\n            return [min_even, i]\n        end\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2cp5s3ti.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp2cp5s3ti.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test Failed at /tmp/tmp2cp5s3ti.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2cp5s3ti.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2cp5s3ti.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp2cp5s3ti.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_even_index = findall(arr .==\
    \ min_even)[1]\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5cec447_.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp5cec447_.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5cec447_.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5cec447_.jl:50\ntest set: Test Failed at /tmp/tmp5cec447_.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5cec447_.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5cec447_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp5cec447_.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5cec447_.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5cec447_.jl:50\ntest set: Test Failed at /tmp/tmp5cec447_.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5cec447_.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5cec447_.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp5cec447_.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798408
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpcy3iwaeo.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpcy3iwaeo.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpcy3iwaeo.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcy3iwaeo.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcy3iwaeo.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpcy3iwaeo.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    min_even = Inf\n\
    \    min_even_index = 0\n    for i in 1:length(arr)\n        if arr[i] % 2 ==\
    \ 0 && arr[i] < min_even\n            min_even = arr[i]\n            min_even_index\
    \ = i\n        end\n    end\n    if min_even == Inf\n        return []\n    end\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpogim1xir.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpogim1xir.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpogim1xir.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpogim1xir.jl:55\ntest set: Test Failed at /tmp/tmpogim1xir.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpogim1xir.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpogim1xir.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpogim1xir.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpogim1xir.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpogim1xir.jl:55\ntest set: Test Failed at /tmp/tmpogim1xir.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpogim1xir.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpogim1xir.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpogim1xir.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798408
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = arr[arr .%\
    \ 2 .== 0]\n    if isempty(even_arr)\n        return []\n    end\n    min_even\
    \ = minimum(even_arr)\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp62_3uwyg.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp62_3uwyg.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test Failed at /tmp/tmp62_3uwyg.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp62_3uwyg.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test Failed at /tmp/tmp62_3uwyg.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp62_3uwyg.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_indices = findall(arr\
    \ .% 2 .== 0)\n    if isempty(even_indices)\n        return []\n    end\n    even_values\
    \ = arr[even_indices]\n    min_index = findmin(even_values)[2]\n    return [even_values[min_index],\
    \ even_indices[min_index]]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7ow4isoj.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp7ow4isoj.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7ow4isoj.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7ow4isoj.jl:50\ntest set: Test Failed at /tmp/tmp7ow4isoj.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ow4isoj.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ow4isoj.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp7ow4isoj.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7ow4isoj.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7ow4isoj.jl:50\ntest set: Test Failed at /tmp/tmp7ow4isoj.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7ow4isoj.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7ow4isoj.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp7ow4isoj.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = arr[arr .%\
    \ 2 .== 0]\n    if isempty(even_arr)\n        return []\n    end\n    min_even\
    \ = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpomlrn9dm.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpomlrn9dm.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpomlrn9dm.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpomlrn9dm.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpomlrn9dm.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpomlrn9dm.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpomlrn9dm.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpomlrn9dm.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpomlrn9dm.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpomlrn9dm.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp_y3nede1.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmp_y3nede1.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_y3nede1.jl:41\ntest set:\
    \ Error During Test at /tmp/tmp_y3nede1.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_y3nede1.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_y3nede1.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpxym45e70.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpxym45e70.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxym45e70.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxym45e70.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxym45e70.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxym45e70.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxym45e70.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxym45e70.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxym45e70.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxym45e70.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp7frsbe6u.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp7frsbe6u.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7frsbe6u.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7frsbe6u.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7frsbe6u.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp7frsbe6u.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp7frsbe6u.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp7frsbe6u.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp7frsbe6u.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp7frsbe6u.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nodes = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nodes)\n        return []\n    end\n\
    \    min_even_value = minimum(even_nodes)\n    min_even_index = findfirst(arr,\
    \ min_even_value)\n    return [min_even_value, min_even_index]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpfi5av07j.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpfi5av07j.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfi5av07j.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfi5av07j.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfi5av07j.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpfi5av07j.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfi5av07j.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfi5av07j.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfi5av07j.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpfi5av07j.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpfivfm8za.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmpfivfm8za.jl:42\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type Vector{Int64}\n  Closest candidates\
    \ are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfivfm8za.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfivfm8za.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfivfm8za.jl:41\ntest set:\
    \ Error During Test at /tmp/tmpfivfm8za.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: Cannot `convert` an object of\
    \ type Nothing to an object of type Vector{Int64}\n  Closest candidates are:\n\
    \    convert(::Type{T}, !Matched::LinearAlgebra.Factorization) where T<:AbstractArray\
    \ at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/base/abstractarray.jl:16\n\
    \    ...\n  Stacktrace:\n   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfivfm8za.jl:36\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfivfm8za.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/s"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n \
    \       if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprwjt0lvu.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmprwjt0lvu.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpq149x5hn.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpq149x5hn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr .== min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8mwx8t3z.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp8mwx8t3z.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8mwx8t3z.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8mwx8t3z.jl:50\ntest set: Test Failed at /tmp/tmp8mwx8t3z.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8mwx8t3z.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8mwx8t3z.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8mwx8t3z.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8mwx8t3z.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8mwx8t3z.jl:50\ntest set: Test Failed at /tmp/tmp8mwx8t3z.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8mwx8t3z.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8mwx8t3z.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp8mwx8t3z.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [i for i in\
    \ arr if i % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_val = minimum(even_arr)\n    min_idx = findfirst(arr, min_val)\n    return\
    \ [min_val, min_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp55x6x391.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp55x6x391.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp55x6x391.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp55x6x391.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp55x6x391.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp55x6x391.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp55x6x391.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp55x6x391.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp55x6x391.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp55x6x391.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf0qasqx3.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpf0qasqx3.jl:43\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:44\n  Expression: candidate([1, 2, 3]) == [2,\
    \ 1]\n   Evaluated: Int64[] == [2, 1]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:46\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: Int64[] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:47\n  Expression: candidate([1, 2, 3, 0, 5, 3])\
    \ == [0, 3]\n   Evaluated: Int64[] == [0, 3]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpf0qasqx3.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf0qasqx3.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpf0qasqx3.jl:48\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: Int64[] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shar"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = []\n    for\
    \ i in arr\n        if i % 2 == 0\n            push!(even_arr, i)\n        end\n\
    \    end\n    if isempty(even_arr)\n        return []\n    end\n    min_even =\
    \ minimum(even_arr)\n    for i in 1:length(arr)\n        if arr[i] == min_even\n\
    \            return [min_even, i]\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp56gwpxyt.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp56gwpxyt.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp56gwpxyt.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp56gwpxyt.jl:58\ntest set: Test Failed at /tmp/tmp56gwpxyt.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp56gwpxyt.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp56gwpxyt.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp56gwpxyt.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp56gwpxyt.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp56gwpxyt.jl:58\ntest set: Test Failed at /tmp/tmp56gwpxyt.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp56gwpxyt.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp56gwpxyt.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp56gwpxyt.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_idx = findfirst(arr, min_even)\n    return [min_even,\
    \ min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpx4yvi323.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpx4yvi323.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpx4yvi323.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpx4yvi323.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpx4yvi323.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpx4yvi323.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for (i,\
    \ v) in enumerate(arr)\n        if v % 2 == 0\n            push!(evens, [v, i])\n\
    \        end\n    end\n    if isempty(evens)\n        return []\n    end\n   \
    \ evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp37xh4v0t.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp37xh4v0t.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp37xh4v0t.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp37xh4v0t.jl:54\ntest set: Test Failed at /tmp/tmp37xh4v0t.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp37xh4v0t.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp37xh4v0t.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp37xh4v0t.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp37xh4v0t.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp37xh4v0t.jl:54\ntest set: Test Failed at /tmp/tmp37xh4v0t.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp37xh4v0t.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp37xh4v0t.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp37xh4v0t.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpq149x5hn.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpq149x5hn.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpq149x5hn.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpq149x5hn.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpq149x5hn.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpq149x5hn.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [x for\
    \ x in arr if x % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_even_index = findfirst(arr,\
    \ min_even)\n    return [min_even, min_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpxym45e70.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpxym45e70.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxym45e70.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxym45e70.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxym45e70.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxym45e70.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpxym45e70.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxym45e70.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxym45e70.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpxym45e70.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp_1ezibm3.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp_1ezibm3.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp_1ezibm3.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_1ezibm3.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_1ezibm3.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp_1ezibm3.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, i)\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = evens[1]\n    for i in 2:length(evens)\n        if arr[evens[i]]\
    \ < arr[min_even]\n            min_even = evens[i]\n        end\n    end\n   \
    \ return [arr[min_even], min_even]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpiovzkth7.jl:57

    '
  stdout: "test set: Test Failed at /tmp/tmpiovzkth7.jl:60\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiovzkth7.jl:60 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiovzkth7.jl:59\ntest set: Test Failed at /tmp/tmpiovzkth7.jl:61\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiovzkth7.jl:61 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiovzkth7.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpiovzkth7.jl:63\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpiovzkth7.jl:63 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpiovzkth7.jl:59\ntest set: Test Failed at /tmp/tmpiovzkth7.jl:64\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpiovzkth7.jl:64 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpiovzkth7.jl:59\ntest set: Test\
    \ Failed at /tmp/tmpiovzkth7.jl:65\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ [arr[i], i])\n        end\n    end\n    if length(even_arr) == 0\n        return\
    \ []\n    end\n    sorted_even_arr = sort(even_arr, by = x -> x[1])\n    return\
    \ sorted_even_arr[1]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpgmb13303.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpgmb13303.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgmb13303.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgmb13303.jl:54\ntest set: Test Failed at /tmp/tmpgmb13303.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmb13303.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmb13303.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgmb13303.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpgmb13303.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpgmb13303.jl:54\ntest set: Test Failed at /tmp/tmpgmb13303.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpgmb13303.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpgmb13303.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpgmb13303.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if length(evens) == 0\n        return []\n  \
    \  end\n    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpck0uvx4h.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmpck0uvx4h.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test Failed at /tmp/tmpck0uvx4h.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpck0uvx4h.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test Failed at /tmp/tmpck0uvx4h.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpck0uvx4h.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpck0uvx4h.jl:54\ntest set: Test\
    \ Failed at /tmp/tmpck0uvx4h.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798401
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    ind = findfirst(arr, min_even)\n    return [min_even,\
    \ ind]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp0cz7ci8f.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp0cz7ci8f.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0cz7ci8f.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0cz7ci8f.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0cz7ci8f.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp0cz7ci8f.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp0cz7ci8f.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0cz7ci8f.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0cz7ci8f.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp0cz7ci8f.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798411
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7pxywhjs.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp7pxywhjs.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    smallest_even\
    \ = minimum(evens)\n    smallest_even_index = findfirst(arr, smallest_even)\n\
    \    return [smallest_even, smallest_even_index]\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpca8huey8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpca8huey8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpca8huey8.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpca8huey8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpca8huey8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpca8huey8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpca8huey8.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpca8huey8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpca8huey8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpca8huey8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798403
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmph773vei4.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmph773vei4.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmph773vei4.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph773vei4.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph773vei4.jl:50\ntest set:\
    \ Error During Test at /tmp/tmph773vei4.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmph773vei4.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph773vei4.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph773vei4.jl:50\ntest set:\
    \ Error During Test at /tmp/tmph773vei4.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798411
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ arr[i])\n        end\n    end\n    if length(even_arr) == 0\n        return\
    \ []\n    end\n    min_even = minimum(even_arr)\n    for i in 1:length(arr)\n\
    \        if arr[i] == min_even\n            return [min_even, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm4r8is6u.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmpm4r8is6u.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm4r8is6u.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm4r8is6u.jl:58\ntest set: Test Failed at /tmp/tmpm4r8is6u.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm4r8is6u.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm4r8is6u.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpm4r8is6u.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm4r8is6u.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm4r8is6u.jl:58\ntest set: Test Failed at /tmp/tmpm4r8is6u.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm4r8is6u.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm4r8is6u.jl:58\ntest set: Test\
    \ Failed at /tmp/tmpm4r8is6u.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_arr,\
    \ [arr[i], i])\n        end\n    end\n    if isempty(even_arr)\n        return\
    \ []\n    end\n    return sort!(even_arr)[1]\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6bfby8p3.jl:51

    '
  stdout: "test set: Test Failed at /tmp/tmp6bfby8p3.jl:54\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6bfby8p3.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6bfby8p3.jl:53\ntest set: Test Failed at /tmp/tmp6bfby8p3.jl:55\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6bfby8p3.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6bfby8p3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp6bfby8p3.jl:57\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6bfby8p3.jl:57 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6bfby8p3.jl:53\ntest set: Test Failed at /tmp/tmp6bfby8p3.jl:58\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6bfby8p3.jl:58 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6bfby8p3.jl:53\ntest set: Test\
    \ Failed at /tmp/tmp6bfby8p3.jl:59\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798410
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = filter(x -> x\
    \ % 2 == 0, arr)\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    return [min_even, findfirst(arr, min_even)]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) ==\
    \ [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp6el0ff30.jl:47

    '
  stdout: "test set: Error During Test at /tmp/tmp6el0ff30.jl:50\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6el0ff30.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6el0ff30.jl:50 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6el0ff30.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp6el0ff30.jl:51\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp6el0ff30.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6el0ff30.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6el0ff30.jl:49\ntest set:\
    \ Error During Test at /tmp/tmp6el0ff30.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798412
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = [x for x\
    \ in arr if x % 2 == 0]\n    if length(evens) == 0\n        return []\n    end\n\
    \    min_even = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmprhcxo37t.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmprhcxo37t.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprhcxo37t.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprhcxo37t.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprhcxo37t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprhcxo37t.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmprhcxo37t.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprhcxo37t.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprhcxo37t.jl:50\ntest set:\
    \ Error During Test at /tmp/tmprhcxo37t.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798400
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = arr[arr .%\
    \ 2 .== 0]\n    if isempty(even_arr)\n        return []\n    end\n    min_even\
    \ = minimum(even_arr)\n    min_even_idx = findfirst(arr .== min_even)\n    return\
    \ [min_even, min_even_idx]\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\
    \t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\
    \t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp62_3uwyg.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp62_3uwyg.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test Failed at /tmp/tmp62_3uwyg.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp62_3uwyg.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test Failed at /tmp/tmp62_3uwyg.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp62_3uwyg.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp62_3uwyg.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp62_3uwyg.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798409
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_indices = findall(x\
    \ -> x % 2 == 0, arr)\n    if length(even_indices) == 0\n        return []\n \
    \   end\n    even_values = arr[even_indices]\n    min_value = minimum(even_values)\n\
    \    min_index = findfirst(arr, min_value)\n    return [min_value, min_index]\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp4npkpulg.jl:49

    '
  stdout: "test set: Error During Test at /tmp/tmp4npkpulg.jl:52\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4npkpulg.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4npkpulg.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4npkpulg.jl:51\ntest set:\
    \ Error During Test at /tmp/tmp4npkpulg.jl:53\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp4npkpulg.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp4npkpulg.jl:53 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp4npkpulg.jl:51\ntest set:\
    \ Error During Test at /tmp/tmp4npkpulg.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798412
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_values = []\n  \
    \  for i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(even_values,\
    \ arr[i])\n        end\n    end\n    if isempty(even_values)\n        return []\n\
    \    end\n    min_value = minimum(even_values)\n    for i in 1:length(arr)\n \
    \       if arr[i] == min_value\n            return [min_value, i]\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprwjt0lvu.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmprwjt0lvu.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test Failed at /tmp/tmprwjt0lvu.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmprwjt0lvu.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmprwjt0lvu.jl:58\ntest set: Test\
    \ Failed at /tmp/tmprwjt0lvu.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = []\n    for i\
    \ in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, [arr[i],\
    \ i])\n        end\n    end\n    if isempty(evens)\n        return []\n    end\n\
    \    evens = sort(evens, by = x -> x[1])\n    return evens[1]\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7pxywhjs.jl:52

    '
  stdout: "test set: Test Failed at /tmp/tmp7pxywhjs.jl:55\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:56\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:58\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:58 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test Failed at /tmp/tmp7pxywhjs.jl:59\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7pxywhjs.jl:59 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7pxywhjs.jl:54\ntest set: Test\
    \ Failed at /tmp/tmp7pxywhjs.jl:60\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798406
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = [x for x in\
    \ arr if x % 2 == 0]\n    if isempty(even_arr)\n        return []\n    end\n \
    \   min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvh4afri8.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvh4afri8.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvh4afri8.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvh4afri8.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvh4afri8.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvh4afri8.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_arr = filter(x ->\
    \ x % 2 == 0, arr)\n    if isempty(even_arr)\n        return []\n    end\n   \
    \ min_even = minimum(even_arr)\n    min_even_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmp04vx32oq.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmp04vx32oq.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmp04vx32oq.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp04vx32oq.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp04vx32oq.jl:50\ntest set:\
    \ Error During Test at /tmp/tmp04vx32oq.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = []\n \
    \   for i in arr\n        if i % 2 == 0\n            push!(even_arr, i)\n    \
    \    end\n    end\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_val = minimum(even_arr)\n    min_index = findall(arr .== min_val)[1]\n\
    \    return [min_val, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnj4trtae.jl:53

    '
  stdout: "test set: Test Failed at /tmp/tmpnj4trtae.jl:56\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnj4trtae.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnj4trtae.jl:55\ntest set: Test Failed at /tmp/tmpnj4trtae.jl:57\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnj4trtae.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnj4trtae.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpnj4trtae.jl:59\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnj4trtae.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnj4trtae.jl:55\ntest set: Test Failed at /tmp/tmpnj4trtae.jl:60\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnj4trtae.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnj4trtae.jl:55\ntest set: Test\
    \ Failed at /tmp/tmpnj4trtae.jl:61\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798411
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = filter(x\
    \ -> x % 2 == 0, arr)\n    if length(even_arr) == 0\n        return []\n    end\n\
    \    min_even = minimum(even_arr)\n    min_even_index = findall(arr .== min_even)[1]\n\
    \    return [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\n\
    candidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp212_b6td.jl:48

    '
  stdout: "test set: Test Failed at /tmp/tmp212_b6td.jl:51\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test Failed at /tmp/tmp212_b6td.jl:52\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp212_b6td.jl:54\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test Failed at /tmp/tmp212_b6td.jl:55\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp212_b6td.jl:55 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp212_b6td.jl:50\ntest set: Test\
    \ Failed at /tmp/tmp212_b6td.jl:56\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798398
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    # check if the array is empty\n    if isempty(arr)\n        return []\n\
    \    end\n    \n    # find the smallest even value\n    smallest_even = minimum(filter(x\
    \ -> x % 2 == 0, arr))\n    \n    # find the index of the smallest even value\n\
    \    index = findfirst(arr, smallest_even)\n    \n    # return the smallest even\
    \ value and its index\n    return [smallest_even, index]\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\
    \t@test(candidate([1, 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([]))\
    \ == Vector{Int64}([]))\n\t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t\
    @test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4,\
    \ 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1]) == [6, 1])\n\t@test(candidate([7,\
    \ 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 0 failed, 7 errored,
    0 broken.

    in expression starting at /tmp/tmpisfp0ldh.jl:51

    '
  stdout: "test set: Error During Test at /tmp/tmpisfp0ldh.jl:54\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpisfp0ldh.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpisfp0ldh.jl:54 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpisfp0ldh.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpisfp0ldh.jl:55\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpisfp0ldh.jl:44\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpisfp0ldh.jl:55 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpisfp0ldh.jl:53\ntest set:\
    \ Error During Test at /tmp/tmpisfp0ldh.jl:57\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798412
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    even_nums = filter(x\
    \ -> x % 2 == 0, arr)\n    if isempty(even_nums)\n        return []\n    end\n\
    \    min_even = minimum(even_nums)\n    min_even_ind = findfirst(arr, min_even)\n\
    \    return [min_even, min_even_ind]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpfh6jupm5.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpfh6jupm5.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfh6jupm5.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfh6jupm5.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfh6jupm5.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpfh6jupm5.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpfh6jupm5.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpfh6jupm5.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpfh6jupm5.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpfh6jupm5.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798412
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    evens = []\n    for\
    \ i in 1:length(arr)\n        if arr[i] % 2 == 0\n            push!(evens, arr[i])\n\
    \        end\n    end\n    if length(evens) == 0\n        return []\n    end\n\
    \    evens = sort(evens)\n    for i in 1:length(arr)\n        if arr[i] == evens[1]\n\
    \            return [evens[1], i]\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1,\
    \ 2, 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4ghy42o2.jl:56

    '
  stdout: "test set: Test Failed at /tmp/tmp4ghy42o2.jl:59\n  Expression: candidate([4,\
    \ 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4ghy42o2.jl:59 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4ghy42o2.jl:58\ntest set: Test Failed at /tmp/tmp4ghy42o2.jl:60\n\
    \  Expression: candidate([1, 2, 3]) == [2, 1]\n   Evaluated: [2, 2] == [2, 1]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4ghy42o2.jl:60 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4ghy42o2.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4ghy42o2.jl:62\n  Expression: candidate([5, 0, 3, 0, 4, 2])\
    \ == [0, 1]\n   Evaluated: [0, 2] == [0, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4ghy42o2.jl:62 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4ghy42o2.jl:58\ntest set: Test Failed at /tmp/tmp4ghy42o2.jl:63\n\
    \  Expression: candidate([1, 2, 3, 0, 5, 3]) == [0, 3]\n   Evaluated: [0, 4] ==\
    \ [0, 3]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4ghy42o2.jl:63 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4ghy42o2.jl:58\ntest set: Test\
    \ Failed at /tmp/tmp4ghy42o2.jl:64\n  Expression: candidate([5, 4, 8, 4, 8]) ==\
    \ [4, 1]\n   Evaluated: [4, 2] == [4, 1]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Tes"
  timestamp: 1659798411
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if length(arr) == 0\n        return []\n    end\n    even_arr = [i for\
    \ i in arr if i % 2 == 0]\n    if length(even_arr) == 0\n        return []\n \
    \   end\n    min_even = minimum(even_arr)\n    min_index = findfirst(arr, min_even)\n\
    \    return [min_even, min_index]\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2,\
    \ 3]) == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\
    \t@test(candidate([5, 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3,\
    \ 0, 5, 3]) == [0, 3])\n\t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7,\
    \ 6, 7, 1]) == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpvw_avkcy.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpvw_avkcy.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvw_avkcy.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvw_avkcy.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvw_avkcy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvw_avkcy.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at ~/.conda/envs/polyglot/share/julia/base/array.jl:1910\n  Stacktrace:\n  \
    \ [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpvw_avkcy.jl:43\n   [2] macro\
    \ expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvw_avkcy.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvw_avkcy.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpvw_avkcy.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Fun"
  timestamp: 1659798413
- exit_code: 1
  program: "\"\"\"\n    \"Given an array representing a branch of a tree that has\
    \ non-negative integer nodes\n    your task is to pluck one of the nodes and return\
    \ it.\n    The plucked node should be the node with the smallest even value.\n\
    \    If multiple nodes with the same smallest even value are found return the\
    \ node that has smallest index.\n\n    The plucked node should be returned in\
    \ a list, [ smalest_value, its index ],\n    If there are no even values or the\
    \ given array is empty, return [].\n\n    Example 1:\n    >>> pluck([4, 2, 3])\n\
    \    [2, 1]\n    Explanation: 2 has the smallest even value, and 2 has the smallest\
    \ index.\n\n    Example 2:\n    >>> pluck([1, 2, 3])\n    [2, 1]\n    Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n\n    Example\
    \ 3:\n    >>> pluck([])\n    []\n    \n    Example 4:\n    >>> pluck([5, 0, 3,\
    \ 0, 4, 2])\n    [0, 1]\n    Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n                 so we will choose the first zero, which has\
    \ the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n\
    \        * 0 <= node.value\n    \"\"\"\nfunction pluck(arr::Vector{Int64})::Vector{Int64}\
    \ \n    if isempty(arr)\n        return []\n    end\n    evens = [x for x in arr\
    \ if x % 2 == 0]\n    if isempty(evens)\n        return []\n    end\n    min_even\
    \ = minimum(evens)\n    min_even_index = findfirst(arr, min_even)\n    return\
    \ [min_even, min_even_index]\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ pluck;\n\t@test(candidate([4, 2, 3]) == [2, 1])\n\t@test(candidate([1, 2, 3])\
    \ == [2, 1])\n\t@test(candidate(Vector{Int64}([])) == Vector{Int64}([]))\n\t@test(candidate([5,\
    \ 0, 3, 0, 4, 2]) == [0, 1])\n\t@test(candidate([1, 2, 3, 0, 5, 3]) == [0, 3])\n\
    \t@test(candidate([5, 4, 8, 4, 8]) == [4, 1])\n\t@test(candidate([7, 6, 7, 1])\
    \ == [6, 1])\n\t@test(candidate([7, 9, 7, 1]) == Vector{Int64}([]))\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 6 errored,
    0 broken.

    in expression starting at /tmp/tmpr_bm1u99.jl:48

    '
  stdout: "test set: Error During Test at /tmp/tmpr_bm1u99.jl:51\n  Test threw exception\n\
    \  Expression: candidate([4, 2, 3]) == [2, 1]\n  MethodError: no method matching\
    \ findfirst(::Vector{Int64}, ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function,\
    \ ::Any) at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr_bm1u99.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_bm1u99.jl:51 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_bm1u99.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpr_bm1u99.jl:52\n  Test threw exception\n  Expression:\
    \ candidate([1, 2, 3]) == [2, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  Closest candidates are:\n    findfirst(!Matched::Function, ::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1994\n    findfirst(::AbstractArray)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1920\n    findfirst(::Any)\
    \ at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:1910\n  Stacktrace:\n\
    \   [1] pluck(arr::Vector{Int64})\n     @ Main /tmp/tmpr_bm1u99.jl:43\n   [2]\
    \ macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr_bm1u99.jl:52 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr_bm1u99.jl:50\ntest set:\
    \ Error During Test at /tmp/tmpr_bm1u99.jl:54\n  Test threw exception\n  Expression:\
    \ candidate([5, 0, 3, 0, 4, 2]) == [0, 1]\n  MethodError: no method matching findfirst(::Vector{Int64},\
    \ ::Int64)\n  C"
