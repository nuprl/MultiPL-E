language: jl
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = Vector{String}()\n    paren_group = \"\"\n    open_parens = 0\n    for c in\
    \ paren_string\n        if c == '('\n            open_parens += 1\n        elseif\
    \ c == ')'\n            open_parens -= 1\n        end\n        paren_group *=\
    \ c\n        if open_parens == 0\n            push!(paren_groups, paren_group)\n\
    \            paren_group = \"\"\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc5rkniem.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpc5rkniem.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test Failed at /tmp/tmpc5rkniem.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = Vector{String}()\n    open_parens = 0\n    start_index = 0\n    for (i, char)\
    \ in enumerate(paren_string)\n        if char == '('\n            open_parens\
    \ += 1\n        elseif char == ')'\n            open_parens -= 1\n        end\n\
    \        if open_parens == 0\n            push!(paren_groups, paren_string[start_index:i])\n\
    \            start_index = i + 1\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpj5196d_d.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpj5196d_d.jl:31\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  BoundsError: attempt to access 24-codeunit String\
    \ at index [0:6]\n  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216\
    \ [inlined]\n   [2] getindex\n     @ ./strings/string.jl:261 [inlined]\n   [3]\
    \ separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpj5196d_d.jl:20\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpj5196d_d.jl:31 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpj5196d_d.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpj5196d_d.jl:32\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  BoundsError: attempt to access 20-codeunit String at index [0:2]\n\
    \  Stacktrace:\n   [1] checkbounds\n     @ ./strings/basic.jl:216 [inlined]\n\
    \   [2] getindex\n     @ ./strings/string.jl:261 [inlined]\n   [3] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpj5196d_d.jl:20\n   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [5] macro expansion\n     @ /tmp/tmpj5196d_d.jl:32 [inlined]\n\
    \   [6] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [7] top-level scope\n     @ /tmp/tmpj5196d_d.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpj5196d_d.jl:33\n  Test threw exception\n  Expression:\
    \ candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n  BoundsError: attempt\
    \ to access 14-codeunit String at index [0:14]\n  Stacktrace:\n   [1] checkbounds\n\
    \     @ ./strings/basic.jl:216 [inlined]\n   [2] getindex\n     @ ./strings/string.jl:261\
    \ [inlined]\n   [3] separate_paren_groups(paren_string::String)\n     @ Main /tmp/tmpj5196d_d.jl:20\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/pol"
  timestamp: 1659795076
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    group = \"\"\n    open_parens = 0\n    for c in paren_string\n   \
    \     if c == '('\n            open_parens += 1\n        elseif c == ')'\n   \
    \         open_parens -= 1\n        end\n        group *= c\n        if open_parens\
    \ == 0\n            push!(paren_groups, group)\n            group = \"\"\n   \
    \     end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = Vector{String}()\n    paren_group = \"\"\n    open_parens = 0\n    for c in\
    \ paren_string\n        if c == '('\n            open_parens += 1\n        elseif\
    \ c == ')'\n            open_parens -= 1\n        end\n        paren_group *=\
    \ c\n        if open_parens == 0\n            push!(paren_groups, paren_group)\n\
    \            paren_group = \"\"\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = Vector{String}()\n    paren_group = \"\"\n    open_parens = 0\n    for i in\
    \ 1:length(paren_string)\n        if paren_string[i] == '('\n            open_parens\
    \ += 1\n        elseif paren_string[i] == ')'\n            open_parens -= 1\n\
    \        end\n        paren_group *= paren_string[i]\n        if open_parens ==\
    \ 0\n            push!(paren_groups, paren_group)\n            paren_group = \"\
    \"\n        end\n    end\n    return paren_groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    start_index = 1\n    for (i, c) in enumerate(paren_string)\n     \
    \   if c == '('\n            start_index = i\n        elseif c == ')'\n      \
    \      push!(paren_groups, paren_string[start_index:i])\n        end\n    end\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzdxcrak8.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpzdxcrak8.jl:26\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"()\",\
    \ \"()\", \"())\", \"()\", \"()\", \"())\"] == [\"(()())\", \"((()))\", \"()\"\
    , \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzdxcrak8.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzdxcrak8.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpzdxcrak8.jl:27\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"()\"\
    , \"())\", \"()\", \"())\", \"()))\", \"()\", \"())\", \"()))\", \"())))\"] ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzdxcrak8.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzdxcrak8.jl:25\ntest set: Test Failed at /tmp/tmpzdxcrak8.jl:28\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"()\", \"()\", \"())\", \"()\", \"())\", \"()))\", \"())))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzdxcrak8.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzdxcrak8.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpzdxcrak8.jl:29\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"()\", \"())\"\
    , \"()\", \"()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlin"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 0
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    open_parens = 0\n    paren_groups = []\n    current_group = \"\"\n   \
    \ for c in paren_string\n        if c == '('\n            open_parens += 1\n \
    \           current_group = current_group * c\n        elseif c == ')'\n     \
    \       open_parens -= 1\n            current_group = current_group * c\n    \
    \        if open_parens == 0\n                push!(paren_groups, current_group)\n\
    \                current_group = \"\"\n            end\n        end\n    end\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    4      4

    '
  stdout: ''
  timestamp: 1659795073
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc5rkniem.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpc5rkniem.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test Failed at /tmp/tmpc5rkniem.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    open_parens = 0\n    close_parens = 0\n    paren_groups\
    \ = []\n    temp_string = \"\"\n    for i in 1:length(paren_string)\n        if\
    \ paren_string[i] == '('\n            open_parens += 1\n        elseif paren_string[i]\
    \ == ')'\n            close_parens += 1\n        end\n        if open_parens ==\
    \ close_parens\n            push!(paren_groups, temp_string)\n            temp_string\
    \ = \"\"\n            open_parens = 0\n            close_parens = 0\n        else\n\
    \            temp_string = temp_string * paren_string[i]\n        end\n    end\n\
    \    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpovqxyj5j.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpovqxyj5j.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"\", \"((())\", \"\", \"(\", \"\", \"((())()()\"\
    ] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpovqxyj5j.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpovqxyj5j.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpovqxyj5j.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"\"\
    , \"(()\", \"\", \"((())\", \"\", \"(((()))\"] == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpovqxyj5j.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpovqxyj5j.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpovqxyj5j.jl:38\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()(())((()))\"] == [\"(()(())((())))\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpovqxyj5j.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpovqxyj5j.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpovqxyj5j.jl:39\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"( \", \"\", \"(( )\"\
    , \"\", \"(( )( )\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpovqxyj5j.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.c"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_string\
    \ = replace(paren_string, \")(\" => \") (\")\n    paren_string = split(paren_string,\
    \ \" \")\n    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbcvxy8xj.jl:16

    '
  stdout: "test set: Test Failed at /tmp/tmpbcvxy8xj.jl:19\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbcvxy8xj.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbcvxy8xj.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpbcvxy8xj.jl:21\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(())\", \"((())))\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbcvxy8xj.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbcvxy8xj.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpbcvxy8xj.jl:22\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(())\", \"\
    (()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbcvxy8xj.jl:22 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbcvxy8xj.jl:18\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_groups\
    \ = []\n    paren_group = \"\"\n    open_parens = 0\n    for i in 1:length(paren_string)\n\
    \        if paren_string[i] == '('\n            open_parens += 1\n        elseif\
    \ paren_string[i] == ')'\n            open_parens -= 1\n        end\n        if\
    \ open_parens == 0\n            push!(paren_groups, paren_group)\n           \
    \ paren_group = \"\"\n        else\n            paren_group = string(paren_group,\
    \ paren_string[i])\n        end\n    end\n    return paren_groups\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpumvb_b3g.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpumvb_b3g.jl:33\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()()\", \"((())\", \"(\", \"((())()()\"] == [\"(()())\",\
    \ \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpumvb_b3g.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpumvb_b3g.jl:32\ntest set: Test Failed at /tmp/tmpumvb_b3g.jl:34\n\
    \  Expression: candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"\
    ((()))\", \"(((())))\"]\n   Evaluated: [\"(\", \"(()\", \"((())\", \"(((()))\"\
    ] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpumvb_b3g.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpumvb_b3g.jl:32\ntest set: Test Failed at /tmp/tmpumvb_b3g.jl:35\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ [\"(()(())((()))\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpumvb_b3g.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpumvb_b3g.jl:32\ntest set: Test Failed at /tmp/tmpumvb_b3g.jl:36\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"(\", \"(()\", \"(()()\"] == [\"()\", \"(())\", \"(()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpumvb_b3g.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdli"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return [\"()\", \"(())\", \"(()())\"]\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpcgl6uzvr.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpcgl6uzvr.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcgl6uzvr.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcgl6uzvr.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpcgl6uzvr.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(())\"\
    , \"(()())\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcgl6uzvr.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcgl6uzvr.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpcgl6uzvr.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcgl6uzvr.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcgl6uzvr.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return Vector{String}()\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpz8nstk1f.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpz8nstk1f.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz8nstk1f.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz8nstk1f.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpz8nstk1f.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz8nstk1f.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpz8nstk1f.jl:16\ntest set: Test Failed at /tmp/tmpz8nstk1f.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz8nstk1f.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz8nstk1f.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpz8nstk1f.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz8nstk1f.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, r\"\\s+\",\
    \ \"\")\n    paren_groups = []\n    paren_group = \"\"\n    open_parens = 0\n\
    \    for c in paren_string\n        if c == '('\n            open_parens += 1\n\
    \        elseif c == ')'\n            open_parens -= 1\n        end\n        paren_group\
    \ *= c\n        if open_parens == 0\n            push!(paren_groups, paren_group)\n\
    \            paren_group = \"\"\n        end\n    end\n    return paren_groups\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp51fpaye3.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmp51fpaye3.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: no method matching replace(::String,\
    \ ::Regex, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp51fpaye3.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp51fpaye3.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp51fpaye3.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp51fpaye3.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: no method matching replace(::String, ::Regex, ::String)\n\
    \  Closest candidates are:\n    replace(!Matched::Union{Function, Type}, ::Any;\
    \ count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n    replace(::String,\
    \ !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp51fpaye3.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp51fpaye3.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    groups = []\n\
    \    start = 1\n    for i in 1:length(paren_string)\n        if paren_string[i]\
    \ == ')'\n            push!(groups, paren_string[start:i])\n            start\
    \ = i + 1\n        end\n    end\n    return groups\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjik_vjwq.jl:22

    '
  stdout: "test set: Test Failed at /tmp/tmpjik_vjwq.jl:25\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"()\", \")\", \"((()\", \")\", \")\", \"()\", \"((()\"\
    , \")\", \"()\", \"()\", \")\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjik_vjwq.jl:25 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjik_vjwq.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpjik_vjwq.jl:26\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(()\"\
    , \")\", \"((()\", \")\", \")\", \"(((()\", \")\", \")\", \")\"] == [\"()\", \"\
    (())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjik_vjwq.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjik_vjwq.jl:24\ntest set: Test\
    \ Failed at /tmp/tmpjik_vjwq.jl:27\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(()\", \")\", \"((()\", \"\
    )\", \")\", \")\"] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpjik_vjwq.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpjik_vjwq.jl:24\ntest set: Test Failed at /tmp/tmpjik_vjwq.jl:28\n\
    \  Expression: candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ]\n   Evaluated: [\"()\", \"(()\", \")\", \"(()\", \"()\", \")\"] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    return split(paren_string,\
    \ \" \")\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsa_lm5v5.jl:16

    '
  stdout: "test set: Test Failed at /tmp/tmpsa_lm5v5.jl:19\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsa_lm5v5.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsa_lm5v5.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpsa_lm5v5.jl:21\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(())\", \"((())))\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpsa_lm5v5.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpsa_lm5v5.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpsa_lm5v5.jl:22\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(())\", \"\
    (()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsa_lm5v5.jl:22 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpsa_lm5v5.jl:18\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpu8f25scm.jl:17

    '
  stdout: "test set: Test Failed at /tmp/tmpu8f25scm.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpu8f25scm.jl:22\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(())\", \"((())))\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpu8f25scm.jl:23\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(())\", \"\
    (()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:23 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    open_parens =\
    \ 0\n    start_index = 0\n    end_index = 0\n    groups = []\n    for (i, paren)\
    \ in enumerate(paren_string)\n        if paren == \"(\"\n            open_parens\
    \ += 1\n            if open_parens == 1\n                start_index = i\n   \
    \         end\n        elseif paren == \")\"\n            open_parens -= 1\n \
    \           if open_parens == 0\n                end_index = i\n             \
    \   push!(groups, paren_string[start_index:end_index])\n            end\n    \
    \    end\n    end\n    return groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp4fpih698.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmp4fpih698.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpih698.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4fpih698.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp4fpih698.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp4fpih698.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp4fpih698.jl:34\ntest set: Test Failed at /tmp/tmp4fpih698.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpih698.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4fpih698.jl:34\ntest set: Test\
    \ Failed at /tmp/tmp4fpih698.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp4fpih698.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp4"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    open_paren = 0\n    close_paren = 0\n    paren_groups\
    \ = []\n    temp_string = \"\"\n    for i in paren_string\n        if i == \"\
    (\"\n            open_paren += 1\n            temp_string = temp_string * i\n\
    \        elseif i == \")\"\n            close_paren += 1\n            temp_string\
    \ = temp_string * i\n        end\n        if open_paren == close_paren && open_paren\
    \ != 0\n            push!(paren_groups, temp_string)\n            temp_string\
    \ = \"\"\n            open_paren = 0\n            close_paren = 0\n        end\n\
    \    end\n    return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7tcpl0ne.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmp7tcpl0ne.jl:36\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7tcpl0ne.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7tcpl0ne.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp7tcpl0ne.jl:37\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7tcpl0ne.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7tcpl0ne.jl:35\ntest set: Test Failed at /tmp/tmp7tcpl0ne.jl:38\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7tcpl0ne.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7tcpl0ne.jl:35\ntest set: Test\
    \ Failed at /tmp/tmp7tcpl0ne.jl:39\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp7tcpl0ne.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp7"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    # Hint: You may want to use the `split` function\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmprpe2nk0r.jl:14

    '
  stdout: "test set: Error During Test at /tmp/tmprpe2nk0r.jl:17\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprpe2nk0r.jl:11\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmprpe2nk0r.jl:17 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmprpe2nk0r.jl:16\ntest set:\
    \ Error During Test at /tmp/tmprpe2nk0r.jl:18\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmprpe2nk0r.jl:11\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return Vector{String}()\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqd99z1ic.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpqd99z1ic.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqd99z1ic.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqd99z1ic.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpqd99z1ic.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqd99z1ic.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqd99z1ic.jl:16\ntest set: Test Failed at /tmp/tmpqd99z1ic.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqd99z1ic.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqd99z1ic.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpqd99z1ic.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqd99z1ic.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpq"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc5rkniem.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpc5rkniem.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test Failed at /tmp/tmpc5rkniem.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: write your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpvok9_jof.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpvok9_jof.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpvok9_jof.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvok9_jof.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvok9_jof.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpvok9_jof.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpvok9_jof.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795077
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: your code here\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp_chima2t.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmp_chima2t.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp_chima2t.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_chima2t.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_chima2t.jl:15\ntest set:\
    \ Error During Test at /tmp/tmp_chima2t.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp_chima2t.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpu8f25scm.jl:17

    '
  stdout: "test set: Test Failed at /tmp/tmpu8f25scm.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpu8f25scm.jl:22\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(())\", \"((())))\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpu8f25scm.jl:23\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(())\", \"\
    (()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:23 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    # You can use the following function to check if\
    \ a string is balanced\n    # is_balanced(paren_string::String)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()())\
    \ ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\
    \t@test(candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\"\
    , \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"\
    ])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"\
    ])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmp80n8nt05.jl:15

    '
  stdout: "test set: Error During Test at /tmp/tmp80n8nt05.jl:18\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp80n8nt05.jl:12\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp80n8nt05.jl:18 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp80n8nt05.jl:17\ntest set:\
    \ Error During Test at /tmp/tmp80n8nt05.jl:19\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmp80n8nt05.jl:12\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    # Hint: You may want to use the split\
    \ function\n    # Hint: You may want to use the strip function\n    # Hint: You\
    \ may want to use the join function\n    # Hint: You may want to use the push!\
    \ function\n    # Hint: You may want to use the isempty function\n    # Hint:\
    \ You may want to use the ismatching function\n    # Hint: You may want to use\
    \ the isbalanced function\n    # Hint: You may want to use the isopen function\n\
    \    # Hint: You may want to use the isclose function\n    # Hint: You may want\
    \ to use the pop! function\n    # Hint: You may want to use the push! function\n\
    \    # Hint: You may want to use the append! function\n    # Hint: You may want\
    \ to use the length function\n    # Hint: You may want to use the getindex function\n\
    \    # Hint: You may want to use the contains function\n    # Hint: You may want\
    \ to use the findfirst function\n    # Hint: You may want to use the findnext\
    \ function\n    # Hint: You may want to use the findlast function\n    # Hint:\
    \ You may want to use the findprev function\n    # Hint: You may want to use the\
    \ findnext function\n    # Hint: You may want to use the findlast function\n \
    \   # Hint: You may want to use the findprev function\n    # Hint: You may want\
    \ to use the findnext function\n    # Hint: You may want to use the findlast function\n\
    \    # Hint: You may want to use the findprev function\n    # Hint: You may want\
    \ to use the findnext function\n    # Hint: You may want to use the findlast function\n\
    \    # Hint: You may want to use the findprev function\n    # Hint: You may want\
    \ to use the findnext function\n    # Hint: You may want to use the findlast function\n\
    \    # Hint: You may want to use the findprev function\n    # Hint: You may want\
    \ to use the findnext function\n    # Hint: You may want to use the findlast function\n\
    \    # Hint: You may want to use the\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: \"function\" at /tmp/tmpai10si6g.jl:8\
    \ requires end\nStacktrace:\n [1] top-level scope\n   @ /tmp/tmpai10si6g.jl:1\n\
    in expression starting at /tmp/tmpai10si6g.jl:1\n"
  stdout: ''
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: write your code here\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpz7qy9_ns.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpz7qy9_ns.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz7qy9_ns.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz7qy9_ns.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpz7qy9_ns.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz7qy9_ns.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpz7qy9_ns.jl:16\ntest set: Test Failed at /tmp/tmpz7qy9_ns.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz7qy9_ns.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz7qy9_ns.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpz7qy9_ns.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz7qy9_ns.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    paren_string = replace(paren_string, \" \" => \"\
    \")\n    paren_string = replace(paren_string, \")(\" => \") (\")\n    paren_string\
    \ = split(paren_string, \" \")\n    return paren_string\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpu8f25scm.jl:17

    '
  stdout: "test set: Test Failed at /tmp/tmpu8f25scm.jl:20\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpu8f25scm.jl:22\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(())\", \"((())))\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:22 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\ntest set: Test\
    \ Failed at /tmp/tmpu8f25scm.jl:23\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(())\", \"\
    (()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpu8f25scm.jl:23 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpu8f25scm.jl:19\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    # Hint: use a stack\n    stack = []\n    result\
    \ = []\n    for i in paren_string\n        if i == '('\n            push!(stack,\
    \ i)\n        elseif i == ')'\n            if length(stack) == 0\n           \
    \     return \"Invalid\"\n            else\n                pop!(stack)\n    \
    \        end\n        end\n    end\n    if length(stack) == 0\n        return\
    \ result\n    else\n        return \"Invalid\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxbw8klsr.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpxbw8klsr.jl:35\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxbw8klsr.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxbw8klsr.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpxbw8klsr.jl:36\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxbw8klsr.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxbw8klsr.jl:34\ntest set: Test Failed at /tmp/tmpxbw8klsr.jl:37\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxbw8klsr.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxbw8klsr.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpxbw8klsr.jl:38\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxbw8klsr.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpx"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return [\"()\", \"(())\", \"(()())\"\
    ]\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\t\
    @test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphraa95gd.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmphraa95gd.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"(()())\", \"((()))\", \"\
    ()\", \"((())()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphraa95gd.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphraa95gd.jl:16\ntest set: Test\
    \ Failed at /tmp/tmphraa95gd.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: [\"()\", \"(())\"\
    , \"(()())\"] == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphraa95gd.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphraa95gd.jl:16\ntest set: Test\
    \ Failed at /tmp/tmphraa95gd.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"()\", \"(())\", \"(()())\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphraa95gd.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphraa95gd.jl:16\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795077
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc5rkniem.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpc5rkniem.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test Failed at /tmp/tmpc5rkniem.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpr7balxtl.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpr7balxtl.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpr7balxtl.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpr7balxtl.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpr7balxtl.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpr7balxtl.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Write your code here\n    return []\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0g5qpqyg.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp0g5qpqyg.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0g5qpqyg.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0g5qpqyg.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp0g5qpqyg.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0g5qpqyg.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0g5qpqyg.jl:16\ntest set: Test Failed at /tmp/tmp0g5qpqyg.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0g5qpqyg.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0g5qpqyg.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp0g5qpqyg.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0g5qpqyg.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0"
  timestamp: 1659795077
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    paren_string = replace(paren_string, \" \" => \"\")\n    paren_string\
    \ = replace(paren_string, \")(\" => \") (\")\n    paren_string = split(paren_string,\
    \ \" \")\n    return paren_string\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbcvxy8xj.jl:16

    '
  stdout: "test set: Test Failed at /tmp/tmpbcvxy8xj.jl:19\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: [\"(()\", \"())\", \"((()))\", \"()\", \"((())\", \"()\", \"\
    ())\"] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbcvxy8xj.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbcvxy8xj.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpbcvxy8xj.jl:21\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: [\"(()\", \"(())\", \"((())))\"] == [\"\
    (()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbcvxy8xj.jl:21 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbcvxy8xj.jl:18\ntest set: Test\
    \ Failed at /tmp/tmpbcvxy8xj.jl:22\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: [\"()\", \"(())\", \"\
    (()\", \"())\"] == [\"()\", \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpbcvxy8xj.jl:22 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpbcvxy8xj.jl:18\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    1     3      4\n"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    \"\"\"\n    >>> separate_paren_groups(\"( ) (( )) (( )( ))\")\n    [\"\
    ()\", \"(())\", \"(()())\"]\n    \"\"\"\n    # initialize a vector of strings\n\
    \    paren_groups = Vector{String}()\n    # initialize a string to hold the current\
    \ group\n    current_group = \"\"\n    # initialize a counter to keep track of\
    \ the number of open parentheses\n    open_paren_count = 0\n    # loop through\
    \ the characters in the string\n    for c in paren_string\n        # if the character\
    \ is a space, skip it\n        if c == ' '\n            continue\n        # if\
    \ the character is an open parenthesis, add it to the current group and increment\
    \ the counter\n        if c == '('\n            current_group *= c\n         \
    \   open_paren_count += 1\n        # if the character is a closed parenthesis,\
    \ add it to the current group and decrement the counter\n        if c == ')'\n\
    \            current_group *= c\n            open_paren_count -= 1\n        #\
    \ if the counter is zero, push the current group to the vector and reset the current\
    \ group\n        if open_paren_count == 0\n            push!(paren_groups, current_group)\n\
    \            current_group = \"\"\n    # return the vector of paren groups\n \
    \   return paren_groups\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmplano6nq3.jl:1\nin expression starting at /tmp/tmplano6nq3.jl:1\n"
  stdout: ''
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: Implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpjgru_nwk.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpjgru_nwk.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpjgru_nwk.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpjgru_nwk.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpjgru_nwk.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc5rkniem.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpc5rkniem.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test Failed at /tmp/tmpc5rkniem.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # TODO: implement this function\n    return []\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((()))\
    \ () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"\
    () (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8b_i7w1c.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmp8b_i7w1c.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8b_i7w1c.jl:16\ntest set: Test\
    \ Failed at /tmp/tmp8b_i7w1c.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8b_i7w1c.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb2yfma5v.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpb2yfma5v.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb2yfma5v.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpb2yfma5v.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb2yfma5v.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpadrofh71.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpadrofh71.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpadrofh71.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpadrofh71.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpadrofh71.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at ~/.conda/envs/polyglot/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpadrofh71.jl:10\n   [2] macro expansion\n     @ ~/.cond"
  timestamp: 1659795076
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # Your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpc5rkniem.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpc5rkniem.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:18 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test Failed at /tmp/tmpc5rkniem.jl:19\n\
    \  Expression: candidate(\"(()(())((())))\") == [\"(()(())((())))\"]\n   Evaluated:\
    \ String[] == [\"(()(())((())))\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc5rkniem.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpc5rkniem.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpc5rkniem.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpc"
  timestamp: 1659795075
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\n    return []\nend\nusing Test\n\n@testset begin\n\n\
    candidate = separate_paren_groups;\n\t@test(candidate(\"(()()) ((())) () ((())()())\"\
    ) == [\"(()())\", \"((()))\", \"()\", \"((())()())\"])\n\t@test(candidate(\"()\
    \ (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t\
    @test(candidate(\"(()(())((())))\") == [\"(()(())((())))\"])\n\t@test(candidate(\"\
    ( ) (( )) (( )( ))\") == [\"()\", \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkrv9ggo2.jl:14

    '
  stdout: "test set: Test Failed at /tmp/tmpkrv9ggo2.jl:17\n  Expression: candidate(\"\
    (()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]\n   Evaluated: String[] == [\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n\
    Stacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:17 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:18\n  Expression: candidate(\"() (()) ((())) (((())))\"\
    ) == [\"()\", \"(())\", \"((()))\", \"(((())))\"]\n   Evaluated: String[] == [\"\
    ()\", \"(())\", \"((()))\", \"(((())))\"]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:18 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:19\n  Expression: candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"]\n   Evaluated: String[] == [\"(()(())((())))\"]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:19 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkrv9ggo2.jl:16\ntest set: Test\
    \ Failed at /tmp/tmpkrv9ggo2.jl:20\n  Expression: candidate(\"( ) (( )) (( )(\
    \ ))\") == [\"()\", \"(())\", \"(()())\"]\n   Evaluated: String[] == [\"()\",\
    \ \"(())\", \"(()())\"]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkrv9ggo2.jl:20 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inli"
- exit_code: 1
  program: "\"\"\" Input to this function is a string containing multiple groups of\
    \ nested parentheses. Your goal is to\n    separate those group into separate\
    \ strings and return the list of those.\n    Separate groups are balanced (each\
    \ open brace is properly closed) and not nested within each other\n    Ignore\
    \ any spaces in the input string.\n    >>> separate_paren_groups(\"( ) (( )) ((\
    \ )( ))\")\n    [\"()\", \"(())\", \"(()())\"]\n    \"\"\"\nfunction separate_paren_groups(paren_string::String)::Vector{String}\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = separate_paren_groups;\n\
    \t@test(candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"])\n\t@test(candidate(\"() (()) ((())) (((())))\") ==\
    \ [\"()\", \"(())\", \"((()))\", \"(((())))\"])\n\t@test(candidate(\"(()(())((())))\"\
    ) == [\"(()(())((())))\"])\n\t@test(candidate(\"( ) (( )) (( )( ))\") == [\"()\"\
    , \"(())\", \"(()())\"])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 4 errored,
    0 broken.

    in expression starting at /tmp/tmpag75fn_d.jl:13

    '
  stdout: "test set: Error During Test at /tmp/tmpag75fn_d.jl:16\n  Test threw exception\n\
    \  Expression: candidate(\"(()()) ((())) () ((())()())\") == [\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]\n  MethodError: Cannot `convert` an object of type Nothing\
    \ to an object of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T},\
    \ !Matched::LinearAlgebra.Factorization) where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:10\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpag75fn_d.jl:16 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpag75fn_d.jl:15\ntest set:\
    \ Error During Test at /tmp/tmpag75fn_d.jl:17\n  Test threw exception\n  Expression:\
    \ candidate(\"() (()) ((())) (((())))\") == [\"()\", \"(())\", \"((()))\", \"\
    (((())))\"]\n  MethodError: Cannot `convert` an object of type Nothing to an object\
    \ of type Vector{String}\n  Closest candidates are:\n    convert(::Type{T}, !Matched::LinearAlgebra.Factorization)\
    \ where T<:AbstractArray at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LinearAlgebra/src/factorization.jl:58\n\
    \    convert(::Type{Vector{String}}, !Matched::LibGit2.StrArrayStruct) at /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/LibGit2/src/strarray.jl:13\n\
    \    convert(::Type{T}, !Matched::AbstractArray) where T<:Array at /shared/centos7/julia/1.7.3/share/julia/base/array.jl:554\n\
    \    ...\n  Stacktrace:\n   [1] separate_paren_groups(paren_string::String)\n\
    \     @ Main /tmp/tmpag75fn_d.jl:"
