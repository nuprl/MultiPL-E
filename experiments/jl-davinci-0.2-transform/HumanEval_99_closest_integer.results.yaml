language: jl
name: HumanEval_99_closest_integer
results:
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmy171oe4.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpmy171oe4.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmy171oe4.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmy171oe4.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf9dq64ps.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpf9dq64ps.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf9dq64ps.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9dq64ps.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num > 0\n        return round(Int64,\
    \ num)\n    else\n        return round(Int64, num - 1)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5qui7mt4.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp5qui7mt4.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5qui7mt4.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5qui7mt4.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp5qui7mt4.jl:35\n  Expression: candidate(\"0\") == 0\n   Evaluated:\
    \ -1 == 0\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5qui7mt4.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5qui7mt4.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 0
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return ceil(value)\n        else\n          \
    \  return floor(value)\n        end\n    else\n        return round(value)\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    5      5

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxz6enmdb.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpxz6enmdb.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxz6enmdb.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxz6enmdb.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # Convert the string to a float\n    value = parse(Float64, value)\n \
    \   # Round the float to the nearest integer\n    value = round(value)\n    #\
    \ Convert the float to an integer\n    value = Int64(value)\n    # Return the\
    \ integer\n    return value\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkyaglom1.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpkyaglom1.jl:34\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkyaglom1.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkyaglom1.jl:32\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsgii8uvy.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpsgii8uvy.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsgii8uvy.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpsgii8uvy.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfds47pxw.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpfds47pxw.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfds47pxw.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfds47pxw.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf9dq64ps.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpf9dq64ps.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf9dq64ps.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9dq64ps.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # Convert the string to a float\n    value = parse(Float64, value)\n \
    \   # Round the float to an integer\n    value = round(value)\n    # Convert the\
    \ float to an integer\n    value = Int64(value)\n    # Return the integer\n  \
    \  return value\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpg7r62tio.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpg7r62tio.jl:34\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpg7r62tio.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpg7r62tio.jl:32\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return floor(num)\n\
    \    else\n        return ceil(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93hab0es.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93hab0es.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93hab0es.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp93hab0es.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return floor(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwhb3rj2w.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpwhb3rj2w.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwhb3rj2w.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwhb3rj2w.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == round(value)\n        return\
    \ round(value)\n    elseif value > 0\n        return round(value) + 1\n    else\n\
    \        return round(value) - 1\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9bep7dwi.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmp9bep7dwi.jl:35\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -17 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9bep7dwi.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9bep7dwi.jl:32\ntest set: Test Failed at /tmp/tmp9bep7dwi.jl:36\n\
    \  Expression: candidate(\"15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9bep7dwi.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9bep7dwi.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  timestamp: 1659805226
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    \"\"\"\n    Convert the string to a float and round it to the nearest\
    \ integer.\n    \"\"\"\n    value = parse(Float64, value)\n    return round(Int64,\
    \ value)\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmppwbs61sg.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmppwbs61sg.jl:31\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmppwbs61sg.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmppwbs61sg.jl:29\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return floor(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwhb3rj2w.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpwhb3rj2w.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwhb3rj2w.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwhb3rj2w.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsgii8uvy.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpsgii8uvy.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsgii8uvy.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpsgii8uvy.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf9dq64ps.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpf9dq64ps.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf9dq64ps.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9dq64ps.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxz6enmdb.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpxz6enmdb.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxz6enmdb.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxz6enmdb.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    if value == \"10\"\n        return 10\n    elseif value == \"15.3\"\n\
    \        return 15\n    else\n        return 0\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp6pjohp90.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmp6pjohp90.jl:33\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 0 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp6pjohp90.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp6pjohp90.jl:31\ntest set: Test Failed at /tmp/tmp6pjohp90.jl:34\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: 0 == -16\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp6pjohp90.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp6pjohp90.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyco1ms5n.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpyco1ms5n.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyco1ms5n.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyco1ms5n.jl:32\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return floor(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwhb3rj2w.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpwhb3rj2w.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwhb3rj2w.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwhb3rj2w.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    value = round(value)\n    return value\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp_95adkeg.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmp_95adkeg.jl:29\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp_95adkeg.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp_95adkeg.jl:27\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxz6enmdb.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpxz6enmdb.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxz6enmdb.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxz6enmdb.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      return ceil(value)\n    else\n        return round(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpizj4s04z.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpizj4s04z.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpizj4s04z.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpizj4s04z.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp65cwu53l.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp65cwu53l.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp65cwu53l.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp65cwu53l.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmy171oe4.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpmy171oe4.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmy171oe4.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmy171oe4.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return round(value\
    \ - 0.5)\n    else\n        return round(value + 0.5)\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpz1yjzjnd.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpz1yjzjnd.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz1yjzjnd.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpz1yjzjnd.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return trunc(num)\
    \ - 1\n    else\n        return trunc(num)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp7duuoipj.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp7duuoipj.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp7duuoipj.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp7duuoipj.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value == trunc(value)\n        return\
    \ trunc(value)\n    elseif value > trunc(value)\n        return trunc(value) +\
    \ 1\n    else\n        return trunc(value) - 1\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmy171oe4.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpmy171oe4.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmy171oe4.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmy171oe4.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 0
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return ceil(value)\n        else\n          \
    \  return floor(value)\n        end\n    else\n        return round(value)\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    5      5

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    return round(Int64, value)\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpsgii8uvy.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpsgii8uvy.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpsgii8uvy.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpsgii8uvy.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyco1ms5n.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpyco1ms5n.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyco1ms5n.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyco1ms5n.jl:32\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num < 0\n        return floor(num)\n\
    \    else\n        return ceil(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93hab0es.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93hab0es.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93hab0es.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp93hab0es.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) >= 0.5\n  \
    \      return ceil(value)\n    else\n        return floor(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwhb3rj2w.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpwhb3rj2w.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwhb3rj2w.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwhb3rj2w.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwp92c4t_.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpwp92c4t_.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwp92c4t_.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpwp92c4t_.jl:30\ntest set: Test Failed at /tmp/tmpwp92c4t_.jl:33\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwp92c4t_.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwp92c4t_.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 0
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return trunc(Int64,\
    \ value - 0.5)\n    else\n        return trunc(Int64, value + 0.5)\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    5      5

    '
  stdout: ''
  timestamp: 1659805224
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 0.5)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9m1hl0yz.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp9m1hl0yz.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9m1hl0yz.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9m1hl0yz.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    # Convert the string to a float\n    value = parse(Float64, value)\n \
    \   # Round the float to the nearest integer\n    value = round(value)\n    #\
    \ Convert the float to an integer\n    value = parse(Int64, value)\n    # Return\
    \ the integer\n    return value\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 5 errored,
    0 broken.

    in expression starting at /tmp/tmp_e6smtj8.jl:30

    '
  stdout: "test set: Error During Test at /tmp/tmp_e6smtj8.jl:33\n  Test threw exception\n\
    \  Expression: candidate(\"10\") == 10\n  MethodError: no method matching parse(::Type{Int64},\
    \ ::Float64)\n  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar;\
    \ base) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/parse.jl:40\n\
    \    parse(::Type{T}, !Matched::AbstractString; base) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/parse.jl:240\n\
    \    parse(::Type{T}, !Matched::AbstractString; kwargs...) where T<:Real at ~/.conda/envs/polyglot/share/julia/base/parse.jl:379\n\
    \  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmp_e6smtj8.jl:24\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_e6smtj8.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_e6smtj8.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp_e6smtj8.jl:34\n  Test threw exception\n  Expression:\
    \ candidate(\"14.5\") == 15\n  MethodError: no method matching parse(::Type{Int64},\
    \ ::Float64)\n  Closest candidates are:\n    parse(::Type{T}, !Matched::AbstractChar;\
    \ base) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/parse.jl:40\n\
    \    parse(::Type{T}, !Matched::AbstractString; base) where T<:Integer at ~/.conda/envs/polyglot/share/julia/base/parse.jl:240\n\
    \    parse(::Type{T}, !Matched::AbstractString; kwargs...) where T<:Real at ~/.conda/envs/polyglot/share/julia/base/parse.jl:379\n\
    \  Stacktrace:\n   [1] closest_integer(value::String)\n     @ Main /tmp/tmp_e6smtj8.jl:24\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_e6smtj8.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_e6smtj8.jl:32\ntest set:\
    \ Error During Test at /tmp/tmp_e6"
  timestamp: 1659805227
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfds47pxw.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpfds47pxw.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfds47pxw.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfds47pxw.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    elseif value < 0\n        return floor(value)\n    else\n        return 0\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyco1ms5n.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpyco1ms5n.jl:36\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyco1ms5n.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyco1ms5n.jl:32\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return round(Int64,\
    \ value)\n    elseif value < 0\n        return round(Int64, value)\n    else\n\
    \        return 0\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\
    \t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkzepe1sk.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmpkzepe1sk.jl:34\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkzepe1sk.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkzepe1sk.jl:32\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxz6enmdb.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpxz6enmdb.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxz6enmdb.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxz6enmdb.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp65cwu53l.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp65cwu53l.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp65cwu53l.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp65cwu53l.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp65cwu53l.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp65cwu53l.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp65cwu53l.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp65cwu53l.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf9dq64ps.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpf9dq64ps.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf9dq64ps.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9dq64ps.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    if num > 0\n        return ceil(num)\n\
    \    else\n        return floor(num)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5xj0_4ab.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp5xj0_4ab.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5xj0_4ab.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5xj0_4ab.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - trunc(value) < 0.5\n   \
    \     return trunc(value)\n    else\n        return trunc(value) + 1\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1t9l3flp.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp1t9l3flp.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1t9l3flp.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1t9l3flp.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return Int64(round(parse(Float64, value)))\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpf9dq64ps.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpf9dq64ps.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpf9dq64ps.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpf9dq64ps.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 0
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) == 0.5\n  \
    \      if value > 0\n            return ceil(value)\n        else\n          \
    \  return floor(value)\n        end\n    else\n        return round(value)\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t\
    @test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"\
    -15.5\") == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\"\
    ) == 0)\nend\n"
  status: OK
  stderr: 'Test Summary: | Pass  Total

    test set      |    5      5

    '
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    number = parse(Float64, value)\n    return round(number)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") ==\
    \ 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\
    \t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmprywsgt47.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmprywsgt47.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmprywsgt47.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmprywsgt47.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805226
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    num = parse(Float64, value)\n    return round(num)\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\
    \t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxz6enmdb.jl:24

    '
  stdout: "test set: Test Failed at /tmp/tmpxz6enmdb.jl:28\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxz6enmdb.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxz6enmdb.jl:26\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value >= 0\n        return round(Int64,\
    \ value)\n    else\n        return round(Int64, value - 1)\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfds47pxw.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpfds47pxw.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfds47pxw.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfds47pxw.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805225
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return round(parse(Float64, value))\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqc8sxjqy.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpqc8sxjqy.jl:27\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqc8sxjqy.jl:27 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqc8sxjqy.jl:25\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr1cmeppu.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpr1cmeppu.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpr1cmeppu.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpr1cmeppu.jl:30\ntest set: Test Failed at /tmp/tmpr1cmeppu.jl:33\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr1cmeppu.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr1cmeppu.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  timestamp: 1659805227
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr1cmeppu.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpr1cmeppu.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpr1cmeppu.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpr1cmeppu.jl:30\ntest set: Test Failed at /tmp/tmpr1cmeppu.jl:33\n\
    \  Expression: candidate(\"-15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr1cmeppu.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr1cmeppu.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    3     2      5\n"
  timestamp: 1659805227
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value - floor(value) < 0.5\n   \
    \     return floor(value)\n    else\n        return ceil(value)\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"\
    10\") == 10)\n\t@test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\"\
    ) == -16)\n\t@test(candidate(\"15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpeb5gponq.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpeb5gponq.jl:33\n  Expression: candidate(\"\
    -15.5\") == -16\n   Evaluated: -15 == -16\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpeb5gponq.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpeb5gponq.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value < 0\n        return floor(value)\n\
    \    else\n        return ceil(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp93u2x1oh.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp93u2x1oh.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp93u2x1oh.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp93u2x1oh.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return round(value)\n\
    \    else\n        return round(value - 0.5)\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t\
    @test(candidate(\"14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"\
    15.3\") == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpe848ik4c.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpe848ik4c.jl:32\n  Expression: candidate(\"\
    14.5\") == 15\n   Evaluated: 14 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpe848ik4c.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpe848ik4c.jl:30\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    4     1      5\n"
  timestamp: 1659805227
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    return parse(Int64, value)\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"14.5\"\
    ) == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\") ==\
    \ 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 0 failed, 3 errored,
    0 broken.

    in expression starting at /tmp/tmpt395n0tn.jl:23

    '
  stdout: "test set: Error During Test at /tmp/tmpt395n0tn.jl:27\n  Test threw exception\n\
    \  Expression: candidate(\"14.5\") == 15\n  ArgumentError: invalid base 10 digit\
    \ '.' in \"14.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64},\
    \ s::String, startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n    \
    \ @ Base ./parse.jl:137\n   [2] parse(::Type{Int64}, s::String; base::Nothing)\n\
    \     @ Base ./parse.jl:241\n   [3] parse\n     @ ./parse.jl:241 [inlined]\n \
    \  [4] closest_integer(value::String)\n     @ Main /tmp/tmpt395n0tn.jl:19\n  \
    \ [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:27 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:28\n  Test threw exception\n  Expression:\
    \ candidate(\"-15.5\") == -16\n  ArgumentError: invalid base 10 digit '.' in \"\
    -15.5\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ Base ./parse.jl:137\n\
    \   [2] parse(::Type{Int64}, s::String; base::Nothing)\n     @ Base ./parse.jl:241\n\
    \   [3] parse\n     @ ./parse.jl:241 [inlined]\n   [4] closest_integer(value::String)\n\
    \     @ Main /tmp/tmpt395n0tn.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt395n0tn.jl:28 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt395n0tn.jl:25\ntest set:\
    \ Error During Test at /tmp/tmpt395n0tn.jl:29\n  Test threw exception\n  Expression:\
    \ candidate(\"15.3\") == 15\n  ArgumentError: invalid base 10 digit '.' in \"\
    15.3\"\n  Stacktrace:\n   [1] tryparse_internal(#unused#::Type{Int64}, s::String,\
    \ startpos::Int64, endpos::Int64, base_::Int64, raise::Bool)\n     @ "
- exit_code: 1
  program: "\"\"\"\n    Create a function that takes a value (string) representing\
    \ a number\n    and returns the closest integer to it. If the number is equidistant\n\
    \    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"\
    10\")\n    10\n    >>> closest_integer(\"15.3\")\n    15\n\n    Note:\n    Rounding\
    \ away from zero means that if the given number is equidistant\n    from two integers,\
    \ the one you should return is the one that is the\n    farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"\
    -14.5\") should return -15.\n    \"\"\"\nfunction closest_integer(value::String)::Int64\
    \ \n    value = parse(Float64, value)\n    if value > 0\n        return ceil(value)\n\
    \    else\n        return floor(value)\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = closest_integer;\n\t@test(candidate(\"10\") == 10)\n\t@test(candidate(\"\
    14.5\") == 15)\n\t@test(candidate(\"-15.5\") == -16)\n\t@test(candidate(\"15.3\"\
    ) == 15)\n\t@test(candidate(\"0\") == 0)\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2htjf8sb.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp2htjf8sb.jl:34\n  Expression: candidate(\"\
    15.3\") == 15\n   Evaluated: 16 == 15\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2htjf8sb.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2htjf8sb.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    4     1      5\n"
