name: HumanEval_87_get_row
language: jl
prompt: "\"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which\
  \ is similar to matrix, however, unlike matrices,\n    each row may contain a different\
  \ number of columns.\n    Given lst, and integer x, find integers x in the list,\n\
  \    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple\
  \ is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially\
  \ by rows in ascending order.\n    Also, sort coordinates of the row by columns\
  \ in descending order.\n    \n    Examples:\n    >>> get_row([[1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\n    [(0, 0), (1, 4), (1, 0), (2,\
  \ 5), (2, 0)]\n    >>> get_row([], 1)\n    []\n    >>> get_row([[], [1], [1, 2,\
  \ 3]], 3)\n    [(2, 2)]\n    \"\"\"\nfunction get_row(lst::Vector{Vector{Int64}},\
  \ x::Int64)::Vector{Tuple{Int64, Int64}} \n"
tests: "using Test\n\n@testset begin\n\ncandidate = get_row;\n\t@test(candidate([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 4),\
  \ (1, 0), (2, 5), (2, 0)])\n\t@test(candidate([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
  \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
  \ 5, 6]], 2) == [(0, 1), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1)])\n\t@test(candidate([[1,\
  \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
  \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1) == [(0, 0), (1, 0),\
  \ (2, 1), (2, 0), (3, 2), (3, 0), (4, 3), (4, 0), (5, 4), (5, 0), (6, 5), (6, 0)])\n\
  \t@test(candidate(Vector{Vector{Int64}}([]), 1) == Vector{Tuple{Int64, Int64}}([]))\n\
  \t@test(candidate([[1]], 2) == Vector{Tuple{Int64, Int64}}([]))\n\t@test(candidate([[],\
  \ [1], [1, 2, 3]], 3) == [(2, 2)])\nend\n"
completions: ["    result = []\n    for (i, row) in enumerate(lst)\n        for (j,\
    \ elem) in enumerate(row)\n            if elem == x\n                push!(result,\
    \ (i, j))\n            end\n        end\n    end\n    sort!(result, by=x->x[1])\n\
    \    for i in 1:length(result)\n        sort!(result[i], by=x->x[2], rev=true)\n\
    \    end\n    return result\nend", "    # your code here\n    return []\nend",
  "    result = Tuple{Int64, Int64}[]\n    for (i, row) in enumerate(lst)\n      \
    \  for (j, item) in enumerate(row)\n            if item == x\n               \
    \ push!(result, (i, j))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        sort!(result[i], by=x->x[2],\
    \ rev=true)\n    end\n    return result\nend", "    row_col = []\n    for i in\
    \ 1:length(lst)\n        for j in 1:length(lst[i])\n            if lst[i][j] ==\
    \ x\n                push!(row_col, (i-1, j-1))\n            end\n        end\n\
    \    end\n    sort!(row_col, by = x -> x[1])\n    sort!(row_col, by = x -> x[2],\
    \ rev = true)\n    return row_col\nend", "    result = []\n    for i in 1:length(lst)\n\
    \        for j in 1:length(lst[i])\n            if lst[i][j] == x\n          \
    \      push!(result, (i-1, j-1))\n            end\n        end\n    end\n    sort!(result,\
    \ by=x->x[1])\n    for i in 1:length(result)\n        if i != 1 && result[i][1]\
    \ == result[i-1][1]\n            sort!(result[i-1:i], by=x->x[2], rev=true)\n\
    \        end\n    end\n    return result\nend", "    result = []\n    for i in\
    \ 1:length(lst)\n        for j in 1:length(lst[i])\n            if lst[i][j] ==\
    \ x\n                push!(result, (i-1, j-1))\n            end\n        end\n\
    \    end\n    sort!(result, by=x->x[1])\n    sort!(result, by=x->x[2], rev=true)\n\
    \    return result\nend", "    res = []\n    for i in 1:length(lst)\n        for\
    \ j in 1:length(lst[i])\n            if lst[i][j] == x\n                push!(res,\
    \ (i-1, j-1))\n            end\n        end\n    end\n    return sort(res, by=x->x[1])\n\
    end", "    result = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n\
    \            if lst[i][j] == x\n                push!(result, (i-1, j-1))\n  \
    \          end\n        end\n    end\n    sort!(result, by = x -> x[1])\n    sort!(result,\
    \ by = x -> x[2], rev = true)\n    return result\nend", "    result = []\n   \
    \ for i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if lst[i][j]\
    \ == x\n                push!(result, (i-1, j-1))\n            end\n        end\n\
    \    end\n    sort!(result, by = x -> x[1])\n    for i in 1:length(result)\n \
    \       sort!(result[i], by = x -> x[2], rev = true)\n    end\n    return result\n\
    end", "    # your code here\n    return []\nend", "    # your code here\n    return\
    \ []\nend", "    # your code here\n    return []\nend", "    res = []\n    for\
    \ i in 1:length(lst)\n        for j in 1:length(lst[i])\n            if lst[i][j]\
    \ == x\n                push!(res, (i-1, j-1))\n            end\n        end\n\
    \    end\n    sort!(res, by = x -> x[1])\n    for i in 1:length(res)\n       \
    \ if res[i][1] == res[i+1][1]\n            sort!(res, by = x -> x[2], rev = true)\n\
    \        end\n    end\n    return res\nend", "    # your code here\n    return\
    \ []\nend", "    # YOUR CODE HERE\n    return []\nend", "    # your code here\n\
    \    return []\nend", "    # YOUR CODE HERE\n    return []\nend", "    result\
    \ = []\n    for i in 1:length(lst)\n        for j in 1:length(lst[i])\n      \
    \      if lst[i][j] == x\n                push!(result, (i-1, j-1))\n        \
    \    end\n        end\n    end\n    return sort(result, by = x -> x[1])\nend",
  "    # YOUR CODE HERE\n    return []\nend", "    result = []\n    for (i, row) in\
    \ enumerate(lst)\n        for (j, col) in enumerate(row)\n            if col ==\
    \ x\n                push!(result, (i, j))\n            end\n        end\n   \
    \ end\n    sort!(result, by = x -> x[1])\n    sort!(result, by = x -> x[2], rev\
    \ = true)\n    return result\nend"]
stop_tokens:
- "\nfunction"
- "\nmacro"
- "\n\n"
