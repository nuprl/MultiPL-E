language: jl
name: HumanEval_123_get_odd_collatz
results:
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwcs_zunm.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpwcs_zunm.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz_list = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n/2\n        else\n         \
    \   n = 3*n + 1\n        end\n        push!(collatz_list, n)\n    end\n    return\
    \ filter(x -> x % 2 != 0, collatz_list)\nend\nusing Test\n\n@testset begin\n\n\
    candidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp2rghyz0e.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp2rghyz0e.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2rghyz0e.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2rghyz0e.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp2rghyz0e.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp2rghyz0e.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2rghyz0e.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp2rghyz0e.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp2rghyz0e.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp2rghyz0e.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    collatz = [n]\n    while n != 1\n        if n % 2 == 0\n            n = n/2\n\
    \        else\n            n = 3*n + 1\n        end\n        push!(collatz, n)\n\
    \    end\n    return filter(x -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11,\
    \ 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\
    \t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpuvjx01lx.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpuvjx01lx.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuvjx01lx.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuvjx01lx.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpuvjx01lx.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpuvjx01lx.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuvjx01lx.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpuvjx01lx.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpuvjx01lx.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpuvjx01lx.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwcs_zunm.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpwcs_zunm.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpystbykuj.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpystbykuj.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpystbykuj.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpystbykuj.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpystbykuj.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpystbykuj.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpystbykuj.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpystbykuj.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpystbykuj.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpystbykuj.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    collatz_seq = [n]\n    while n != 1\n        if n % 2 == 0\n            n\
    \ = n / 2\n        else\n            n = 3 * n + 1\n        end\n        push!(collatz_seq,\
    \ n)\n    end\n    return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1,\
    \ 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) ==\
    \ [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi5qvq9v9.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpi5qvq9v9.jl:36\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi5qvq9v9.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi5qvq9v9.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpi5qvq9v9.jl:37\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi5qvq9v9.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi5qvq9v9.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpi5qvq9v9.jl:38\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi5qvq9v9.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi5qvq9v9.jl:35\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwcs_zunm.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpwcs_zunm.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    if n == 1\n        return [1]\n    end\n    odd_collatz\
    \ = [n]\n    while n != 1\n        if n % 2 == 0\n            n = n / 2\n    \
    \    else\n            n = 3 * n + 1\n        end\n        if n % 2 != 0\n   \
    \         push!(odd_collatz, n)\n        end\n    end\n    return sort(odd_collatz)\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\t@test(candidate(14)\
    \ == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\t@test(candidate(12)\
    \ == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 2 passed, 2 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd8dj9vhj.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpd8dj9vhj.jl:42\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [1, 5, 7, 11, 13, 14, 17] == [1, 5,\
    \ 7, 11, 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd8dj9vhj.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd8dj9vhj.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpd8dj9vhj.jl:44\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [1, 3, 5, 12] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd8dj9vhj.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd8dj9vhj.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    2     2      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwcs_zunm.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpwcs_zunm.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz_seq = [n]\n    while\
    \ n != 1\n        if n % 2 == 0\n            n = n / 2\n        else\n       \
    \     n = 3 * n + 1\n        end\n        push!(collatz_seq, n)\n    end\n   \
    \ return filter(x -> x % 2 != 0, collatz_seq)\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\
    \t@test(candidate(5) == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1)\
    \ == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpystbykuj.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpystbykuj.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpystbykuj.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpystbykuj.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpystbykuj.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpystbykuj.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpystbykuj.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpystbykuj.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpystbykuj.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpystbykuj.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    if n == 1\n        return [1]\n    end\n    collatz = [n]\n    while n !=\
    \ 1\n        if n % 2 == 0\n            n = n / 2\n        else\n            n\
    \ = 3 * n + 1\n        end\n        push!(collatz, n)\n    end\n    return filter(x\
    \ -> x % 2 != 0, collatz)\nend\nusing Test\n\n@testset begin\n\ncandidate = get_odd_collatz;\n\
    \t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5) == [1, 5])\n\
    \t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwcs_zunm.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpwcs_zunm.jl:39\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: [7, 11, 17, 13, 5, 1] == [1, 5, 7, 11,\
    \ 13, 17]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:40\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ [5, 1] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpwcs_zunm.jl:41\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: [3, 5, 1] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @\
    \ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpwcs_zunm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwcs_zunm.jl:38\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    1     3      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
- exit_code: 1
  program: "\"\"\"\n    Given a positive integer n, return a sorted list that has\
    \ the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture\
    \ in mathematics that concerns a sequence defined\n    as follows: start with\
    \ any positive integer n. Then each term is obtained from the \n    previous term\
    \ as follows: if the previous term is even, the next term is one half of \n  \
    \  the previous term. If the previous term is odd, the next term is 3 times the\
    \ previous\n    term plus 1. The conjecture is that no matter what value of n,\
    \ the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n\
    \        2. returned list sorted in increasing order.\n\n    For example:\n  \
    \  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8,\
    \ 4, 2, 1], so the odd numbers are only 1, and 5.\n    >>> get_odd_collatz(5)\n\
    \    [1, 5]\n    \"\"\"\nfunction get_odd_collatz(n::Int64)::Vector{Int64} \n\
    \    # YOUR CODE HERE\n    return []\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = get_odd_collatz;\n\t@test(candidate(14) == [1, 5, 7, 11, 13, 17])\n\t@test(candidate(5)\
    \ == [1, 5])\n\t@test(candidate(12) == [1, 3, 5])\n\t@test(candidate(1) == [1])\n\
    end\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpr3115v5f.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpr3115v5f.jl:28\n  Expression: candidate(14)\
    \ == [1, 5, 7, 11, 13, 17]\n   Evaluated: Int64[] == [1, 5, 7, 11, 13, 17]\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:29\n  Expression: candidate(5) == [1, 5]\n   Evaluated:\
    \ Int64[] == [1, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:30\n  Expression: candidate(12) == [1, 3, 5]\n\
    \   Evaluated: Int64[] == [1, 3, 5]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpr3115v5f.jl:31\n  Expression: candidate(1) == [1]\n   Evaluated:\
    \ Int64[] == [1]\nStacktrace:\n [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpr3115v5f.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpr3115v5f.jl:27\nTest Summary:\
    \ | Fail  Total\ntest set      |    4      4\n"
