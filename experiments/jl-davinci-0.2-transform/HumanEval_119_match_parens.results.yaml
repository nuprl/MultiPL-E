language: jl
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if is_good(lst[1])\n        return\
    \ \"Yes\"\n    end\n    # check if the second string is good\n    if is_good(lst[2])\n\
    \        return \"Yes\"\n    end\n    # check if the concatenation of the two\
    \ strings is good\n    if is_good(lst[1] * lst[2])\n        return \"Yes\"\n \
    \   end\n    # check if the concatenation of the two strings in reverse order\
    \ is good\n    if is_good(lst[2] * lst[1])\n        return \"Yes\"\n    end\n\
    \    # if none of the above is true, then return \"No\"\n    return \"No\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmph67ghmro.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmph67ghmro.jl:42\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmph67ghmro.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph67ghmro.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph67ghmro.jl:41\ntest set:\
    \ Error During Test at /tmp/tmph67ghmro.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmph67ghmro.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph67ghmro.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph67ghmro.jl:41\ntest set:\
    \ Error During Test at /tmp/tmph67ghmro.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmph67ghmro.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph67ghmro.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph67ghmro.jl:41\ntest set:\
    \ Error During Test at /tmp/tmph67ghmro.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmph67ghmro.jl:19\n\
    \   ["
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] != ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] != '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb3fte722.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb3fte722.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:50\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if count(s1, '(') == count(s1, ')') && count(s2,\
    \ '(') == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmptac3weeo.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmptac3weeo.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmptac3weeo.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmptac3weeo.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n  \
    \      else\n            return match_parens([lst[1][2:end], lst[2]])\n      \
    \  end\n    else\n        if lst[2][1] == ')'\n            return match_parens([lst[1],\
    \ lst[2][2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5kh6wll0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5kh6wll0.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    cnt = 0\n    for i in s\n        if\
    \ i == '('\n            cnt += 1\n        else\n            cnt -= 1\n       \
    \ end\n        if cnt < 0\n            return \"No\"\n        end\n    end\n \
    \   if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbqlzn9p5.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpbqlzn9p5.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqlzn9p5.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqlzn9p5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpbqlzn9p5.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqlzn9p5.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqlzn9p5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpbqlzn9p5.jl:53\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqlzn9p5.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqlzn9p5.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmhph5jfv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpmhph5jfv.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:31\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:34\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    str1 = lst[1]\n    str2 = lst[2]\n    if isbalanced(str1) && isbalanced(str2)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpab53_hwo.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpab53_hwo.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpab53_hwo.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpab53_hwo.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpab53_hwo.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpab53_hwo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpab53_hwo.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpab53_hwo.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpab53_hwo.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpab53_hwo.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpab53_hwo.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpab53_hwo.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpab53_hwo.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpab53_hwo.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpab53_hw"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1) &&\n        count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \   return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp84q3crv7.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp84q3crv7.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:40\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    cnt = 0\n    for i in 1:length(s)\n\
    \        if s[i] == '('\n            cnt += 1\n        else\n            cnt -=\
    \ 1\n        end\n        if cnt < 0\n            return \"No\"\n        end\n\
    \    end\n    if cnt == 0\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1n4qd3wb.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmp1n4qd3wb.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1n4qd3wb.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1n4qd3wb.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp1n4qd3wb.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1n4qd3wb.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1n4qd3wb.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp1n4qd3wb.jl:53\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1n4qd3wb.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1n4qd3wb.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s = lst[1] * lst[2]\n    if s == \"\"\n        return \"Yes\"\n    end\n\
    \    if s[1] == ')'\n        return \"No\"\n    end\n    if s[end] == '('\n  \
    \      return \"No\"\n    end\n    if count(x -> x == '(', s) != count(x -> x\
    \ == ')', s)\n        return \"No\"\n    end\n    if count(x -> x == '(', s) ==\
    \ count(x -> x == ')', s) == 0\n        return \"Yes\"\n    end\n    if count(x\
    \ -> x == '(', s) == count(x -> x == ')', s) == 1\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s) == count(x -> x == ')', s) == 2\n      \
    \  return \"Yes\"\n    end\n    if count(x -> x == '(', s) == count(x -> x ==\
    \ ')', s) == 3\n        return \"No\"\n    end\n    if count(x -> x == '(', s)\
    \ == count(x -> x == ')', s) == 4\n        return \"Yes\"\n    end\n    if count(x\
    \ -> x == '(', s) == count(x -> x == ')', s) == 5\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s) == count(x -> x == ')', s) == 6\n      \
    \  return \"Yes\"\n    end\n    if count(x -> x == '(', s) == count(x -> x ==\
    \ ')', s) == 7\n        return \"No\"\n    end\n    if count(x -> x == '(', s)\
    \ == count(x -> x == ')', s) == 8\n        return \"Yes\"\n    end\n    if count(x\
    \ -> x == '(', s) == count(x -> x == ')', s) == 9\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s) == count(x -> x == ')', s) == 10\n     \
    \   return \"Yes\"\n    end\n    if count(x -> x == '(', s) ==\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph4nsjvdk.jl:1\nin expression starting at /tmp/tmph4nsjvdk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # Check if the first string is good\n    if !is_good(lst[1])\n       \
    \ return \"No\"\n    end\n    # Check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # Check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    # Check if the concatenation of the two strings in reverse order is good\n\
    \    if !is_good(lst[2] * lst[1])\n        return \"No\"\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpni5kqife.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpni5kqife.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpni5kqife.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpni5kqife.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpni5kqife.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpni5kqife.jl:19\n\
    \   ["
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \")\" || s2 == \")\"\n        return\
    \ \"No\"\n    end\n    if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n\
    \    end\n    if s1 == \"(\"\n        return \"Yes\"\n    end\n    if s2 == \"\
    (\"\n        return \"Yes\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpcobirw77.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpcobirw77.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcobirw77.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcobirw77.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpcobirw77.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpcobirw77.jl:29\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcobirw77.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcobirw77.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpcobirw77.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::Ab"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmhph5jfv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpmhph5jfv.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:31\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:34\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ >\n        count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return\
    \ \"No\"\n    end\n    s = s1 * s2\n    cnt = 0\n    for c in s\n        if c\
    \ == '('\n            cnt += 1\n        else\n            cnt -= 1\n        end\n\
    \        if cnt < 0\n            return \"No\"\n        end\n    end\n    if cnt\
    \ == 0\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpys3plp6v.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpys3plp6v.jl:49\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpys3plp6v.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpys3plp6v.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpys3plp6v.jl:50\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpys3plp6v.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpys3plp6v.jl:45\ntest set: Test Failed at /tmp/tmpys3plp6v.jl:57\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpys3plp6v.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpys3plp6v.jl:45\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ >\n        count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return\
    \ \"No\"\n    end\n    s = s1 * s2\n    if count(x -> x == ')', s) > count(x ->\
    \ x == '(', s)\n        return \"No\"\n    end\n    return \"Yes\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9bcfap9t.jl:31

    '
  stdout: "test set: Test Failed at /tmp/tmp9bcfap9t.jl:41\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9bcfap9t.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9bcfap9t.jl:33\ntest set: Test\
    \ Failed at /tmp/tmp9bcfap9t.jl:42\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9bcfap9t.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9bcfap9t.jl:33\ntest set: Test Failed at /tmp/tmp9bcfap9t.jl:43\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9bcfap9t.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9bcfap9t.jl:33\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if count(s1, '(') == count(s1, ')') && count(s2,\
    \ '(') == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmptac3weeo.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmptac3weeo.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmptac3weeo.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmptac3weeo.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    cnt = 0\n    for c in s\n        if\
    \ c == '('\n            cnt += 1\n        else\n            cnt -= 1\n       \
    \ end\n        if cnt < 0\n            return \"No\"\n        end\n    end\n \
    \   return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfvrrsa_g.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpfvrrsa_g.jl:41\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfvrrsa_g.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfvrrsa_g.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpfvrrsa_g.jl:42\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfvrrsa_g.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfvrrsa_g.jl:37\ntest set: Test Failed at /tmp/tmpfvrrsa_g.jl:45\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfvrrsa_g.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfvrrsa_g.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpfvrrsa_g.jl:49\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfvrrsa_g.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfvrrsa_g.jl:37\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    8     4     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if !(is_balanced(s1) && is_balanced(s2))\n        return\
    \ \"No\"\n    end\n    if count_parens(s1) == count_parens(s2)\n        return\
    \ \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpn6bzgos6.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpn6bzgos6.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpn6bzgos6.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn6bzgos6.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn6bzgos6.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpn6bzgos6.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpn6bzgos6.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn6bzgos6.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn6bzgos6.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpn6bzgos6.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpn6bzgos6.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpn6bzgos6.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpn6bzgos6.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpn6bzgos6.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpn6bzgos6.jl:19\n   [2] macro expan"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][end]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][1:end-1]])\n\
    \        else\n            return match_parens([lst[1][2:end], lst[2]])\n    \
    \    end\n    else\n        if lst[2][end] == ')'\n            return match_parens([lst[1],\
    \ lst[2][1:end-1]])\n        else\n            return \"No\"\n        end\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpm13pqbvv.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpm13pqbvv.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm13pqbvv.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm13pqbvv.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm13pqbvv.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm13pqbvv.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm13pqbvv.jl:42\ntest set: Test Failed at /tmp/tmpm13pqbvv.jl:47\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpm13pqbvv.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpm13pqbvv.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpm13pqbvv.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpm13pqbvv.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpm13pqbvv.jl:42\ntest set: Test Failed at /tmp/tmpm13pqbvv.jl:50\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1)\n        return \"No\"\n    end\n    if is_good(s2)\n\
    \        return \"No\"\n    end\n    if count_open(s1) == count_open(s2)\n   \
    \     return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpvo9fs7cx.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpvo9fs7cx.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpvo9fs7cx.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvo9fs7cx.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvo9fs7cx.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvo9fs7cx.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvo9fs7cx.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvo9fs7cx.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvo9fs7cx.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvo9fs7cx.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvo9fs7cx.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvo9fs7cx.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvo9fs7cx.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvo9fs7cx.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvo9fs7cx.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    for i in lst[1]\n        if i == '('\n          \
    \  open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    for i in lst[2]\n        if i == '('\n            open_parens +=\
    \ 1\n        else\n            open_parens -= 1\n        end\n    end\n    if\
    \ open_parens == 0\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwdmcdzhp.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpwdmcdzhp.jl:53\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwdmcdzhp.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwdmcdzhp.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    s = s1 * s2\n    cnt = 0\n    for i in 1:length(s)\n        if\
    \ s[i] == '('\n            cnt += 1\n        else\n            cnt -= 1\n    \
    \    end\n        if cnt < 0\n            return \"No\"\n        end\n    end\n\
    \    if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpd8d_hzbn.jl:42

    '
  stdout: "test set: Test Failed at /tmp/tmpd8d_hzbn.jl:48\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd8d_hzbn.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd8d_hzbn.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpd8d_hzbn.jl:49\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpd8d_hzbn.jl:49 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpd8d_hzbn.jl:44\ntest set: Test Failed at /tmp/tmpd8d_hzbn.jl:56\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpd8d_hzbn.jl:56 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpd8d_hzbn.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    for s in lst\n        for c in s\n            if\
    \ c == '('\n                open_parens += 1\n            else\n             \
    \   open_parens -= 1\n            end\n            if open_parens < 0\n      \
    \          return \"No\"\n            end\n        end\n    end\n    if open_parens\
    \ == 0\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzl3zwdg9.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpzl3zwdg9.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzl3zwdg9.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzl3zwdg9.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpzl3zwdg9.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzl3zwdg9.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzl3zwdg9.jl:41\ntest set: Test Failed at /tmp/tmpzl3zwdg9.jl:53\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzl3zwdg9.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzl3zwdg9.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) == count(x -> x == '(',\
    \ s2)\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmph9njfznr.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmph9njfznr.jl:30\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph9njfznr.jl:33\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test Failed at /tmp/tmph9njfznr.jl:34\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph9njfznr.jl:35\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test Failed at /tmp/tmph9njfznr.jl:36\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    # check if s1 and s2 are balanced\n    if is_balanced(s1)\
    \ && is_balanced(s2)\n        return \"Yes\"\n    end\n    # check if s1 + s2\
    \ is balanced\n    if is_balanced(s1 * s2)\n        return \"Yes\"\n    end\n\
    \    # check if s2 + s1 is balanced\n    if is_balanced(s2 * s1)\n        return\
    \ \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmppszsyn2j.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmppszsyn2j.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmppszsyn2j.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppszsyn2j.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppszsyn2j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmppszsyn2j.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmppszsyn2j.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppszsyn2j.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppszsyn2j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmppszsyn2j.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmppszsyn2j.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmppszsyn2j.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmppszsyn2j.jl:37\ntest set:\
    \ Error During Test at /tmp/tmppszsyn2j.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmppszsyn2j.jl:20\n   [2] macro expan"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if count(s, '(') == count(s, ')')\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpvgv1ti36.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpvgv1ti36.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpvgv1ti36.jl:20\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpvgv1ti36.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpvgv1ti36.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpvgv1ti36.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvgv1ti36.jl:20\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpvgv1ti36.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpvgv1ti36.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpvgv1ti36.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    n = length(s)\n    cnt = 0\n    for\
    \ i in 1:n\n        if s[i] == '('\n            cnt += 1\n        else\n     \
    \       cnt -= 1\n        end\n        if cnt < 0\n            return \"No\"\n\
    \        end\n    end\n    if cnt == 0\n        return \"Yes\"\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp44uxb8dz.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp44uxb8dz.jl:46\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp44uxb8dz.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp44uxb8dz.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp44uxb8dz.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp44uxb8dz.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp44uxb8dz.jl:42\ntest set: Test Failed at /tmp/tmp44uxb8dz.jl:54\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp44uxb8dz.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp44uxb8dz.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if !is_good(lst[1])\n       \
    \ return \"No\"\n    end\n    # check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp2b5b6o6u.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp2b5b6o6u.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp2b5b6o6u.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2b5b6o6u.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2b5b6o6u.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp2b5b6o6u.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2b5b6o6u.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2b5b6o6u.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2b5b6o6u.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp2b5b6o6u.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp2b5b6o6u.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2b5b6o6u.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2b5b6o6u.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp2b5b6o6u.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2b5b6o6u.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if count(s, '(') == count(s, ')')\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpvgv1ti36.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpvgv1ti36.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpvgv1ti36.jl:20\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpvgv1ti36.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpvgv1ti36.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpvgv1ti36.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvgv1ti36.jl:20\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpvgv1ti36.jl:32 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpvgv1ti36.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpvgv1ti36.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) == count(x -> x == '(',\
    \ s2)\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmph9njfznr.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmph9njfznr.jl:30\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph9njfznr.jl:33\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test Failed at /tmp/tmph9njfznr.jl:34\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph9njfznr.jl:35\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test Failed at /tmp/tmph9njfznr.jl:36\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        if count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \       return \"Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy9w3jmvp.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpy9w3jmvp.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpy9w3jmvp.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test Failed at /tmp/tmpy9w3jmvp.jl:35\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpy9w3jmvp.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test Failed at /tmp/tmpy9w3jmvp.jl:40\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) != count(x -> x == ')',\
    \ s1)\n        return \"No\"\n    end\n    if count(x -> x == '(', s2) != count(x\
    \ -> x == ')', s2)\n        return \"No\"\n    end\n    return \"Yes\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqtd_hexp.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpqtd_hexp.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqtd_hexp.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqtd_hexp.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpqtd_hexp.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqtd_hexp.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqtd_hexp.jl:31\ntest set: Test Failed at /tmp/tmpqtd_hexp.jl:36\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqtd_hexp.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqtd_hexp.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpqtd_hexp.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqtd_hexp.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqtd_hexp.jl:31\ntest set: Test Failed at /tmp/tmpqtd_hexp.jl:41\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    cnt = 0\n    for c in s\n        if\
    \ c == '('\n            cnt += 1\n        else\n            cnt -= 1\n       \
    \ end\n        if cnt < 0\n            return \"No\"\n        end\n    end\n \
    \   if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp48ty1u_a.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmp48ty1u_a.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp48ty1u_a.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp48ty1u_a.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp48ty1u_a.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp48ty1u_a.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp48ty1u_a.jl:41\ntest set: Test Failed at /tmp/tmp48ty1u_a.jl:53\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp48ty1u_a.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp48ty1u_a.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if (count(x -> x == ')', s1) + count(x ->\
    \ x == ')', s2)) > (count(x -> x == '(', s1) + count(x -> x == '(', s2))\n   \
    \     return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpnw2orxsf.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpnw2orxsf.jl:36\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnw2orxsf.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnw2orxsf.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpnw2orxsf.jl:37\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpnw2orxsf.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpnw2orxsf.jl:28\ntest set: Test Failed at /tmp/tmpnw2orxsf.jl:38\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpnw2orxsf.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpnw2orxsf.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    for i in lst[1]\n        if i == '('\n          \
    \  open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    for i in lst[2]\n        if i == '('\n            open_parens +=\
    \ 1\n        else\n            open_parens -= 1\n        end\n    end\n    if\
    \ open_parens == 0\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpwdmcdzhp.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpwdmcdzhp.jl:53\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpwdmcdzhp.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpwdmcdzhp.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1)\n        return \"No\"\n    end\n    if is_good(s2)\n\
    \        return \"No\"\n    end\n    if count_parens(s1) == count_parens(s2)\n\
    \        return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpvock7_iw.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpvock7_iw.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpvock7_iw.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvock7_iw.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvock7_iw.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvock7_iw.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvock7_iw.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvock7_iw.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvock7_iw.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvock7_iw.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvock7_iw.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvock7_iw.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvock7_iw.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvock7_iw.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvock7_iw.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n  \
    \      else\n            return match_parens([lst[1][2:end], lst[2]])\n      \
    \  end\n    else\n        if lst[2][1] == ')'\n            return match_parens([lst[1],\
    \ lst[2][2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5kh6wll0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5kh6wll0.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \"(\" && s2 == \")\"\n        return\
    \ \"Yes\"\n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n   \
    \ elseif s1 == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"\
    (\" && s2 == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpvoc0rf9y.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpvoc0rf9y.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvoc0rf9y.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvoc0rf9y.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvoc0rf9y.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvoc0rf9y.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvoc0rf9y.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvoc0rf9y.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if isbalanced(s1) && isbalanced(s2)\n        return\
    \ \"Yes\"\n    elseif isbalanced(s1) && !isbalanced(s2)\n        return \"No\"\
    \n    elseif !isbalanced(s1) && isbalanced(s2)\n        return \"No\"\n    else\n\
    \        return \"Yes\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpsku9s9oc.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpsku9s9oc.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpsku9s9oc.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsku9s9oc.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsku9s9oc.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpsku9s9oc.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpsku9s9oc.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsku9s9oc.jl:35 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsku9s9oc.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpsku9s9oc.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpsku9s9oc.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpsku9s9oc.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpsku9s9oc.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpsku9s9oc.jl:37\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpsku9s9oc.jl:19\n   [2] macro expansion"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if count(x -> x == '(', s) == count(x\
    \ -> x == ')', s)\n        return \"Yes\"\n    else\n        return \"No\"\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmd9443nt.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpmd9443nt.jl:40\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmd9443nt.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmd9443nt.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_balanced(s)\n        return \"\
    Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpwxqhlr2l.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpwxqhlr2l.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpwxqhlr2l.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwxqhlr2l.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwxqhlr2l.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpwxqhlr2l.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_balanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpwxqhlr2l.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwxqhlr2l.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwxqhlr2l.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpwxqhlr2l.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_balanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpwxqhlr2l.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpwxqhlr2l.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpwxqhlr2l.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpwxqhlr2l.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_balanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpwxqhlr2l.jl:20\n   [2] macro expan"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if (s1 == \"\") && (s2 == \"\")\n       \
    \ return \"Yes\"\n    elseif (s1 == \"\") && (s2 != \"\")\n        return \"No\"\
    \n    elseif (s1 != \"\") && (s2 == \"\")\n        return \"Yes\"\n    else\n\
    \        if s1[end] == '('\n            return match_parens([s1[1:end-1], s2])\n\
    \        elseif s2[end] == ')'\n            return match_parens([s1, s2[1:end-1]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpca_vrh8u.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmpca_vrh8u.jl:41\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpca_vrh8u.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpca_vrh8u.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpca_vrh8u.jl:43\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpca_vrh8u.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpca_vrh8u.jl:39\ntest set: Test Failed at /tmp/tmpca_vrh8u.jl:44\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpca_vrh8u.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpca_vrh8u.jl:39\ntest set: Test\
    \ Failed at /tmp/tmpca_vrh8u.jl:46\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpca_vrh8u.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpca_vrh8u.jl:39\ntest set: Test Failed at /tmp/tmpca_vrh8u.jl:50\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.j"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '(' && s2[end] == ')'\n        return match_parens([s1[2:end],\
    \ s2[1:end-1]])\n    elseif s1[1] == ')' && s2[end] == '('\n        return match_parens([s1[2:end],\
    \ s2[1:end-1]])\n    elseif s1[1] == '(' && s2[end] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s1[1] == ')' && s2[end] == ')'\n        return match_parens([s1[2:end],\
    \ s2])\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplq3twbaf.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmplq3twbaf.jl:42\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test\
    \ Failed at /tmp/tmplq3twbaf.jl:45\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test Failed at /tmp/tmplq3twbaf.jl:46\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test\
    \ Failed at /tmp/tmplq3twbaf.jl:48\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test Failed at /tmp/tmplq3twbaf.jl:51\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    lst[1] = replace(lst[1], \")\", \"\")\n    lst[2] = replace(lst[2], \"\
    (\", \"\")\n    if lst[1] == \"\" && lst[2] == \"\"\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpnaihu2tw.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpnaihu2tw.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching replace(::String, ::String, ::String)\n  Closest candidates are:\n\
    \    replace(!Matched::Union{Function, Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpnaihu2tw.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnaihu2tw.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnaihu2tw.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpnaihu2tw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: no method matching replace(::String,\
    \ ::String, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpnaihu2tw.jl:18\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnaihu2tw.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnaihu2tw.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpnaih"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if count(x -> x == ')', lst[1]) > count(x -> x == '(', lst[2])\n     \
    \   return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmjxyed0q.jl:25

    '
  stdout: "test set: Test Failed at /tmp/tmpmjxyed0q.jl:28\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmjxyed0q.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmjxyed0q.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmjxyed0q.jl:33\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmjxyed0q.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpmjxyed0q.jl:27\ntest set: Test Failed at /tmp/tmpmjxyed0q.jl:35\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmjxyed0q.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmjxyed0q.jl:27\ntest set: Test\
    \ Failed at /tmp/tmpmjxyed0q.jl:36\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpmjxyed0q.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpmjxyed0q.jl:27\ntest set: Test Failed at /tmp/tmpmjxyed0q.jl:37\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inli"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) > 0\n        return \"No\"\n\
    \    elseif length(lst[1]) > 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif length(lst[1]) > 0 && length(lst[2]) > 0\n        if lst[1][1] ==\
    \ '('\n            lst[1] = lst[1][2:end]\n            return match_parens(lst)\n\
    \        elseif lst[2][1] == ')'\n            lst[2] = lst[2][2:end]\n       \
    \     return match_parens(lst)\n        else\n            return \"No\"\n    \
    \    end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpstmt6g3u.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpstmt6g3u.jl:41\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpstmt6g3u.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpstmt6g3u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpstmt6g3u.jl:44\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpstmt6g3u.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpstmt6g3u.jl:40\ntest set: Test Failed at /tmp/tmpstmt6g3u.jl:45\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpstmt6g3u.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpstmt6g3u.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpstmt6g3u.jl:47\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpstmt6g3u.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpstmt6g3u.jl:40\ntest set: Test Failed at /tmp/tmpstmt6g3u.jl:51\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1) &&\n        count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \   return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp84q3crv7.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp84q3crv7.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:40\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp0typ31rv.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp0typ31rv.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] != ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] != '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb3fte722.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb3fte722.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:50\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if count(x -> x == '(', s) == count(x\
    \ -> x == ')', s)\n        return \"Yes\"\n    else\n        return \"No\"\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmd9443nt.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpmd9443nt.jl:40\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmd9443nt.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmd9443nt.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if sum(count(x -> x == '(', lst[1])) == sum(count(x -> x == ')', lst[2]))\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpzl8q8dl4.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpzl8q8dl4.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzl8q8dl4.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzl8q8dl4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpzl8q8dl4.jl:31\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzl8q8dl4.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzl8q8dl4.jl:28\ntest set: Test Failed at /tmp/tmpzl8q8dl4.jl:32\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpzl8q8dl4.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpzl8q8dl4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpzl8q8dl4.jl:33\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpzl8q8dl4.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpzl8q8dl4.jl:28\ntest set: Test Failed at /tmp/tmpzl8q8dl4.jl:35\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Te"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) > count(x -> x == '(', s2)\n\
    \        return \"No\"\n    end\n    s = s1 * s2\n    cnt = 0\n    for c in s\n\
    \        if c == '('\n            cnt += 1\n        else\n            cnt -= 1\n\
    \        end\n        if cnt < 0\n            return \"No\"\n        end\n   \
    \ end\n    if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 8 passed, 4 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqwx0ax2q.jl:42

    '
  stdout: "test set: Test Failed at /tmp/tmpqwx0ax2q.jl:45\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqwx0ax2q.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqwx0ax2q.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpqwx0ax2q.jl:48\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqwx0ax2q.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqwx0ax2q.jl:44\ntest set: Test Failed at /tmp/tmpqwx0ax2q.jl:49\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqwx0ax2q.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqwx0ax2q.jl:44\ntest set: Test\
    \ Failed at /tmp/tmpqwx0ax2q.jl:56\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqwx0ax2q.jl:56 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqwx0ax2q.jl:44\nTest Summary: | Pass  Fail\
    \  Total\ntest set      |    8     4     12\n"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmhph5jfv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpmhph5jfv.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:31\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:34\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    s = s1 * s2\n    while contains(s, \"()\")\n        s = replace(s,\
    \ \"()\" => \"\")\n    end\n    if s == \"\"\n        return \"Yes\"\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqn1xhnff.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpqn1xhnff.jl:40\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqn1xhnff.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqn1xhnff.jl:36\ntest set: Test\
    \ Failed at /tmp/tmpqn1xhnff.jl:41\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqn1xhnff.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqn1xhnff.jl:36\ntest set: Test Failed at /tmp/tmpqn1xhnff.jl:48\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqn1xhnff.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqn1xhnff.jl:36\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) > count(x -> x == '(', s2)\n\
    \        return \"No\"\n    end\n    if count(x -> x == '(', s1) > count(x ->\
    \ x == ')', s2)\n        return \"No\"\n    end\n    return \"Yes\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp3jc3if5d.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmp3jc3if5d.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3jc3if5d.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3jc3if5d.jl:31\ntest set: Test\
    \ Failed at /tmp/tmp3jc3if5d.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp3jc3if5d.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp3jc3if5d.jl:31\ntest set: Test Failed at /tmp/tmp3jc3if5d.jl:41\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp3jc3if5d.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp3jc3if5d.jl:31\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \")\" || s2 == \")\"\n        return\
    \ \"No\"\n    end\n    if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n\
    \    end\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    end\n\
    \    if s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    end\n    if s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp49qpdmop.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmp49qpdmop.jl:40\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp49qpdmop.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp49qpdmop.jl:39\ntest set: Error\
    \ During Test at /tmp/tmp49qpdmop.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp49qpdmop.jl:32\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp49qpdmop.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp49qpdmop.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp49qpdmop.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.c"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    n1, n2 = length(s1), length(s2)\n    if n1 == 0 && n2\
    \ == 0\n        return \"Yes\"\n    elseif n1 == 0 && n2 > 0\n        return \"\
    No\"\n    elseif n1 > 0 && n2 == 0\n        return \"Yes\"\n    elseif s1[end]\
    \ == '(' && s2[1] == ')'\n        return match_parens([s1[1:end-1], s2[2:end]])\n\
    \    elseif s1[end] == ')' && s2[1] == '('\n        return match_parens([s1[1:end-1],\
    \ s2[2:end]])\n    elseif s1[end] == '(' && s2[1] == '('\n        return match_parens([s1[1:end-1],\
    \ s2[2:end]])\n    elseif s1[end] == ')' && s2[1] == ')'\n        return match_parens([s1[1:end-1],\
    \ s2[2:end]])\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpqznozlr5.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmpqznozlr5.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqznozlr5.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqznozlr5.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpqznozlr5.jl:45\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqznozlr5.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqznozlr5.jl:42\ntest set: Test Failed at /tmp/tmpqznozlr5.jl:46\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpqznozlr5.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpqznozlr5.jl:42\ntest set: Test\
    \ Failed at /tmp/tmpqznozlr5.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpqznozlr5.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpqznozlr5.jl:42\ntest set: Test Failed at /tmp/tmpqznozlr5.jl:49\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    # check if the second string\
    \ is good\n    # if both are good, return \"Yes\"\n    # else return \"No\"\n\
    \    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpseo6fps4.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpseo6fps4.jl:30\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpseo6fps4.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpseo6fps4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpseo6fps4.jl:31\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpseo6fps4.jl:31 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpseo6fps4.jl:28\ntest set: Test Failed at /tmp/tmpseo6fps4.jl:34\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpseo6fps4.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpseo6fps4.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpseo6fps4.jl:36\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpseo6fps4.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpseo6fps4.jl:28\ntest set: Test Failed at /tmp/tmpseo6fps4.jl:37\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] == '('\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    elseif lst[1][1]\
    \ == ')' && lst[2][1] == '('\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp29kw_862.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp29kw_862.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29kw_862.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test Failed at /tmp/tmp29kw_862.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29kw_862.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test Failed at /tmp/tmp29kw_862.jl:50\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp72zlvkgx.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmp72zlvkgx.jl:25\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp72zlvkgx.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp72zlvkgx.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp72zlvkgx.jl:24\ntest set:\
    \ Error During Test at /tmp/tmp72zlvkgx.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp72zlvkgx.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp72zlvkgx.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp0typ31rv.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp0typ31rv.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        if count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \       return \"Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy9w3jmvp.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpy9w3jmvp.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpy9w3jmvp.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test Failed at /tmp/tmpy9w3jmvp.jl:35\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpy9w3jmvp.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test Failed at /tmp/tmpy9w3jmvp.jl:40\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if count(s1, '(') == count(s1, ')') && count(s2,\
    \ '(') == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmptac3weeo.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmptac3weeo.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmptac3weeo.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmptac3weeo.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if sum(count(x -> x == ')', lst[1])) > sum(count(x -> x == '(', lst[2]))\n\
    \        return \"No\"\n    else\n        return \"Yes\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpw0sma9_m.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpw0sma9_m.jl:29\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw0sma9_m.jl:29 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw0sma9_m.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpw0sma9_m.jl:34\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw0sma9_m.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpw0sma9_m.jl:28\ntest set: Test Failed at /tmp/tmpw0sma9_m.jl:36\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpw0sma9_m.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpw0sma9_m.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpw0sma9_m.jl:37\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpw0sma9_m.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpw0sma9_m.jl:28\ntest set: Test Failed at /tmp/tmpw0sma9_m.jl:38\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inli"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkpzoxi1s.jl:26

    '
  stdout: "test set: Test Failed at /tmp/tmpkpzoxi1s.jl:36\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkpzoxi1s.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkpzoxi1s.jl:28\ntest set: Test\
    \ Failed at /tmp/tmpkpzoxi1s.jl:37\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkpzoxi1s.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkpzoxi1s.jl:28\ntest set: Test Failed at /tmp/tmpkpzoxi1s.jl:38\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkpzoxi1s.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkpzoxi1s.jl:28\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s2[end] == ')'\n        return match_parens([s1, s2[1:end-1]])\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpddgzggdp.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpddgzggdp.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:44\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:48\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \"\"\n        return \"Yes\"\n \
    \   elseif s2 == \"\"\n        return \"Yes\"\n    elseif s1[end] == '(' && s2[1]\
    \ == ')'\n        return match_parens([s1[1:end-1], s2[2:end]])\n    elseif s1[end]\
    \ == ')' && s2[1] == '('\n        return match_parens([s1[1:end-1], s2[2:end]])\n\
    \    elseif s1[end] == '(' && s2[1] == '('\n        return match_parens([s1[1:end-1],\
    \ s2])\n    elseif s1[end] == ')' && s2[1] == ')'\n        return match_parens([s1[1:end-1],\
    \ s2])\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp0di113ju.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmp0di113ju.jl:41\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0di113ju.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0di113ju.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp0di113ju.jl:42\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0di113ju.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0di113ju.jl:39\ntest set: Test Failed at /tmp/tmp0di113ju.jl:45\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp0di113ju.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp0di113ju.jl:39\ntest set: Test\
    \ Failed at /tmp/tmp0di113ju.jl:47\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp0di113ju.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp0di113ju.jl:39\ntest set: Test Failed at /tmp/tmp0di113ju.jl:48\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    n = length(s)\n    cnt = 0\n    for\
    \ i in 1:n\n        if s[i] == '('\n            cnt += 1\n        else\n     \
    \       cnt -= 1\n        end\n        if cnt < 0\n            return \"No\"\n\
    \        end\n    end\n    if cnt == 0\n        return \"Yes\"\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp44uxb8dz.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp44uxb8dz.jl:46\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp44uxb8dz.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp44uxb8dz.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp44uxb8dz.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp44uxb8dz.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp44uxb8dz.jl:42\ntest set: Test Failed at /tmp/tmp44uxb8dz.jl:54\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp44uxb8dz.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp44uxb8dz.jl:42\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp0typ31rv.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp0typ31rv.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if is_good(s1) && is_good(s2)\n        return\
    \ \"Yes\"\n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n\
    \    end\n    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && !is_good(s2)\n        if count_open(s1) == count_close(s2)\n\
    \            return \"Yes\"\n        end\n        if count_open(s1) > count_close(s2)\n\
    \            return \"No\"\n        end\n        if count_open(s1) < count_close(s2)\n\
    \            return \"No\"\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp2zsdeu9_.jl:42

    '
  stdout: "test set: Error During Test at /tmp/tmp2zsdeu9_.jl:45\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp2zsdeu9_.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2zsdeu9_.jl:45 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2zsdeu9_.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp2zsdeu9_.jl:46\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2zsdeu9_.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2zsdeu9_.jl:46 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2zsdeu9_.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp2zsdeu9_.jl:47\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp2zsdeu9_.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2zsdeu9_.jl:47 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2zsdeu9_.jl:44\ntest set:\
    \ Error During Test at /tmp/tmp2zsdeu9_.jl:48\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2zsdeu9_.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \"(\" && s2 == \")\"\n        return\
    \ \"Yes\"\n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n   \
    \ elseif s1 == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"\
    (\" && s2 == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpvoc0rf9y.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpvoc0rf9y.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvoc0rf9y.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvoc0rf9y.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvoc0rf9y.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvoc0rf9y.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvoc0rf9y.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvoc0rf9y.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if is_good(lst[1])\n        return\
    \ \"Yes\"\n    end\n    # check if the second string is good\n    if is_good(lst[2])\n\
    \        return \"Yes\"\n    end\n    # check if the concatenation of the two\
    \ strings is good\n    if is_good(lst[1] * lst[2])\n        return \"Yes\"\n \
    \   end\n    # check if the concatenation of the two strings in reverse order\
    \ is good\n    if is_good(lst[2] * lst[1])\n        return \"Yes\"\n    end\n\
    \    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp6a5n85hf.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp6a5n85hf.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp6a5n85hf.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6a5n85hf.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6a5n85hf.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp6a5n85hf.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp6a5n85hf.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6a5n85hf.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6a5n85hf.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp6a5n85hf.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp6a5n85hf.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6a5n85hf.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6a5n85hf.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp6a5n85hf.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp6a5n85hf.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    for s in lst[1]\n        if s == '('\n          \
    \  open_parens += 1\n        else\n            open_parens -= 1\n        end\n\
    \    end\n    for s in lst[2]\n        if s == '('\n            open_parens +=\
    \ 1\n        else\n            open_parens -= 1\n        end\n    end\n    if\
    \ open_parens == 0\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkpqrt9t0.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpkpqrt9t0.jl:53\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkpqrt9t0.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkpqrt9t0.jl:43\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s1_open, s1_close = count(x -> x == '(', s1), count(x\
    \ -> x == ')', s1)\n    s2_open, s2_close = count(x -> x == '(', s2), count(x\
    \ -> x == ')', s2)\n    if s1_open == s1_close && s2_open == s2_close\n      \
    \  return \"Yes\"\n    elseif s1_open == s1_close && s2_open != s2_close\n   \
    \     if s2_open > s2_close\n            return \"Yes\"\n        else\n      \
    \      return \"No\"\n        end\n    elseif s1_open != s1_close && s2_open ==\
    \ s2_close\n        if s1_open > s1_close\n            return \"Yes\"\n      \
    \  else\n            return \"No\"\n        end\n    else\n        return \"No\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 4 passed, 8 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkihtca70.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpkihtca70.jl:44\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkihtca70.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkihtca70.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpkihtca70.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkihtca70.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkihtca70.jl:43\ntest set: Test Failed at /tmp/tmpkihtca70.jl:48\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkihtca70.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkihtca70.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpkihtca70.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpkihtca70.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpkihtca70.jl:43\ntest set: Test Failed at /tmp/tmpkihtca70.jl:52\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/sr"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if count(x -> x == '(', s) == count(x\
    \ -> x == ')', s)\n        return \"Yes\"\n    else\n        return \"No\"\n \
    \   end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmd9443nt.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpmd9443nt.jl:40\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmd9443nt.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmd9443nt.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\"\n        return \"Yes\"\n    end\n   \
    \ if s2 == \"\"\n        return \"Yes\"\n    end\n    if s1[1] == '('\n      \
    \  if s2[end] == ')'\n            return match_parens([s1[2:end], s2[1:end-1]])\n\
    \        else\n            return match_parens([s1[2:end], s2])\n        end\n\
    \    else\n        if s2[end] == ')'\n            return match_parens([s1, s2[1:end-1]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpt3e3z2h8.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpt3e3z2h8.jl:45\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpt3e3z2h8.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test Failed at /tmp/tmpt3e3z2h8.jl:48\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpt3e3z2h8.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test Failed at /tmp/tmpt3e3z2h8.jl:51\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\"\n        return \"Yes\"\n    end\n   \
    \ if s2 == \"\"\n        return \"Yes\"\n    end\n    if s1[1] == '(' && s2[end]\
    \ == ')'\n        return match_parens([s1[2:end], s2[1:end-1]])\n    end\n   \
    \ if s1[1] == ')' && s2[end] == '('\n        return match_parens([s1[2:end], s2[1:end-1]])\n\
    \    end\n    if s1[1] == '(' && s2[end] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    end\n    if s1[1] == ')' && s2[end] == ')'\n        return match_parens([s1[2:end],\
    \ s2])\n    end\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdabps80p.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpdabps80p.jl:45\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdabps80p.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdabps80p.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpdabps80p.jl:46\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdabps80p.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdabps80p.jl:43\ntest set: Test Failed at /tmp/tmpdabps80p.jl:49\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdabps80p.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdabps80p.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpdabps80p.jl:51\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdabps80p.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdabps80p.jl:43\ntest set: Test Failed at /tmp/tmpdabps80p.jl:52\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    for s in lst\n        for c in s\n            if\
    \ c == '('\n                open_parens += 1\n            elseif c == ')'\n  \
    \              open_parens -= 1\n            end\n            if open_parens <\
    \ 0\n                return \"No\"\n            end\n        end\n    end\n  \
    \  if open_parens == 0\n        return \"Yes\"\n    else\n        return \"No\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpi74g0iim.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpi74g0iim.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi74g0iim.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi74g0iim.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpi74g0iim.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpi74g0iim.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpi74g0iim.jl:41\ntest set: Test Failed at /tmp/tmpi74g0iim.jl:53\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpi74g0iim.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpi74g0iim.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    s = s1 * s2\n    if count(x -> x == ')', s) > count(x -> x == '(',\
    \ s)\n        return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9soy8jtm.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmp9soy8jtm.jl:40\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9soy8jtm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9soy8jtm.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp9soy8jtm.jl:41\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9soy8jtm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9soy8jtm.jl:32\ntest set: Test Failed at /tmp/tmp9soy8jtm.jl:42\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9soy8jtm.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9soy8jtm.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) == count(x -> x == '(',\
    \ s2)\n        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmph9njfznr.jl:27

    '
  stdout: "test set: Test Failed at /tmp/tmph9njfznr.jl:30\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph9njfznr.jl:33\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test Failed at /tmp/tmph9njfznr.jl:34\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test\
    \ Failed at /tmp/tmph9njfznr.jl:35\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmph9njfznr.jl:35 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmph9njfznr.jl:29\ntest set: Test Failed at /tmp/tmph9njfznr.jl:36\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp0typ31rv.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp0typ31rv.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    s = s1 * s2\n    while true\n        s = replace(s, \"()\")\n \
    \       if s == \"()\"\n            return \"Yes\"\n        elseif s == \"\"\n\
    \            return \"Yes\"\n        elseif s == \"(\" || s == \")\"\n       \
    \     return \"No\"\n        end\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmp50wlqe3d.jl:36

    '
  stdout: "test set: Error During Test at /tmp/tmp50wlqe3d.jl:39\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: no method\
    \ matching replace(::String, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp50wlqe3d.jl:24\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp50wlqe3d.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp50wlqe3d.jl:38\ntest set:\
    \ Error During Test at /tmp/tmp50wlqe3d.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: no method matching\
    \ replace(::String, ::String)\n  Closest candidates are:\n    replace(!Matched::Union{Function,\
    \ Type}, ::Any; count) at ~/.conda/envs/polyglot/share/julia/base/set.jl:622\n\
    \    replace(::String, !Matched::Pair...; count) where N at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:535\n\
    \    replace(::AbstractString, !Matched::Pair...; count) at ~/.conda/envs/polyglot/share/julia/base/strings/util.jl:634\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp50wlqe3d.jl:24\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp50wlqe3d.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp50wlqe3d.jl:38\ntest set:\
    \ Error During Test at /tmp/tmp50wlqe3d.jl:43\n"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n  \
    \      else\n            return match_parens([lst[1][2:end], lst[2]])\n      \
    \  end\n    else\n        if lst[2][1] == ')'\n            return match_parens([lst[1],\
    \ lst[2][2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5kh6wll0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5kh6wll0.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        if count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \       return \"Yes\"\n        end\n    end\n    return \"No\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpy9w3jmvp.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmpy9w3jmvp.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpy9w3jmvp.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:34 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test Failed at /tmp/tmpy9w3jmvp.jl:35\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test\
    \ Failed at /tmp/tmpy9w3jmvp.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpy9w3jmvp.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpy9w3jmvp.jl:30\ntest set: Test Failed at /tmp/tmpy9w3jmvp.jl:40\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794411
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1) &&\n        count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \   return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp84q3crv7.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp84q3crv7.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:40\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0\n        if lst[2][1] == ')'\n            return\
    \ \"No\"\n        else\n            return match_parens([lst[1], lst[2][2:end]])\n\
    \        end\n    elseif length(lst[2]) == 0\n        if lst[1][end] == '('\n\
    \            return \"No\"\n        else\n            return match_parens([lst[1][1:end-1],\
    \ lst[2]])\n        end\n    else\n        if lst[1][end] == '('\n           \
    \ return match_parens([lst[1][1:end-1], lst[2]])\n        elseif lst[2][1] ==\
    \ ')'\n            return match_parens([lst[1], lst[2][2:end]])\n        else\n\
    \            return \"No\"\n        end\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpafgv3uko.jl:44

    '
  stdout: "test set: Test Failed at /tmp/tmpafgv3uko.jl:47\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpafgv3uko.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpafgv3uko.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpafgv3uko.jl:48\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpafgv3uko.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpafgv3uko.jl:46\ntest set: Test Failed at /tmp/tmpafgv3uko.jl:50\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpafgv3uko.jl:50 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpafgv3uko.jl:46\ntest set: Test\
    \ Failed at /tmp/tmpafgv3uko.jl:51\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpafgv3uko.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpafgv3uko.jl:46\ntest set: Test Failed at /tmp/tmpafgv3uko.jl:53\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1[1] == ')' && s2[1] == ')'\n        return \"No\"\
    \n    end\n    if s1[end] == '(' && s2[end] == '('\n        return \"No\"\n  \
    \  end\n    if s1[1] == ')' && s2[end] == '('\n        return \"No\"\n    end\n\
    \    if s1[end] == '(' && s2[1] == ')'\n        return \"No\"\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5vmm3u3h.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmp5vmm3u3h.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5vmm3u3h.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5vmm3u3h.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp5vmm3u3h.jl:40\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5vmm3u3h.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5vmm3u3h.jl:37\ntest set: Test Failed at /tmp/tmp5vmm3u3h.jl:41\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5vmm3u3h.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5vmm3u3h.jl:37\ntest set: Test\
    \ Failed at /tmp/tmp5vmm3u3h.jl:43\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp5vmm3u3h.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp5vmm3u3h.jl:37\ntest set: Test Failed at /tmp/tmp5vmm3u3h.jl:45\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test."
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\"\n        return \"Yes\"\n    end\n   \
    \ if s2 == \"\"\n        return \"Yes\"\n    end\n    if s1[1] == \"(\"\n    \
    \    if s2[end] == \")\"\n            return match_parens([s1[2:end], s2[1:end-1]])\n\
    \        else\n            return match_parens([s1[2:end], s2])\n        end\n\
    \    else\n        if s2[end] == \")\"\n            return match_parens([s1, s2[1:end-1]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpk7hxhw25.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpk7hxhw25.jl:44\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk7hxhw25.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk7hxhw25.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpk7hxhw25.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpk7hxhw25.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpk7hxhw25.jl:43\ntest set: Test Failed at /tmp/tmpk7hxhw25.jl:48\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpk7hxhw25.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpk7hxhw25.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpk7hxhw25.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpk7hxhw25.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpk7hxhw25.jl:43\ntest set: Test Failed at /tmp/tmpk7hxhw25.jl:54\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\"\n        return \"Yes\"\n    end\n   \
    \ if s2 == \"\"\n        return \"Yes\"\n    end\n    if s1[1] == '('\n      \
    \  if s2[end] == ')'\n            return match_parens([s1[2:end], s2[1:end-1]])\n\
    \        else\n            return match_parens([s1[2:end], s2])\n        end\n\
    \    else\n        if s2[end] == ')'\n            return match_parens([s1, s2[1:end-1]])\n\
    \        else\n            return \"No\"\n        end\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpt3e3z2h8.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpt3e3z2h8.jl:45\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpt3e3z2h8.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test Failed at /tmp/tmpt3e3z2h8.jl:48\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpt3e3z2h8.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpt3e3z2h8.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpt3e3z2h8.jl:43\ntest set: Test Failed at /tmp/tmpt3e3z2h8.jl:51\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) != count(x -> x == ')',\
    \ s1)\n        return \"No\"\n    end\n    if count(x -> x == '(', s2) != count(x\
    \ -> x == ')', s2)\n        return \"No\"\n    end\n    if count(x -> x == '(',\
    \ s1) == count(x -> x == ')', s1) && count(x -> x == '(', s2) == count(x -> x\
    \ == ')', s2)\n        return \"Yes\"\n    end\n    return \"No\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpta_7zug_.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpta_7zug_.jl:35\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpta_7zug_.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpta_7zug_.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpta_7zug_.jl:38\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpta_7zug_.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpta_7zug_.jl:34\ntest set: Test Failed at /tmp/tmpta_7zug_.jl:39\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpta_7zug_.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpta_7zug_.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpta_7zug_.jl:41\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpta_7zug_.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpta_7zug_.jl:34\ntest set: Test Failed at /tmp/tmpta_7zug_.jl:44\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    str1 = lst[1]\n    str2 = lst[2]\n    str3 = str1 * str2\n    if isbalanced(str3)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpxit2_1lr.jl:29

    '
  stdout: "test set: Error During Test at /tmp/tmpxit2_1lr.jl:32\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpxit2_1lr.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxit2_1lr.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxit2_1lr.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpxit2_1lr.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpxit2_1lr.jl:21\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxit2_1lr.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxit2_1lr.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpxit2_1lr.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpxit2_1lr.jl:21\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxit2_1lr.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxit2_1lr.jl:31\ntest set:\
    \ Error During Test at /tmp/tmpxit2_1lr.jl:35\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpxit2_1lr.jl:21\n   [2] macro expansion"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if !is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if is_good(s1) && !is_good(s2)\n        return \"Yes\"\n    end\n    if !is_good(s1)\
    \ && is_good(s2)\n        return \"Yes\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpp6twkr1p.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpp6twkr1p.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpp6twkr1p.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp6twkr1p.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp6twkr1p.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpp6twkr1p.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpp6twkr1p.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp6twkr1p.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp6twkr1p.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpp6twkr1p.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpp6twkr1p.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp6twkr1p.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp6twkr1p.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpp6twkr1p.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpp6twkr1p.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \"(\" && s2 == \")\"\n        return\
    \ \"Yes\"\n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n   \
    \ elseif s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1 ==\
    \ \")\" && s2 == \")\"\n        return \"Yes\"\n    else\n        return \"No\"\
    \n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyf_f6dnr.jl:33

    '
  stdout: "test set: Test Failed at /tmp/tmpyf_f6dnr.jl:36\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyf_f6dnr.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyf_f6dnr.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpyf_f6dnr.jl:37\n  Expression: candidate([\")\", \")\"]) ==\
    \ \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyf_f6dnr.jl:37 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyf_f6dnr.jl:35\ntest set: Test Failed at /tmp/tmpyf_f6dnr.jl:39\n\
    \  Expression: candidate([\")())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyf_f6dnr.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyf_f6dnr.jl:35\ntest set: Test\
    \ Failed at /tmp/tmpyf_f6dnr.jl:40\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpyf_f6dnr.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpyf_f6dnr.jl:35\ntest set: Test Failed at /tmp/tmpyf_f6dnr.jl:42\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp0typ31rv.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp0typ31rv.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \")\" || s2 == \")\"\n        return \"No\"\
    \n    end\n    s = s1 * s2\n    if s[1] == \")\" || s[end] == \"(\"\n        return\
    \ \"No\"\n    end\n    cnt = 0\n    for i in s\n        if i == \"(\"\n      \
    \      cnt += 1\n        else\n            cnt -= 1\n        end\n        if cnt\
    \ < 0\n            return \"No\"\n        end\n    end\n    if cnt == 0\n    \
    \    return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1vtqip3n.jl:45

    '
  stdout: "test set: Test Failed at /tmp/tmp1vtqip3n.jl:48\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1vtqip3n.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1vtqip3n.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp1vtqip3n.jl:51\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1vtqip3n.jl:51 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1vtqip3n.jl:47\ntest set: Test Failed at /tmp/tmp1vtqip3n.jl:52\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1vtqip3n.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1vtqip3n.jl:47\ntest set: Test\
    \ Failed at /tmp/tmp1vtqip3n.jl:54\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp1vtqip3n.jl:54 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp1vtqip3n.jl:47\ntest set: Test Failed at /tmp/tmp1vtqip3n.jl:58\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # Your code here\n    return \"No\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp8mngqm_g.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmp8mngqm_g.jl:26\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8mngqm_g.jl:26 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8mngqm_g.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp8mngqm_g.jl:29\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8mngqm_g.jl:29 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8mngqm_g.jl:25\ntest set: Test Failed at /tmp/tmp8mngqm_g.jl:30\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp8mngqm_g.jl:30 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp8mngqm_g.jl:25\ntest set: Test\
    \ Failed at /tmp/tmp8mngqm_g.jl:32\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp8mngqm_g.jl:32 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp8mngqm_g.jl:25\ntest set: Test Failed at /tmp/tmp8mngqm_g.jl:36\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1)\n        return \"No\"\n    end\n    if is_good(s2)\n\
    \        return \"No\"\n    end\n    if count_open(s1) == count_open(s2)\n   \
    \     return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpvo9fs7cx.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmpvo9fs7cx.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpvo9fs7cx.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvo9fs7cx.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvo9fs7cx.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvo9fs7cx.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvo9fs7cx.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvo9fs7cx.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvo9fs7cx.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvo9fs7cx.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvo9fs7cx.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvo9fs7cx.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvo9fs7cx.jl:37\ntest set:\
    \ Error During Test at /tmp/tmpvo9fs7cx.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpvo9fs7cx.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] != ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] != '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb3fte722.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb3fte722.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:50\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code goes here\n    return \"Yes\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpz9us7mh4.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpz9us7mh4.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz9us7mh4.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz9us7mh4.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpz9us7mh4.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz9us7mh4.jl:28 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpz9us7mh4.jl:25\ntest set: Test Failed at /tmp/tmpz9us7mh4.jl:31\n\
    \  Expression: candidate([\"()\", \"())\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpz9us7mh4.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpz9us7mh4.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpz9us7mh4.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpz9us7mh4.jl:33 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpz9us7mh4.jl:25\ntest set: Test Failed at /tmp/tmpz9us7mh4.jl:34\n\
    \  Expression: candidate([\")(()\", \"(()(\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] != ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] != '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb3fte722.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb3fte722.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:50\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if s[1] == ')' || s[end] == '('\n \
    \       return \"No\"\n    end\n    n = length(s)\n    count = 0\n    for i in\
    \ 1:n\n        if s[i] == '('\n            count += 1\n        else\n        \
    \    count -= 1\n        end\n        if count < 0\n            return \"No\"\n\
    \        end\n    end\n    if count == 0\n        return \"Yes\"\n    else\n \
    \       return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpfbc0m88o.jl:43

    '
  stdout: "test set: Test Failed at /tmp/tmpfbc0m88o.jl:49\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfbc0m88o.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfbc0m88o.jl:45\ntest set: Test\
    \ Failed at /tmp/tmpfbc0m88o.jl:50\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpfbc0m88o.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpfbc0m88o.jl:45\ntest set: Test Failed at /tmp/tmpfbc0m88o.jl:57\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpfbc0m88o.jl:57 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpfbc0m88o.jl:45\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '('\n        if s2[end] == ')'\n        \
    \    return match_parens([s1[2:end], s2[1:end-1]])\n        else\n           \
    \ return match_parens([s1[2:end], s2])\n        end\n    elseif s1[1] == ')'\n\
    \        if s2[end] == '('\n            return match_parens([s1[2:end], s2[1:end-1]])\n\
    \        else\n            return match_parens([s1[2:end], s2])\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpblrg12ps.jl:41

    '
  stdout: "test set: Test Failed at /tmp/tmpblrg12ps.jl:44\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpblrg12ps.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpblrg12ps.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpblrg12ps.jl:47\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpblrg12ps.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpblrg12ps.jl:43\ntest set: Test Failed at /tmp/tmpblrg12ps.jl:48\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpblrg12ps.jl:48 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpblrg12ps.jl:43\ntest set: Test\
    \ Failed at /tmp/tmpblrg12ps.jl:50\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpblrg12ps.jl:50 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpblrg12ps.jl:43\ntest set: Test Failed at /tmp/tmpblrg12ps.jl:53\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    if count(x -> x == ')', s1) > count(x -> x == '(', s1)\n      \
    \  s1, s2 = s2, s1\n    end\n    if count(x -> x == ')', s2) > count(x -> x ==\
    \ '(', s2)\n        return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpv_it7qhm.jl:32

    '
  stdout: "test set: Test Failed at /tmp/tmpv_it7qhm.jl:35\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv_it7qhm.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv_it7qhm.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpv_it7qhm.jl:38\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv_it7qhm.jl:38 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv_it7qhm.jl:34\ntest set: Test Failed at /tmp/tmpv_it7qhm.jl:39\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv_it7qhm.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv_it7qhm.jl:34\ntest set: Test\
    \ Failed at /tmp/tmpv_it7qhm.jl:41\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv_it7qhm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv_it7qhm.jl:34\ntest set: Test Failed at /tmp/tmpv_it7qhm.jl:42\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/s"
  timestamp: 1659794416
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if count(s, '(') != count(s, ')')\n\
    \        return \"No\"\n    end\n    c = 0\n    for i in s\n        if i == '('\n\
    \            c += 1\n        else\n            c -= 1\n        end\n        if\
    \ c < 0\n            return \"No\"\n        end\n    end\n    return \"Yes\"\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpbu311kgw.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpbu311kgw.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpbu311kgw.jl:20\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpbu311kgw.jl:41 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpbu311kgw.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpbu311kgw.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpbu311kgw.jl:20\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpbu311kgw.jl:42 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpbu311kgw.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpbu311kgw.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s2[end] == ')'\n        return match_parens([s1, s2[1:end-1]])\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpddgzggdp.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpddgzggdp.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:44\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:48\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if is_good(s1) && is_good(s2)\n        return\
    \ \"Yes\"\n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n\
    \    end\n    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpnjqnsb9k.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmpnjqnsb9k.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpnjqnsb9k.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnjqnsb9k.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnjqnsb9k.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpnjqnsb9k.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpnjqnsb9k.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnjqnsb9k.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnjqnsb9k.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpnjqnsb9k.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpnjqnsb9k.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpnjqnsb9k.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpnjqnsb9k.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpnjqnsb9k.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpnjqnsb9k.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n  \
    \      else\n            return match_parens([lst[1][2:end], lst[2]])\n      \
    \  end\n    else\n        if lst[2][1] == ')'\n            return match_parens([lst[1],\
    \ lst[2][2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5kh6wll0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5kh6wll0.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s1, ')') && count(s2, '(')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpk8ez4ehu.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpk8ez4ehu.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpk8ez4ehu.jl:19\n   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpk8ez4ehu.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpk8ez4ehu.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpk8ez4ehu.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpk8ez4ehu.jl:19\n\
    \   [5] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpk8ez4ehu.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpk8ez4ehu.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpk8ez4ehu.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \"(\" && s2 == \")\"\n        return\
    \ \"Yes\"\n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n   \
    \ elseif s1 == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"\
    (\" && s2 == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpvoc0rf9y.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpvoc0rf9y.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvoc0rf9y.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvoc0rf9y.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpvoc0rf9y.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpvoc0rf9y.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpvoc0rf9y.jl:26\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpvoc0rf9y.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n    elseif\
    \ lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb0ju71sq.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb0ju71sq.jl:40\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb0ju71sq.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test Failed at /tmp/tmpb0ju71sq.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb0ju71sq.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test Failed at /tmp/tmpb0ju71sq.jl:46\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # Your code here\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpgnhdvqlf.jl:22

    '
  stdout: "test set: Error During Test at /tmp/tmpgnhdvqlf.jl:25\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpgnhdvqlf.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgnhdvqlf.jl:25 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpgnhdvqlf.jl:24\ntest set:\
    \ Error During Test at /tmp/tmpgnhdvqlf.jl:26\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: Cannot `convert` an object\
    \ of type Nothing to an object of type String\n  Closest candidates are:\n   \
    \ convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpgnhdvqlf.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpgnhdvqlf.jl:26 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n    elseif\
    \ lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb0ju71sq.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb0ju71sq.jl:40\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb0ju71sq.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test Failed at /tmp/tmpb0ju71sq.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb0ju71sq.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test Failed at /tmp/tmpb0ju71sq.jl:46\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '(' && s2[end] == ')'\n        return match_parens([s1[2:end],\
    \ s2[1:end-1]])\n    elseif s1[1] == ')' && s2[end] == '('\n        return match_parens([s1[2:end],\
    \ s2[1:end-1]])\n    elseif s1[1] == '(' && s2[end] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s1[1] == ')' && s2[end] == ')'\n        return match_parens([s1[2:end],\
    \ s2])\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmplq3twbaf.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmplq3twbaf.jl:42\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test\
    \ Failed at /tmp/tmplq3twbaf.jl:45\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test Failed at /tmp/tmplq3twbaf.jl:46\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test\
    \ Failed at /tmp/tmplq3twbaf.jl:48\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmplq3twbaf.jl:48 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmplq3twbaf.jl:41\ntest set: Test Failed at /tmp/tmplq3twbaf.jl:51\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794413
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    str1 = lst[1]\n    str2 = lst[2]\n    if str1 == \"\" && str2 == \"\"\n\
    \        return \"Yes\"\n    elseif str1 == \"\"\n        if str2[1] == '('\n\
    \            return \"No\"\n        else\n            return match_parens([\"\"\
    , str2[2:end]])\n        end\n    elseif str2 == \"\"\n        if str1[1] == ')'\n\
    \            return \"No\"\n        else\n            return match_parens([str1[2:end],\
    \ \"\"])\n        end\n    else\n        if str1[1] == '('\n            return\
    \ match_parens([str1[2:end], str2])\n        elseif str2[1] == ')'\n         \
    \   return match_parens([str1, str2[2:end]])\n        else\n            return\
    \ \"No\"\n        end\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp468yl27a.jl:46

    '
  stdout: "test set: Test Failed at /tmp/tmp468yl27a.jl:49\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp468yl27a.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp468yl27a.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp468yl27a.jl:52\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp468yl27a.jl:52 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp468yl27a.jl:48\ntest set: Test Failed at /tmp/tmp468yl27a.jl:53\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp468yl27a.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp468yl27a.jl:48\ntest set: Test\
    \ Failed at /tmp/tmp468yl27a.jl:55\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp468yl27a.jl:55 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp468yl27a.jl:48\ntest set: Test Failed at /tmp/tmp468yl27a.jl:60\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s2[end] == ')'\n        return match_parens([s1, s2[1:end-1]])\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpddgzggdp.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpddgzggdp.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:44\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:48\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if (count(x -> x == '(', s1) + count(x -> x == '(',\
    \ s2)) ==\n        (count(x -> x == ')', s1) + count(x -> x == ')', s2))\n   \
    \     return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmptfoqase1.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmptfoqase1.jl:40\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmptfoqase1.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmptfoqase1.jl:30\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n  \
    \      else\n            return match_parens([lst[1][2:end], lst[2]])\n      \
    \  end\n    else\n        if lst[2][1] == ')'\n            return match_parens([lst[1],\
    \ lst[2][2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5kh6wll0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5kh6wll0.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    s = s1 * s2\n    if count(x -> x == ')', s) > count(x -> x == '(',\
    \ s)\n        return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9soy8jtm.jl:30

    '
  stdout: "test set: Test Failed at /tmp/tmp9soy8jtm.jl:40\n  Expression: candidate([\"\
    ((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9soy8jtm.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9soy8jtm.jl:32\ntest set: Test\
    \ Failed at /tmp/tmp9soy8jtm.jl:41\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9soy8jtm.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9soy8jtm.jl:32\ntest set: Test Failed at /tmp/tmp9soy8jtm.jl:42\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9soy8jtm.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9soy8jtm.jl:32\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if is_good(lst[1])\n        return\
    \ \"Yes\"\n    end\n    # check if the second string is good\n    if is_good(lst[2])\n\
    \        return \"Yes\"\n    end\n    # check if the concatenation of the two\
    \ strings is good\n    if is_good(lst[1] * lst[2])\n        return \"Yes\"\n \
    \   end\n    # check if the concatenation of the two strings in reverse order\
    \ is good\n    if is_good(lst[2] * lst[1])\n        return \"Yes\"\n    end\n\
    \    return \"No\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp6a5n85hf.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmp6a5n85hf.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp6a5n85hf.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6a5n85hf.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6a5n85hf.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp6a5n85hf.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp6a5n85hf.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6a5n85hf.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6a5n85hf.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp6a5n85hf.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp6a5n85hf.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp6a5n85hf.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp6a5n85hf.jl:40\ntest set:\
    \ Error During Test at /tmp/tmp6a5n85hf.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp6a5n85hf.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the two strings can be concatenated to form a good string\n\
    \    # if yes, return \"Yes\", otherwise return \"No\"\n    # your code here\n\
    \    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n\
    \        if count(x -> x == '(', s2) == count(x -> x == ')', s2)\n           \
    \ return \"Yes\"\n        else\n            return \"No\"\n        end\n    else\n\
    \        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp34vnlx9z.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmp34vnlx9z.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp34vnlx9z.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34vnlx9z.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp34vnlx9z.jl:40\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp34vnlx9z.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp34vnlx9z.jl:36\ntest set: Test Failed at /tmp/tmp34vnlx9z.jl:41\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp34vnlx9z.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp34vnlx9z.jl:36\ntest set: Test\
    \ Failed at /tmp/tmp34vnlx9z.jl:43\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp34vnlx9z.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp34vnlx9z.jl:36\ntest set: Test Failed at /tmp/tmp34vnlx9z.jl:46\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Te"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] == '('\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    elseif lst[1][1]\
    \ == ')' && lst[2][1] == '('\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp29kw_862.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp29kw_862.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29kw_862.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test Failed at /tmp/tmp29kw_862.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp29kw_862.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp29kw_862.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp29kw_862.jl:38\ntest set: Test Failed at /tmp/tmp29kw_862.jl:50\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    s = s1 * s2\n    if is_good(s)\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpuququnz0.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpuququnz0.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpuququnz0.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuququnz0.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuququnz0.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpuququnz0.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpuququnz0.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuququnz0.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuququnz0.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpuququnz0.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpuququnz0.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpuququnz0.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpuququnz0.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpuququnz0.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpuququnz0.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if !is_good(lst[1])\n       \
    \ return \"No\"\n    end\n    # check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    # check if the concatenation of the two strings in reverse order is good\n\
    \    if !is_good(lst[2] * lst[1])\n        return \"No\"\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpxijkp0fs.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpxijkp0fs.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpxijkp0fs.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxijkp0fs.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxijkp0fs.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpxijkp0fs.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpxijkp0fs.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxijkp0fs.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxijkp0fs.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpxijkp0fs.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpxijkp0fs.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpxijkp0fs.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpxijkp0fs.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpxijkp0fs.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpxijkp0fs.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    closed_parens = 0\n    for s in lst\n        for\
    \ c in s\n            if c == '('\n                open_parens += 1\n        \
    \    elseif c == ')'\n                closed_parens += 1\n            end\n  \
    \      end\n    end\n    if open_parens == closed_parens\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpkw2bg2wj.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmpkw2bg2wj.jl:49\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpkw2bg2wj.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpkw2bg2wj.jl:39\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    open_parens = 0\n    close_parens = 0\n    for i in lst[1]\n        if\
    \ i == '('\n            open_parens += 1\n        else\n            close_parens\
    \ += 1\n        end\n    end\n    for i in lst[2]\n        if i == '('\n     \
    \       open_parens += 1\n        else\n            close_parens += 1\n      \
    \  end\n    end\n    if open_parens == close_parens\n        return \"Yes\"\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 11 passed, 1 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmgo2s9m2.jl:42

    '
  stdout: "test set: Test Failed at /tmp/tmpmgo2s9m2.jl:54\n  Expression: candidate([\"\
    )(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmgo2s9m2.jl:54 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmgo2s9m2.jl:44\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |   11     1     12\n"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) > 0\n        return \"No\"\n\
    \    elseif length(lst[1]) > 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif length(lst[1]) > 0 && length(lst[2]) > 0\n        if lst[1][1] ==\
    \ '(' && lst[2][1] == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n\
    \        elseif lst[1][1] == '(' && lst[2][1] == '('\n            return match_parens([lst[1][2:end],\
    \ lst[2]])\n        elseif lst[1][1] == ')' && lst[2][1] == ')'\n            return\
    \ match_parens([lst[1], lst[2][2:end]])\n        elseif lst[1][1] == ')' && lst[2][1]\
    \ == '('\n            return match_parens([lst[1], lst[2][2:end]])\n        end\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpdlgxefgq.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpdlgxefgq.jl:41\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdlgxefgq.jl:41 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdlgxefgq.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdlgxefgq.jl:44\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdlgxefgq.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdlgxefgq.jl:40\ntest set: Test Failed at /tmp/tmpdlgxefgq.jl:45\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpdlgxefgq.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpdlgxefgq.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpdlgxefgq.jl:47\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpdlgxefgq.jl:47 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpdlgxefgq.jl:40\ntest set: Test Failed at /tmp/tmpdlgxefgq.jl:52\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    if is_good(s)\n        return \"Yes\"\
    \n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp0typ31rv.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmp0typ31rv.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp0typ31rv.jl:20\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp0typ31rv.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp0typ31rv.jl:30\ntest set:\
    \ Error During Test at /tmp/tmp0typ31rv.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp0typ31rv.jl:20\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmhph5jfv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpmhph5jfv.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:31\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:34\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] == '('\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp9n8d09q_.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmp9n8d09q_.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9n8d09q_.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9n8d09q_.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp9n8d09q_.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9n8d09q_.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9n8d09q_.jl:38\ntest set: Test Failed at /tmp/tmp9n8d09q_.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp9n8d09q_.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp9n8d09q_.jl:38\ntest set: Test\
    \ Failed at /tmp/tmp9n8d09q_.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmp9n8d09q_.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmp9n8d09q_.jl:38\ntest set: Test Failed at /tmp/tmp9n8d09q_.jl:50\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"\" && s2 == \"\"\n        return \"Yes\"\n\
    \    elseif s1 == \"\"\n        return \"No\"\n    elseif s2 == \"\"\n       \
    \ return \"No\"\n    elseif s1[1] == '('\n        return match_parens([s1[2:end],\
    \ s2])\n    elseif s2[end] == ')'\n        return match_parens([s1, s2[1:end-1]])\n\
    \    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpddgzggdp.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpddgzggdp.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpddgzggdp.jl:44\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpddgzggdp.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpddgzggdp.jl:37\ntest set: Test Failed at /tmp/tmpddgzggdp.jl:48\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794414
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == ')', s1) + count(x -> x == ')', s2)\
    \ > count(x -> x == '(', s1) + count(x -> x == '(', s2)\n        return \"No\"\
    \n    end\n    if count(x -> x == ')', s1) > count(x -> x == '(', s1)\n      \
    \  return \"No\"\n    end\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpvnklx5vf.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpvnklx5vf.jl:35\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvnklx5vf.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvnklx5vf.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpvnklx5vf.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvnklx5vf.jl:36 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvnklx5vf.jl:31\ntest set: Test Failed at /tmp/tmpvnklx5vf.jl:39\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpvnklx5vf.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpvnklx5vf.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpvnklx5vf.jl:40\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpvnklx5vf.jl:40 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpvnklx5vf.jl:31\ntest set: Test Failed at /tmp/tmpvnklx5vf.jl:41\n\
    \  Expression: candidate([\")(\", \")(\"]) == \"No\"\n   Evaluated: \"Yes\" ==\
    \ \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n    elseif\
    \ lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == ')' && lst[2][1] == '('\n        return\
    \ \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb0ju71sq.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb0ju71sq.jl:40\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb0ju71sq.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test Failed at /tmp/tmpb0ju71sq.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb0ju71sq.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpb0ju71sq.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpb0ju71sq.jl:38\ntest set: Test Failed at /tmp/tmpb0ju71sq.jl:46\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794417
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1[1] == ')' || s2[1] == ')'\n       \
    \ return \"No\"\n    end\n    if s1[end] == '(' || s2[end] == '('\n        return\
    \ \"No\"\n    end\n    if count(x -> x == '(', s1) == count(x -> x == ')', s1)\n\
    \        return \"Yes\"\n    end\n    if count(x -> x == '(', s2) == count(x ->\
    \ x == ')', s2)\n        return \"Yes\"\n    end\n    return \"No\"\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpxtyzkry6.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmpxtyzkry6.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxtyzkry6.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxtyzkry6.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpxtyzkry6.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxtyzkry6.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxtyzkry6.jl:37\ntest set: Test Failed at /tmp/tmpxtyzkry6.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpxtyzkry6.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpxtyzkry6.jl:37\ntest set: Test\
    \ Failed at /tmp/tmpxtyzkry6.jl:43\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpxtyzkry6.jl:43 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpxtyzkry6.jl:37\ntest set: Test Failed at /tmp/tmpxtyzkry6.jl:44\n\
    \  Expression: candidate([\"(()(\", \"()))()\"]) == \"Yes\"\n   Evaluated: \"\
    No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/T"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \")\" || s2 == \")\"\n        return \"No\"\
    \n    end\n    if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n    end\n\
    \    if s1 == \"(\"\n        return \"Yes\"\n    end\n    if s2 == \"(\"\n   \
    \     return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmphgt3grhp.jl:35

    '
  stdout: "test set: Test Failed at /tmp/tmphgt3grhp.jl:38\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphgt3grhp.jl:38 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphgt3grhp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmphgt3grhp.jl:41\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphgt3grhp.jl:41 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphgt3grhp.jl:37\ntest set: Test Failed at /tmp/tmphgt3grhp.jl:42\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmphgt3grhp.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmphgt3grhp.jl:37\ntest set: Test\
    \ Failed at /tmp/tmphgt3grhp.jl:44\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmphgt3grhp.jl:44 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmphgt3grhp.jl:37\ntest set: Test Failed at /tmp/tmphgt3grhp.jl:48\n\
    \  Expression: candidate([\"(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Tes"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if !is_good(lst[1])\n       \
    \ return \"No\"\n    end\n    # check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp2b5b6o6u.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp2b5b6o6u.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp2b5b6o6u.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2b5b6o6u.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2b5b6o6u.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp2b5b6o6u.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2b5b6o6u.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2b5b6o6u.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2b5b6o6u.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp2b5b6o6u.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp2b5b6o6u.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp2b5b6o6u.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp2b5b6o6u.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp2b5b6o6u.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp2b5b6o6u.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \")\" || s2 == \")\" || s1 == \"\
    (\" && s2 == \"(\"\n        return \"No\"\n    end\n    if s1 == \"(\" && s2 ==\
    \ \")\"\n        return \"Yes\"\n    end\n    if s1 == \"(\"\n        return match_parens([s1[2:end],\
    \ s2])\n    end\n    if s2 == \")\"\n        return match_parens([s1, s2[2:end]])\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpp91o3ff1.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpp91o3ff1.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpp91o3ff1.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpp91o3ff1.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpp91o3ff1.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpp91o3ff1.jl:29\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpp91o3ff1.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpp91o3ff1.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpp91o3ff1.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.c"
  timestamp: 1659794420
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1][2:end], lst[2][2:end]])\n    elseif\
    \ lst[1][1] == '(' && lst[2][1] == '('\n        return match_parens([lst[1][2:end],\
    \ lst[2]])\n    elseif lst[1][1] == ')' && lst[2][1] == ')'\n        return match_parens([lst[1],\
    \ lst[2][2:end]])\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpya9uxynr.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpya9uxynr.jl:40\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpya9uxynr.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpya9uxynr.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpya9uxynr.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpya9uxynr.jl:42 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpya9uxynr.jl:38\ntest set: Test Failed at /tmp/tmpya9uxynr.jl:43\n\
    \  Expression: candidate([\"(())))\", \"(()())((\"]) == \"Yes\"\n   Evaluated:\
    \ \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpya9uxynr.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpya9uxynr.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpya9uxynr.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpya9uxynr.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpya9uxynr.jl:38\ntest set: Test Failed at /tmp/tmpya9uxynr.jl:46\n\
    \  Expression: candidate([\"((((\", \"((())\"]) == \"No\"\n   Evaluated: \"Yes\"\
    \ == \"No\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if is_good(s1) && is_good(s2)\n        return \"Yes\"\
    \n    end\n    if is_good(s1) && !is_good(s2)\n        return \"No\"\n    end\n\
    \    if !is_good(s1) && is_good(s2)\n        return \"No\"\n    end\n    if !is_good(s1)\
    \ && !is_good(s2)\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp_sbsdao3.jl:34

    '
  stdout: "test set: Error During Test at /tmp/tmp_sbsdao3.jl:37\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:37 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:38\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp_sbsdao3.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp_sbsdao3.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp_sbsdao3.jl:36\ntest set:\
    \ Error During Test at /tmp/tmp_sbsdao3.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp_sbsdao3.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794412
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # Check if the first string is good\n    if !is_good(lst[1])\n       \
    \ return \"No\"\n    end\n    # Check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # Check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    # Check if the concatenation of the two strings in reverse order is good\n\
    \    if !is_good(lst[2] * lst[1])\n        return \"No\"\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpni5kqife.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpni5kqife.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpni5kqife.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpni5kqife.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpni5kqife.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpni5kqife.jl:19\n\
    \   ["
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s = lst[1] * lst[2]\n    cnt = 0\n    for i in 1:length(s)\n        if\
    \ s[i] == '('\n            cnt += 1\n        else\n            cnt -= 1\n    \
    \    end\n        if cnt < 0\n            return \"No\"\n        end\n    end\n\
    \    if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\n  \
    \  end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpj2suj8me.jl:38

    '
  stdout: "test set: Test Failed at /tmp/tmpj2suj8me.jl:44\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj2suj8me.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj2suj8me.jl:40\ntest set: Test\
    \ Failed at /tmp/tmpj2suj8me.jl:45\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpj2suj8me.jl:45 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpj2suj8me.jl:40\ntest set: Test Failed at /tmp/tmpj2suj8me.jl:52\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpj2suj8me.jl:52 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpj2suj8me.jl:40\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794418
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if is_good(s1) && is_good(s2)\n        return\
    \ \"Yes\"\n    end\n    if is_good(s1)\n        return \"No\"\n    end\n    if\
    \ is_good(s2)\n        return \"No\"\n    end\n    if count(s1, '(') == count(s2,\
    \ '(')\n        return \"Yes\"\n    end\n    return \"No\"\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp9la9zrvm.jl:35

    '
  stdout: "test set: Error During Test at /tmp/tmp9la9zrvm.jl:38\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmp9la9zrvm.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9la9zrvm.jl:38 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9la9zrvm.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp9la9zrvm.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp9la9zrvm.jl:19\n\
    \   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9la9zrvm.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9la9zrvm.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp9la9zrvm.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp9la9zrvm.jl:19\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp9la9zrvm.jl:40 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp9la9zrvm.jl:37\ntest set:\
    \ Error During Test at /tmp/tmp9la9zrvm.jl:41\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp9la9zrvm.jl:19\n\
    \   [2] macro expansion\n     @ ~/.c"
  timestamp: 1659794419
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \")\" || s2 == \")\"\n        return\
    \ \"No\"\n    end\n    if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n\
    \    end\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\n    end\n\
    \    if s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    end\n    if s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    end\nend\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmp49qpdmop.jl:37

    '
  stdout: "test set: Test Failed at /tmp/tmp49qpdmop.jl:40\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp49qpdmop.jl:40 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp49qpdmop.jl:39\ntest set: Error\
    \ During Test at /tmp/tmp49qpdmop.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmp49qpdmop.jl:32\n   [2] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmp49qpdmop.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmp49qpdmop.jl:39\ntest set:\
    \ Error During Test at /tmp/tmp49qpdmop.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at ~/.conda/envs/polyglot/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at ~/.conda/envs/polyglot/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at ~/.c"
  timestamp: 1659794415
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    lst = join(lst)\n    open = 0\n    close = 0\n    for i in 1:length(lst)\n\
    \        if lst[i] == '('\n            open += 1\n        else\n            close\
    \ += 1\n        end\n        if close > open\n            return \"No\"\n    \
    \    end\n    end\n    if open == close\n        return \"Yes\"\n    else\n  \
    \      return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpv0gf8tf6.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpv0gf8tf6.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0gf8tf6.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0gf8tf6.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpv0gf8tf6.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445 [inlined]\n\
    \ [2] macro expansion\n   @ /tmp/tmpv0gf8tf6.jl:46 [inlined]\n [3] macro expansion\n\
    \   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283 [inlined]\n\
    \ [4] top-level scope\n   @ /tmp/tmpv0gf8tf6.jl:41\ntest set: Test Failed at /tmp/tmpv0gf8tf6.jl:53\n\
    \  Expression: candidate([\")\", \"(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"\
    Yes\"\nStacktrace:\n [1] macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpv0gf8tf6.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ ~/.conda/envs/polyglot/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpv0gf8tf6.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
  timestamp: 1659794418
