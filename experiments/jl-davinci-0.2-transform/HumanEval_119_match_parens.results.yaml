language: jl
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # check if the first string is good\n    if is_good(lst[1])\n        return\
    \ \"Yes\"\n    end\n    # check if the second string is good\n    if is_good(lst[2])\n\
    \        return \"Yes\"\n    end\n    # check if the concatenation of the two\
    \ strings is good\n    if is_good(lst[1] * lst[2])\n        return \"Yes\"\n \
    \   end\n    # check if the concatenation of the two strings in reverse order\
    \ is good\n    if is_good(lst[2] * lst[1])\n        return \"Yes\"\n    end\n\
    \    # if none of the above is true, then return \"No\"\n    return \"No\"\nend\n\
    using Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmph67ghmro.jl:39

    '
  stdout: "test set: Error During Test at /tmp/tmph67ghmro.jl:42\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmph67ghmro.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph67ghmro.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph67ghmro.jl:41\ntest set:\
    \ Error During Test at /tmp/tmph67ghmro.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmph67ghmro.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph67ghmro.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph67ghmro.jl:41\ntest set:\
    \ Error During Test at /tmp/tmph67ghmro.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmph67ghmro.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmph67ghmro.jl:44 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmph67ghmro.jl:41\ntest set:\
    \ Error During Test at /tmp/tmph67ghmro.jl:45\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmph67ghmro.jl:19\n\
    \   ["
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1)\n        return \"Yes\"\n    elseif count(x -> x == '(', s2) == count(x\
    \ -> x == ')', s2)\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 9 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpyc7lr3hn.jl:29

    '
  stdout: "test set: Test Failed at /tmp/tmpyc7lr3hn.jl:32\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:32 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:35\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:36\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:36 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:37\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpyc7lr3hn.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpyc7lr3hn.jl:31\ntest set: Test\
    \ Failed at /tmp/tmpyc7lr3hn.jl:38\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/j"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0 && length(lst[2]) == 0\n        return \"Yes\"\n\
    \    elseif length(lst[1]) == 0 && length(lst[2]) != 0\n        return \"No\"\n\
    \    elseif length(lst[1]) != 0 && length(lst[2]) == 0\n        return \"No\"\n\
    \    elseif lst[1][1] == '(' && lst[2][1] == ')'\n        return match_parens([lst[1][2:end],\
    \ lst[2][2:end]])\n    elseif lst[1][1] == '(' && lst[2][1] != ')'\n        return\
    \ match_parens([lst[1][2:end], lst[2]])\n    elseif lst[1][1] != '(' && lst[2][1]\
    \ == ')'\n        return match_parens([lst[1], lst[2][2:end]])\n    else\n   \
    \     return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate =\
    \ match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 7 passed, 5 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpb3fte722.jl:36

    '
  stdout: "test set: Test Failed at /tmp/tmpb3fte722.jl:39\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:39 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:42\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:42 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:43\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:43 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:45\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpb3fte722.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpb3fte722.jl:38\ntest set: Test\
    \ Failed at /tmp/tmpb3fte722.jl:50\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/jul"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if count(s1, '(') == count(s1, ')') && count(s2,\
    \ '(') == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmptac3weeo.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmptac3weeo.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmptac3weeo.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmptac3weeo.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmptac3weeo.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmptac3weeo.jl:29\ntest set:\
    \ Error During Test at /tmp/tmptac3weeo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    if length(lst[1]) == 0\n        return \"Yes\"\n    end\n    if length(lst[2])\
    \ == 0\n        return \"Yes\"\n    end\n    if lst[1][1] == '('\n        if lst[2][1]\
    \ == ')'\n            return match_parens([lst[1][2:end], lst[2][2:end]])\n  \
    \      else\n            return match_parens([lst[1][2:end], lst[2]])\n      \
    \  end\n    else\n        if lst[2][1] == ')'\n            return match_parens([lst[1],\
    \ lst[2][2:end]])\n        else\n            return \"No\"\n        end\n    end\n\
    end\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp5kh6wll0.jl:40

    '
  stdout: "test set: Test Failed at /tmp/tmp5kh6wll0.jl:44\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:44 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:46\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:47\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:47 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:49\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp5kh6wll0.jl:49 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp5kh6wll0.jl:42\ntest set: Test\
    \ Failed at /tmp/tmp5kh6wll0.jl:50\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    cnt = 0\n    for i in s\n        if\
    \ i == '('\n            cnt += 1\n        else\n            cnt -= 1\n       \
    \ end\n        if cnt < 0\n            return \"No\"\n        end\n    end\n \
    \   if cnt == 0\n        return \"Yes\"\n    else\n        return \"No\"\n   \
    \ end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpbqlzn9p5.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmpbqlzn9p5.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqlzn9p5.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqlzn9p5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpbqlzn9p5.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqlzn9p5.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqlzn9p5.jl:41\ntest set: Test\
    \ Failed at /tmp/tmpbqlzn9p5.jl:53\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpbqlzn9p5.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpbqlzn9p5.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmhph5jfv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpmhph5jfv.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:31\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:34\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(')\n        return\
    \ \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\n@testset\
    \ begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"\
    Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmp8vp6v6ct.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmp8vp6v6ct.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmp8vp6v6ct.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmp8vp6v6ct.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmp8vp6v6ct.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmp8vp6v6ct.jl:29\ntest set:\
    \ Error During Test at /tmp/tmp8vp6v6ct.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if s1 == \"(\" && s2 == \")\"\n        return \"Yes\"\
    \n    elseif s1 == \")\" && s2 == \"(\"\n        return \"Yes\"\n    elseif s1\
    \ == \")\" && s2 == \")\"\n        return \"No\"\n    elseif s1 == \"(\" && s2\
    \ == \"(\"\n        return \"No\"\n    end\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 3 passed, 0 failed, 9 errored,
    0 broken.

    in expression starting at /tmp/tmpd_9c31cs.jl:31

    '
  stdout: "test set: Error During Test at /tmp/tmpd_9c31cs.jl:34\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:34 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpd_9c31cs.jl:33\ntest set:\
    \ Error During Test at /tmp/tmpd_9c31cs.jl:36\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpd_9c31cs.jl:26\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpd_9c31cs.jl:36 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(s1, '(') == count(s2, '(') && count(s1, ')')\
    \ == count(s2, ')')\n        return \"Yes\"\n    else\n        return \"No\"\n\
    \    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"\
    ()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpt6vc3tkw.jl:27

    '
  stdout: "test set: Error During Test at /tmp/tmpt6vc3tkw.jl:30\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  MethodError: objects\
    \ of type String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String,\
    \ itr::Char, init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String,\
    \ itr::Char; init::Int64)\n     @ Base ./reduce.jl:1201\n   [3] count(f::String,\
    \ itr::Char)\n     @ Base ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n\
    \     @ Main /tmp/tmpt6vc3tkw.jl:19\n   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:30 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:31\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  MethodError: objects of type String are\
    \ not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char, init::Int64)\n\
    \     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char; init::Int64)\n\
    \     @ Base ./reduce.jl:1201\n   [3] count(f::String, itr::Char)\n     @ Base\
    \ ./reduce.jl:1201\n   [4] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpt6vc3tkw.jl:19\n\
    \   [5] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [6] macro expansion\n     @ /tmp/tmpt6vc3tkw.jl:31 [inlined]\n\
    \   [7] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [8] top-level scope\n     @ /tmp/tmpt6vc3tkw.jl:29\ntest set:\
    \ Error During Test at /tmp/tmpt6vc3tkw.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: objects of type\
    \ String are not callable\n  Stacktrace:\n   [1] _simple_count(pred::String, itr::Char,\
    \ init::Int64)\n     @ Base ./reduce.jl:1206\n   [2] count(f::String, itr::Char;\
    \ init::Int64)\n     @ Base ./reduce.jl:1201\n   "
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    str1 = lst[1]\n    str2 = lst[2]\n    if isbalanced(str1) && isbalanced(str2)\n\
    \        return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing\
    \ Test\n\n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpab53_hwo.jl:28

    '
  stdout: "test set: Error During Test at /tmp/tmpab53_hwo.jl:31\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpab53_hwo.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpab53_hwo.jl:31 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpab53_hwo.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpab53_hwo.jl:32\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: isbalanced not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpab53_hwo.jl:20\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpab53_hwo.jl:32 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpab53_hwo.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpab53_hwo.jl:33\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: isbalanced\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpab53_hwo.jl:20\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpab53_hwo.jl:33 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpab53_hwo.jl:30\ntest set:\
    \ Error During Test at /tmp/tmpab53_hwo.jl:34\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: isbalanced not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpab53_hw"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    if count(x -> x == '(', s1) == count(x -> x == ')',\
    \ s1) &&\n        count(x -> x == '(', s2) == count(x -> x == ')', s2)\n     \
    \   return \"Yes\"\n    else\n        return \"No\"\n    end\nend\nusing Test\n\
    \n@testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \"\
    )\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 5 passed, 7 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp84q3crv7.jl:28

    '
  stdout: "test set: Test Failed at /tmp/tmp84q3crv7.jl:31\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:34\n  Expression: candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:34 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:35\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:35 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:37\n  Expression: candidate([\"(()(\", \"()))()\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp84q3crv7.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp84q3crv7.jl:30\ntest set: Test\
    \ Failed at /tmp/tmp84q3crv7.jl:40\n  Expression: candidate([\")(\", \")(\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/ju"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst\n    s = s1 * s2\n    cnt = 0\n    for i in 1:length(s)\n\
    \        if s[i] == '('\n            cnt += 1\n        else\n            cnt -=\
    \ 1\n        end\n        if cnt < 0\n            return \"No\"\n        end\n\
    \    end\n    if cnt == 0\n        return \"Yes\"\n    else\n        return \"\
    No\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\
    \t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"\
    )\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t\
    @test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\"\
    , \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\
    \t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\"\
    , \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\
    \t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 9 passed, 3 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmp1n4qd3wb.jl:39

    '
  stdout: "test set: Test Failed at /tmp/tmp1n4qd3wb.jl:45\n  Expression: candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n\
    \ [1] macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1n4qd3wb.jl:45 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1n4qd3wb.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp1n4qd3wb.jl:46\n  Expression: candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1n4qd3wb.jl:46 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1n4qd3wb.jl:41\ntest set: Test\
    \ Failed at /tmp/tmp1n4qd3wb.jl:53\n  Expression: candidate([\")\", \"(\"]) ==\
    \ \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmp1n4qd3wb.jl:53 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmp1n4qd3wb.jl:41\nTest Summary:\
    \ | Pass  Fail  Total\ntest set      |    9     3     12\n"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s = lst[1] * lst[2]\n    if s == \"\"\n        return \"Yes\"\n    end\n\
    \    if s[1] == ')'\n        return \"No\"\n    end\n    if s[end] == '('\n  \
    \      return \"No\"\n    end\n    if count(x -> x == '(', s) != count(x -> x\
    \ == ')', s)\n        return \"No\"\n    end\n    if count(x -> x == '(', s) ==\
    \ count(x -> x == ')', s) == 0\n        return \"Yes\"\n    end\n    if count(x\
    \ -> x == '(', s) == count(x -> x == ')', s) == 1\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s) == count(x -> x == ')', s) == 2\n      \
    \  return \"Yes\"\n    end\n    if count(x -> x == '(', s) == count(x -> x ==\
    \ ')', s) == 3\n        return \"No\"\n    end\n    if count(x -> x == '(', s)\
    \ == count(x -> x == ')', s) == 4\n        return \"Yes\"\n    end\n    if count(x\
    \ -> x == '(', s) == count(x -> x == ')', s) == 5\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s) == count(x -> x == ')', s) == 6\n      \
    \  return \"Yes\"\n    end\n    if count(x -> x == '(', s) == count(x -> x ==\
    \ ')', s) == 7\n        return \"No\"\n    end\n    if count(x -> x == '(', s)\
    \ == count(x -> x == ')', s) == 8\n        return \"Yes\"\n    end\n    if count(x\
    \ -> x == '(', s) == count(x -> x == ')', s) == 9\n        return \"No\"\n   \
    \ end\n    if count(x -> x == '(', s) == count(x -> x == ')', s) == 10\n     \
    \   return \"Yes\"\n    end\n    if count(x -> x == '(', s) ==\nusing Test\n\n\
    @testset begin\n\ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"\
    ]) == \"Yes\")\n\t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"\
    (()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"])\
    \ == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: "ERROR: LoadError: syntax: incomplete: premature end of input\nStacktrace:\n\
    \ [1] top-level scope\n   @ /tmp/tmph4nsjvdk.jl:1\nin expression starting at /tmp/tmph4nsjvdk.jl:1\n"
  stdout: ''
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # Check if the first string is good\n    if !is_good(lst[1])\n       \
    \ return \"No\"\n    end\n    # Check if the second string is good\n    if !is_good(lst[2])\n\
    \        return \"No\"\n    end\n    # Check if the concatenation of the two strings\
    \ is good\n    if !is_good(lst[1] * lst[2])\n        return \"No\"\n    end\n\
    \    # Check if the concatenation of the two strings in reverse order is good\n\
    \    if !is_good(lst[2] * lst[1])\n        return \"No\"\n    end\n    return\
    \ \"Yes\"\nend\nusing Test\n\n@testset begin\n\ncandidate = match_parens;\n\t\
    @test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \")\"\
    ]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\")\n\t@test(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) == \"No\")\n\t@test(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"((((\", \"((())\"]) ==\
    \ \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\"\
    )(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 0 passed, 0 failed, 12 errored,
    0 broken.

    in expression starting at /tmp/tmpni5kqife.jl:38

    '
  stdout: "test set: Error During Test at /tmp/tmpni5kqife.jl:41\n  Test threw exception\n\
    \  Expression: candidate([\"()(\", \")\"]) == \"Yes\"\n  UndefVarError: is_good\
    \ not defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @\
    \ Main /tmp/tmpni5kqife.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:41 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:42\n  Test threw exception\n  Expression:\
    \ candidate([\")\", \")\"]) == \"No\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpni5kqife.jl:19\n\
    \   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:42 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:43\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  UndefVarError: is_good not\
    \ defined\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpni5kqife.jl:19\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpni5kqife.jl:43 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpni5kqife.jl:40\ntest set:\
    \ Error During Test at /tmp/tmpni5kqife.jl:44\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  UndefVarError: is_good not defined\n\
    \  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main /tmp/tmpni5kqife.jl:19\n\
    \   ["
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    s1, s2 = lst[1], lst[2]\n    if s1 == \")\" || s2 == \")\"\n        return\
    \ \"No\"\n    end\n    if s1 == \"(\" && s2 == \"(\"\n        return \"Yes\"\n\
    \    end\n    if s1 == \"(\"\n        return \"Yes\"\n    end\n    if s2 == \"\
    (\"\n        return \"Yes\"\n    end\nend\nusing Test\n\n@testset begin\n\ncandidate\
    \ = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\t@test(candidate([\"\
    )\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    )\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\")\n\t@test(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"()\", \"())\"]) ==\
    \ \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\")\n\t@test(candidate([\"\
    ((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\")(()\", \"(()(\"]) == \"\
    No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\t@test(candidate([\"(\"\
    , \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 1 passed, 3 failed, 8 errored,
    0 broken.

    in expression starting at /tmp/tmpcobirw77.jl:34

    '
  stdout: "test set: Test Failed at /tmp/tmpcobirw77.jl:37\n  Expression: candidate([\"\
    ()(\", \")\"]) == \"Yes\"\n   Evaluated: \"No\" == \"Yes\"\nStacktrace:\n [1]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpcobirw77.jl:37 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpcobirw77.jl:36\ntest set: Error\
    \ During Test at /tmp/tmpcobirw77.jl:39\n  Test threw exception\n  Expression:\
    \ candidate([\"(()(())\", \"())())\"]) == \"No\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::AbstractString) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:232\n\
    \    ...\n  Stacktrace:\n   [1] match_parens(lst::Vector{String})\n     @ Main\
    \ /tmp/tmpcobirw77.jl:29\n   [2] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n   [3] macro expansion\n     @ /tmp/tmpcobirw77.jl:39 [inlined]\n\
    \   [4] macro expansion\n     @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n   [5] top-level scope\n     @ /tmp/tmpcobirw77.jl:36\ntest set:\
    \ Error During Test at /tmp/tmpcobirw77.jl:40\n  Test threw exception\n  Expression:\
    \ candidate([\")())\", \"(()()(\"]) == \"Yes\"\n  MethodError: Cannot `convert`\
    \ an object of type Nothing to an object of type String\n  Closest candidates\
    \ are:\n    convert(::Type{String}, !Matched::String) at /shared/centos7/julia/1.7.3/share/julia/base/essentials.jl:223\n\
    \    convert(::Type{T}, !Matched::T) where T<:AbstractString at /shared/centos7/julia/1.7.3/share/julia/base/strings/basic.jl:231\n\
    \    convert(::Type{T}, !Matched::Ab"
- exit_code: 1
  program: "\"\"\"\n    You are given a list of two strings, both strings consist\
    \ of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is\
    \ to check if it is possible to concatenate the two strings in\n    some order,\
    \ that the resulting string will be good.\n    A string S is considered to be\
    \ good if and only if all parentheses in S\n    are balanced. For example: the\
    \ string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes'\
    \ if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n\
    \    >>> match_parens([\"()(\", \")\"])\n    \"Yes\"\n    >>> match_parens([\"\
    )\", \")\"])\n    \"No\"\n    \"\"\"\nfunction match_parens(lst::Vector{String})::String\
    \ \n    # your code here\n    return \"Yes\"\nend\nusing Test\n\n@testset begin\n\
    \ncandidate = match_parens;\n\t@test(candidate([\"()(\", \")\"]) == \"Yes\")\n\
    \t@test(candidate([\")\", \")\"]) == \"No\")\n\t@test(candidate([\"(()(())\",\
    \ \"())())\"]) == \"No\")\n\t@test(candidate([\")())\", \"(()()(\"]) == \"Yes\"\
    )\n\t@test(candidate([\"(())))\", \"(()())((\"]) == \"Yes\")\n\t@test(candidate([\"\
    ()\", \"())\"]) == \"No\")\n\t@test(candidate([\"(()(\", \"()))()\"]) == \"Yes\"\
    )\n\t@test(candidate([\"((((\", \"((())\"]) == \"No\")\n\t@test(candidate([\"\
    )(()\", \"(()(\"]) == \"No\")\n\t@test(candidate([\")(\", \")(\"]) == \"No\")\n\
    \t@test(candidate([\"(\", \")\"]) == \"Yes\")\n\t@test(candidate([\")\", \"(\"\
    ]) == \"Yes\")\nend\n"
  status: SyntaxError
  stderr: 'ERROR: LoadError: Some tests did not pass: 6 passed, 6 failed, 0 errored,
    0 broken.

    in expression starting at /tmp/tmpmhph5jfv.jl:23

    '
  stdout: "test set: Test Failed at /tmp/tmpmhph5jfv.jl:27\n  Expression: candidate([\"\
    )\", \")\"]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro\
    \ expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:27 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:28\n  Expression: candidate([\"(()(())\", \"())())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:28 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:31\n  Expression: candidate([\"()\", \"())\"])\
    \ == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:31 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:33\n  Expression: candidate([\"((((\", \"((())\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:445\
    \ [inlined]\n [2] macro expansion\n   @ /tmp/tmpmhph5jfv.jl:33 [inlined]\n [3]\
    \ macro expansion\n   @ /shared/centos7/julia/1.7.3/share/julia/stdlib/v1.7/Test/src/Test.jl:1283\
    \ [inlined]\n [4] top-level scope\n   @ /tmp/tmpmhph5jfv.jl:25\ntest set: Test\
    \ Failed at /tmp/tmpmhph5jfv.jl:34\n  Expression: candidate([\")(()\", \"(()(\"\
    ]) == \"No\"\n   Evaluated: \"Yes\" == \"No\"\nStacktrace:\n [1] macro expansion\n\
    \   @ /shared/centos7/julia/1.7.3"
