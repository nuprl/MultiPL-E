{
  "name": "HumanEval_99_closest_integer",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n",
  "tests": "unittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long digit_count = 0;\n    long digit_limit = 0;\n    long digit_limit_plus_one = 0;\n    long digit_limit_minus_one = 0;\n    long digit_limit_plus_two = 0;\n    long digit_limit_minus_two = 0;\n    long digit_limit_plus_three = 0;\n    long digit_limit_minus_three = 0;\n    long digit_limit_plus_four = 0;\n    long digit_limit_minus_four = 0;\n    long digit_limit_plus_five = 0;\n    long digit_limit_minus_five = 0;\n    long digit_limit_plus_six = 0;\n    long digit_limit_minus_six = 0;\n    long digit_limit_plus_seven = 0;\n    long digit_limit_minus_seven = 0;\n    long digit_limit_plus_eight = 0;\n    long digit_limit_minus_eight = 0;\n    long digit_limit_plus_nine = 0;\n    long digit_limit_minus_nine = 0;\n    long digit_limit_plus_ten = 0;\n    long digit_limit_minus_ten = 0;\n    long digit_limit_plus_eleven = 0;\n    long digit_limit_minus_eleven = 0;\n    long digit_limit_plus_twelve = 0;\n    long digit_limit_minus_twelve = 0;\n    long digit_limit_plus_thirteen = 0;\n    long digit_limit_minus_thirteen = 0;\n    long digit_limit_plus_fourteen = 0;\n    long digit_limit_minus_fourteen = 0;\n    long digit_limit_plus_fifteen = 0;\n    long digit_limit_minus_fifteen = 0;\n    long digit_limit_plus_sixteen = 0;\n    long digit_limit_minus_sixteen = 0;\n    long digit_limit_plus_seventeen = 0;\n    long digit_limit_minus_seventeen = 0;\n    long digit_limit_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpk644j_ar.d(65): Error: semicolon expected, not `unittest`\n/tmp/tmpk644j_ar.d(65): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk644j_ar.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_diff = 0;\n    long diff_diff_min = 0;\n    long diff_diff_max = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_min\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpp8ni1c0m.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmpp8ni1c0m.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp8ni1c0m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5ebkllec.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp5ebkllec.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ebkllec.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long diff_max = 0;\n    long diff_min = 0;\n    long diff_diff = 0;\n    long diff_diff_max = 0;\n    long diff_diff_min = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpkqrumbfl.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmpkqrumbfl.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkqrumbfl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_int_2;\n    long frac_part_int_3;\n    long frac_part_int_4;\n    long frac_part_int_5;\n    long frac_part_int_6;\n    long frac_part_int_7;\n    long frac_part_int_8;\n    long frac_part_int_9;\n    long frac_part_int_10;\n    long frac_part_int_11;\n    long frac_part_int_12;\n    long frac_part_int_13;\n    long frac_part_int_14;\n    long frac_part_int_15;\n    long frac_part_int_16;\n    long frac_part_int_17;\n    long frac_part_int_18;\n    long frac_part_int_19;\n    long frac_part_int_20;\n    long frac_part_int_21;\n    long frac_part_int_22;\n    long frac_part_int_23;\n    long frac_part_int_24;\n    long frac_part_int_25;\n    long frac_part_int_26;\n    long frac_part_int_27;\n    long frac_part_int_28;\n    long frac_part_int_29;\n    long frac_part_int_30;\n    long frac_part_int_31;\n    long frac_part_int_32;\n    long frac_part_int_33;\n    long frac_part_int_34;\n    long frac_part_int_35;\n    long frac_part_int_36;\n    long frac_part_int_37;\n    long frac_part_int_38;\n    long frac_part_int_39;\n    long frac_part_int_40;\n    long frac_part_int_41;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp8pkjygw4.d(69): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8pkjygw4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    \n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] == '.') {\n            continue;\n        }\n        \n        temp = value[i] - '0';\n        \n        if (i == 0) {\n            min = max = temp;\n        } else {\n            if (temp < min) {\n                min = temp;\n            }\n            if (temp > max) {\n                max = temp;\n            }\n        }\n    }\n    \n    diff = max - min;\n    \n    if (diff == 0) {\n        result = max;\n    } else if (diff > 0) {\n        result = min + 1;\n    } else {\n        result = max - 1;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpxx_9oo7e.d(30): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxx_9oo7e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    \n    if (value.length() == 0)\n        throw new std.exception(\"Empty string\");\n    \n    if (value.length() == 1)\n        result = (long) value.charAt(0);\n    else\n        result = (long) value.charAt(0) - '0';\n    \n    for (int i = 1; i < value.length(); i++)\n    {\n        result = result * 10 + (long) value.charAt(i) - '0';\n    }\n    \n    if (result < 0)\n        result = -result;\n    \n    if (result == 0)\n        result = 1;\n    \n    if (result == 1)\n        result = 0;\n    \n    if (result == 2)\n        result = 1;\n    \n    if (result == 3)\n        result = 2;\n    \n    if (result == 4)\n        result = 3;\n    \n    if (result == 5)\n        result = 4;\n    \n    if (result == 6)\n        result = 5;\n    \n    if (result == 7)\n        result = 6;\n    \n    if (result == 8)\n        result = 7;\n    \n    if (result == 9)\n        result = 8;\n    \n    if (result == 10)\n        result = 9;\n    \n    if (result == 11)\n        result = 10;\n    \n    if (result == 12)\n        result = 11;\n    \n    if (result == 13)\n        result = 12;\n    \n    if (result == 14)\n        result = 13;\n    \n    if (result == 15)\n        result = 14;\n    \n    if (result == 16)\n        result = 15;\n    \n    if (result == 17)\n        result = 16;\n    \n    if (result == 18)\n        result = 17;\n    \n    if (result == 19)\n        result = 18;\n    \n    if (result == 20)\n        result = 19;\n    \n    if (result == 21)\n        result = 20;\n    \n    if (result == 22)\n        result = 21;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpyoivna_4.d(30): Error: C style cast illegal, use `cast(long)value.charAt(0)`\n/tmp/tmpyoivna_4.d(32): Error: C style cast illegal, use `cast(long)value.charAt(0)`\n/tmp/tmpyoivna_4.d(36): Error: C style cast illegal, use `cast(long)value.charAt(i)`\n/tmp/tmpyoivna_4.d(111): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyoivna_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long i = 0;\n    \n    if (value.length() == 0)\n        return 0;\n    \n    if (value[0] == '-')\n    {\n        result = -1;\n        value = value.substr(1);\n    }\n    \n    if (value[0] == '+')\n        value = value.substr(1);\n    \n    if (value[0] == '.')\n        value = value.substr(1);\n    \n    if (value[value.length() - 1] == '.')\n        value = value.substr(0, value.length() - 1);\n    \n    if (value.length() == 0)\n        return 0;\n    \n    if (value.length() == 1)\n        return value[0] - '0';\n    \n    if (value.length() == 2)\n        return value[0] - '0' + 10 * (value[1] - '0');\n    \n    if (value.length() == 3)\n        return value[0] - '0' + 10 * (value[1] - '0') + 100 * (value[2] - '0');\n    \n    if (value.length() == 4)\n        return value[0] - '0' + 10 * (value[1] - '0') + 100 * (value[2] - '0') + 1000 * (value[3] - '0');\n    \n    if (value.length() == 5)\n        return value[0] - '0' + 10 * (value[1] - '0') + 100 * (value[2] - '0') + 1000 * (value[3] - '0') + 10000 * (value[4] - '0');\n    \n    if (value.length() == 6)\n        return value[0] - '0' + 10 * (value[1] - '0') + 100 * (value[2] - '0') + 1000 * (value[3] - '0') + 10000 * (value[4] - '0') + 100000\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp_6va3m7i.d(68): Error: found `unittest` when expecting `;` following `return` statement\n/tmp/tmp_6va3m7i.d(78): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_6va3m7i.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long number_of_digits = 0;\n    long number_of_decimals = 0;\n    long number_of_decimals_to_round = 0;\n    long number_of_decimals_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round_away_from_zero_to_round = 0;\n    long number_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmphzdn37ew.d(40): Error: semicolon expected, not `unittest`\n/tmp/tmphzdn37ew.d(40): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphzdn37ew.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_diff = 0;\n    \n    if (value.length() == 0)\n    {\n        return 0;\n    }\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        if (value[i] == '.')\n        {\n            continue;\n        }\n        \n        if (value[i] == '-')\n        {\n            continue;\n        }\n        \n        if (value[i] < '0' || value[i] > '9')\n        {\n            continue;\n        }\n        \n        result = result * 10 + (value[i] - '0');\n        \n        if (i == 0)\n        {\n            min = result;\n            max = result;\n        }\n        else\n        {\n            if (result < min)\n            {\n                min = result;\n            }\n            \n            if (result > max)\n            {\n                max = result;\n            }\n        }\n    }\n    \n    diff = max - min;\n    diff_min = max - min;\n    diff_max = min - max;\n    diff_diff = diff_max - diff_min;\n    \n    if (diff_diff == 0)\n    {\n        return max;\n    }\n    \n    if (diff_diff < 0)\n    {\n        return max;\n    }\n    \n    if (diff_diff > 0)\n    {\n        return min;\n    }\n    \n    if (diff_min < 0)\n    {\n        return min;\n    }\n    \n    if (diff_min > 0)\n    {\n        return max;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpgofm76et.d(32): Error: no property `length` for type `string`\n/tmp/tmpgofm76et.d(37): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgofm76et.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_distance = 0;\n    long distance = 0;\n    long temp = 0;\n    long temp_distance = 0;\n    long temp_max_distance = 0;\n    long temp_result = 0;\n    long temp_distance_result = 0;\n    long temp_max_distance_result = 0;\n    long temp_result_distance = 0;\n    long temp_max_result_distance = 0;\n    long temp_result_max_distance = 0;\n    long temp_result_distance_max_distance = 0;\n    long temp_result_max_distance_distance = 0;\n    long temp_result_distance_max_distance_distance = 0;\n    long temp_result_max_distance_distance_max_distance = 0;\n    long temp_result_distance_max_distance_distance_max_distance = 0;\n    long temp_result_max_distance_distance_max_distance_distance = 0;\n    long temp_result_distance_max_distance_distance_max_distance_distance = 0;\n    long temp_result_max_distance_distance_max_distance_distance_max_distance = 0;\n    long temp_result_distance_max_distance_distance_max_distance_distance_max_distance = 0;\n    long temp_result_max_distance_distance_max_distance_distance_max_distance_distance = 0;\n    long temp_result_distance_max_distance_distance_max_distance_distance_max_distance_distance = 0;\n    long temp_result_max_distance_distance_max_distance_distance_max_distance_distance_max_distance = 0;\n    long temp_result_distance_max_distance_distance_max_distance_distance_max_distance_distance_max_distance = 0;\n    long temp_result_max_distance_distance_max_distance_distance_max_distance_distance_max_distance_distance = 0;\n    long temp_result_distance_max_distance_distance_max_distance_distance_max_distance_distance_max_distance_distance = 0;\n    long temp_result_max_distance_distance_max_distance_distance_max\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmps5tj2vl6.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmps5tj2vl6.d(52): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps5tj2vl6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_abs_sign_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp494ong90.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmp494ong90.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp494ong90.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long factor = 1;\n    long power = 0;\n    long power_factor = 1;\n    long power_sign = 1;\n    long power_value = 0;\n    long power_value_factor = 1;\n    long power_value_sign = 1;\n    long power_value_value = 0;\n    long power_value_value_factor = 1;\n    long power_value_value_sign = 1;\n    long power_value_value_value = 0;\n    long power_value_value_value_factor = 1;\n    long power_value_value_value_sign = 1;\n    long power_value_value_value_value = 0;\n    long power_value_value_value_value_factor = 1;\n    long power_value_value_value_value_sign = 1;\n    long power_value_value_value_value_value = 0;\n    long power_value_value_value_value_value_factor = 1;\n    long power_value_value_value_value_value_sign = 1;\n    long power_value_value_value_value_value_value = 0;\n    long power_value_value_value_value_value_value_factor = 1;\n    long power_value_value_value_value_value_value_sign = 1;\n    long power_value_value_value_value_value_value_value = 0;\n    long power_value_value_value_value_value_value_value_factor = 1;\n    long power_value_value_value_value_value_value_value_sign = 1;\n    long power_value_value_value_value_value_value_value_value = 0;\n    long power_value_value_value_value_value_value_value_value_factor = 1;\n    long power_value_value_value_value_value_value_value_value_sign = 1;\n    long power_value_value_value_value_value_value_value_value_value = 0;\n    long power_value_value_value_value_value_value_value_value_value_factor\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp8bo_l1yb.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmp8bo_l1yb.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8bo_l1yb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_abs = 0;\n    long exp_abs_sign = 1;\n    long exp_abs_value = 0;\n    long exp_abs_value_sign = 1;\n    long exp_abs_value_int = 0;\n    long exp_abs_value_int_sign = 1;\n    long exp_abs_value_int_value = 0;\n    long exp_abs_value_int_value_sign = 1;\n    long exp_abs_value_int_value_int = 0;\n    long exp_abs_value_int_value_int_sign = 1;\n    long exp_abs_value_int_value_int_value = 0;\n    long exp_abs_value_int_value_int_value_sign = 1;\n    long exp_abs_value_int_value_int_value_int = 0;\n    long exp_abs_value_int_value_int_value_int_sign = 1;\n    long exp_abs_value_int_value_int_value_int_value = 0;\n    long exp_abs_value_int_value_int_value_int_value_sign = 1;\n    long exp_abs_value_int_value_int_value_int_value_int = 0;\n    long exp_abs_value_int_value_int_value_int_value_int_sign = 1;\n    long exp_abs_value_int_value_int_value_int_value_int_value = 0;\n    long exp_abs_value_int_value_int_value_int_value_int_value_sign = 1;\n    long exp_abs_value_int_value_int_value_int_value_int_value_int = 0;\n    long exp_abs_value_int_value_int_value_int_value_int\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp4vh86xvg.d(54): Error: semicolon expected, not `unittest`\n/tmp/tmp4vh86xvg.d(54): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4vh86xvg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_len = 0;\n    long int_part_len = 0;\n    long sign = 1;\n    \n    if (value.length() == 0)\n        return 0;\n    \n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    \n    int_part_len = value.find_first_of('.');\n    if (int_part_len == string::npos) {\n        int_part = atol(value.c_str());\n        frac_part = 0;\n        frac_part_len = 0;\n    } else {\n        int_part = atol(value.substr(0, int_part_len).c_str());\n        frac_part = atol(value.substr(int_part_len + 1).c_str());\n        frac_part_len = value.length() - int_part_len - 1;\n    }\n    \n    if (frac_part_len == 0) {\n        result = int_part;\n    } else {\n        result = int_part + (frac_part * pow(10, frac_part_len));\n    }\n    \n    result = result * sign;\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp2rfa6q9x.d(40): Error: found `:` when expecting `)`\n/tmp/tmp2rfa6q9x.d(40): Error: found `:` instead of statement\n/tmp/tmp2rfa6q9x.d(44): Error: declaration expected, not `else`\n/tmp/tmp2rfa6q9x.d(46): Error: no identifier for declarator `frac_part`\n/tmp/tmp2rfa6q9x.d(46): Error: declaration expected, not `=`\n/tmp/tmp2rfa6q9x.d(47): Error: no identifier for declarator `frac_part_len`\n/tmp/tmp2rfa6q9x.d(47): Error: declaration expected, not `=`\n/tmp/tmp2rfa6q9x.d(48): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2rfa6q9x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_abs = 0;\n    long exp_abs_sign = 1;\n    long exp_abs_value = 0;\n    long exp_abs_value_sign = 1;\n    long exp_abs_value_abs = 0;\n    long exp_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp_mxv2duv.d(54): Error: semicolon expected, not `unittest`\n/tmp/tmp_mxv2duv.d(54): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_mxv2duv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long max_diff = 0;\n    long diff = 0;\n    \n    for(int i = 0; i < value.length(); i++)\n    {\n        number = number * 10 + (value[i] - '0');\n        diff = abs(number - result);\n        if(diff > max_diff)\n        {\n            max_diff = diff;\n            result = number;\n        }\n    }\n    \n    if(max_diff == 0)\n    {\n        result = number;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpekh0_0sb.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpekh0_0sb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp1nmdjx5j.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1nmdjx5j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long int_part_length = 0;\n    long frac_part_length = 0;\n    long int_part_max = 0;\n    long frac_part_max = 0;\n    long int_part_min = 0;\n    long frac_part_min = 0;\n    long int_part_max_length = 0;\n    long frac_part_max_length = 0;\n    long int_part_min_length = 0;\n    long frac_part_min_length = 0;\n    long int_part_max_value = 0;\n    long frac_part_max_value = 0;\n    long int_part_min_value = 0;\n    long frac_part_min_value = 0;\n    long int_part_max_value_length = 0;\n    long frac_part_max_value_length = 0;\n    long int_part_min_value_length = 0;\n    long frac_part_min_value_length = 0;\n    long int_part_max_value_value = 0;\n    long frac_part_max_value_value = 0;\n    long int_part_min_value_value = 0;\n    long frac_part_min_value_value = 0;\n    long int_part_max_value_value_length = 0;\n    long frac_part_max_value_value_length = 0;\n    long int_part_min_value_value_length = 0;\n    long frac_part_min_value_value_length = 0;\n    long int_part_max_value_value_value = 0;\n    long frac_part_max_value_value_value = 0;\n    long int_part_min_value_value_value = 0;\n    long frac_part_min_value_value_value = 0;\n    long int_part_max_value_value_value_length = 0;\n    long frac_part_max_value_value_value_length =\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpyv0lsgqh.d(60): Error: expression expected, not `unittest`\n/tmp/tmpyv0lsgqh.d(61): Error: semicolon expected, not `{`\n/tmp/tmpyv0lsgqh.d(70): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyv0lsgqh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_abs = 0;\n    long exp_abs_sign = 1;\n    long exp_abs_val = 0;\n    long exp_abs_val_sign = 1;\n    long exp_abs_val_val = 0;\n    long exp_abs_val_val_sign = 1;\n    long exp_abs_val_val_val = 0;\n    long exp_abs_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_val_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val_val_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_val_val_val_val_val_sign = 1;\n    long exp_abs_val_val_val_val_val_val_val_val_val_val = 0;\n    long exp_abs_val_val_val_val_val_val_val_val\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpz4mn41zi.d(54): Error: semicolon expected, not `unittest`\n/tmp/tmpz4mn41zi.d(54): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz4mn41zi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5ebkllec.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp5ebkllec.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ebkllec.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    \n    if (value.length() == 0)\n        return 0;\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        if (value[i] == '.')\n            continue;\n        \n        if (value[i] == '-')\n            continue;\n        \n        if (value[i] >= '0' && value[i] <= '9')\n        {\n            temp = value[i] - '0';\n            if (temp < min)\n                min = temp;\n            if (temp > max)\n                max = temp;\n        }\n    }\n    \n    diff = max - min;\n    \n    if (diff == 0)\n        return max;\n    \n    if (diff > 0)\n        result = min + 1;\n    else\n        result = max - 1;\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp23aw_1jg.d(30): Error: no property `length` for type `string`\n/tmp/tmp23aw_1jg.d(33): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp23aw_1jg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_min_max = 0;\n    long diff_min_max_min = 0;\n    long diff_min_max_max = 0;\n    long diff_min_max_min_max = 0;\n    long diff_min_max_min_max_min = 0;\n    long diff_min_max_min_max_max = 0;\n    long diff_min_max_min_max_min_max = 0;\n    long diff_min_max_min_max_min_max_min = 0;\n    long diff_min_max_min_max_min_max_max = 0;\n    long diff_min_max_min_max_min_max_min_max = 0;\n    long diff_min_max_min_max_min_max_min_max_min = 0;\n    long diff_min_max_min_max_min_max_min_max_max = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max_min = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max_max = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max_min_max = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max_min_max_min = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max_min_max_max = 0;\n    long diff_min_max_min_max_min_max_min_max_min_max_min_max_min_max = 0;\n    long diff_min_max_min_max_min_max_min_max_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp6g18ozvh.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmp6g18ozvh.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6g18ozvh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long temp = 0;\n    long power = 1;\n    long temp_power = 1;\n    long temp_sign = 1;\n    long temp_result = 0;\n    long temp_result_sign = 1;\n    long temp_result_power = 1;\n    long temp_result_temp_power = 1;\n    long temp_result_temp_sign = 1;\n    long temp_result_temp_result = 0;\n    long temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpqb9ddqfo.d(55): Error: semicolon expected, not `unittest`\n/tmp/tmpqb9ddqfo.d(55): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqb9ddqfo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long int_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    \nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5kyx2bk9.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5kyx2bk9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    \n    for(int i = 0; i < value.length(); i++)\n    {\n        if(value[i] == '.')\n        {\n            temp = 0;\n            for(int j = i + 1; j < value.length(); j++)\n            {\n                temp = temp * 10 + value[j] - '0';\n            }\n            diff = temp;\n            diff_min = diff;\n            diff_max = diff;\n            i = value.length();\n        }\n        else\n        {\n            temp = temp * 10 + value[i] - '0';\n            if(temp > max)\n            {\n                max = temp;\n            }\n            if(temp < min)\n            {\n                min = temp;\n            }\n        }\n    }\n    if(diff_max == diff_min)\n    {\n        result = max;\n    }\n    else\n    {\n        if(diff_max > diff_min)\n        {\n            result = max;\n        }\n        else\n        {\n            result = min;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpgub2imd2.d(32): Error: no property `length` for type `string`\n/tmp/tmpgub2imd2.d(37): Error: no property `length` for type `string`\n/tmp/tmpgub2imd2.d(44): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgub2imd2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long power = 1;\n    long sign = 1;\n    long exponent = 0;\n    long mantissa = 0;\n    long exponent_sign = 1;\n    long exponent_mantissa = 0;\n    long exponent_exponent = 0;\n    long exponent_exponent_sign = 1;\n    long exponent_exponent_mantissa = 0;\n    long exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_mantissa = 0;\n    long exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_mantissa = 0;\n    long exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_mantissa = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent_mantissa = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_mantissa = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_exponent_mantissa = 0;\n    long exponent_exponent\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpbtm8iaa2.d(54): Error: semicolon expected, not `unittest`\n/tmp/tmpbtm8iaa2.d(54): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbtm8iaa2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpf9jnar94.d(89): Error: no identifier for declarator `long`\n/tmp/tmpf9jnar94.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9jnar94.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long sign = 1;\n    long power = 0;\n    long exponent = 0;\n    long mantissa = 0;\n    long exponent_sign = 1;\n    long exponent_value = 0;\n    long mantissa_sign = 1;\n    long mantissa_value = 0;\n    long mantissa_power = 0;\n    long mantissa_exponent = 0;\n    long mantissa_mantissa = 0;\n    long mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_value = 0;\n    long mantissa_mantissa_power = 0;\n    long mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_value = 0;\n    long mantissa_mantissa_mantissa_power = 0;\n    long mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_mantissa_value = 0;\n    long mantissa_mantissa_mantissa_mantissa_power = 0;\n    long mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_value = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_power = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpc_cay3vk.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmpc_cay3vk.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc_cay3vk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long int_part_temp = 0;\n    long frac_part_temp = 0;\n    long int_part_temp2 = 0;\n    long frac_part_temp2 = 0;\n    long int_part_temp3 = 0;\n    long frac_part_temp3 = 0;\n    long int_part_temp4 = 0;\n    long frac_part_temp4 = 0;\n    long int_part_temp5 = 0;\n    long frac_part_temp5 = 0;\n    long int_part_temp6 = 0;\n    long frac_part_temp6 = 0;\n    long int_part_temp7 = 0;\n    long frac_part_temp7 = 0;\n    long int_part_temp8 = 0;\n    long frac_part_temp8 = 0;\n    long int_part_temp9 = 0;\n    long frac_part_temp9 = 0;\n    long int_part_temp10 = 0;\n    long frac_part_temp10 = 0;\n    long int_part_temp11 = 0;\n    long frac_part_temp11 = 0;\n    long int_part_temp12 = 0;\n    long frac_part_temp12 = 0;\n    long int_part_temp13 = 0;\n    long frac_part_temp13 = 0;\n    long int_part_temp14 = 0;\n    long frac_part_temp14 = 0;\n    long int_part_temp15 = 0;\n    long frac_part_temp15 = 0;\n    long int_part_temp16 = 0;\n    long frac_part_temp16 = 0;\n    long int_part_temp17 = 0;\n    long frac_part_temp17 = 0;\n    long int_part_temp18 = 0;\n    long frac_part_temp18 = 0;\n    long int_part_temp19 = 0;\n    long frac_part_temp19 = 0;\n    long int_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpuk256pu4.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpuk256pu4.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuk256pu4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long power = 1;\n    long power_of_ten = 1;\n    long power_of_ten_minus_1 = 1;\n    long power_of_ten_minus_2 = 1;\n    long power_of_ten_minus_3 = 1;\n    long power_of_ten_minus_4 = 1;\n    long power_of_ten_minus_5 = 1;\n    long power_of_ten_minus_6 = 1;\n    long power_of_ten_minus_7 = 1;\n    long power_of_ten_minus_8 = 1;\n    long power_of_ten_minus_9 = 1;\n    long power_of_ten_minus_10 = 1;\n    long power_of_ten_minus_11 = 1;\n    long power_of_ten_minus_12 = 1;\n    long power_of_ten_minus_13 = 1;\n    long power_of_ten_minus_14 = 1;\n    long power_of_ten_minus_15 = 1;\n    long power_of_ten_minus_16 = 1;\n    long power_of_ten_minus_17 = 1;\n    long power_of_ten_minus_18 = 1;\n    long power_of_ten_minus_19 = 1;\n    long power_of_ten_minus_20 = 1;\n    long power_of_ten_minus_21 = 1;\n    long power_of_ten_minus_22 = 1;\n    long power_of_ten_minus_23 = 1;\n    long power_of_ten_minus_24 = 1;\n    long power_of_ten_minus_25 = 1;\n    long power_of_ten_minus_26 = 1;\n    long power_of_ten_minus_27 = 1;\n    long power_of_ten_minus_28 = 1;\n    long power_of_ten_minus_29 = 1;\n    long power_of_ten_minus_30 = 1;\n    long power_of_ten_minus_31 = 1;\n    long power_of_ten_minus_32 = 1\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp_d5hbd1z.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmp_d5hbd1z.d(60): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_d5hbd1z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long int_part_sign = 1;\n    long frac_part_sign = 1;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_int_sign = 1;\n    long frac_part_frac_sign = 1;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_int_sign = 1;\n    long frac_part_frac_frac_sign = 1;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_int_sign = 1;\n    long frac_part_frac_frac_frac_sign = 1;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int_sign = 1;\n    long frac_part_frac_frac_frac_frac_sign = 1;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int_sign = 1;\n    long frac_part_frac_frac_frac_frac_frac_sign = 1;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int_sign = 1;\n    long frac_part_frac_frac_frac_frac_frac_frac_sign = 1;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpiyt4g0t5.d(55): Error: semicolon expected, not `unittest`\n/tmp/tmpiyt4g0t5.d(55): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiyt4g0t5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long int_part_max = 0;\n    long int_part_min = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmppa9n7ql_.d(70): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppa9n7ql_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long sign = 1;\n    long power = 1;\n    long power_sign = 1;\n    long power_sign_temp = 1;\n    long power_sign_temp_temp = 1;\n    long power_sign_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long power_sign_temp_temp_temp_temp_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpvlf37nkf.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmpvlf37nkf.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvlf37nkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long power_sign = 1;\n    long power_sign_2 = 1;\n    long power_sign_3 = 1;\n    long power_sign_4 = 1;\n    long power_sign_5 = 1;\n    long power_sign_6 = 1;\n    long power_sign_7 = 1;\n    long power_sign_8 = 1;\n    long power_sign_9 = 1;\n    long power_sign_10 = 1;\n    long power_sign_11 = 1;\n    long power_sign_12 = 1;\n    long power_sign_13 = 1;\n    long power_sign_14 = 1;\n    long power_sign_15 = 1;\n    long power_sign_16 = 1;\n    long power_sign_17 = 1;\n    long power_sign_18 = 1;\n    long power_sign_19 = 1;\n    long power_sign_20 = 1;\n    long power_sign_21 = 1;\n    long power_sign_22 = 1;\n    long power_sign_23 = 1;\n    long power_sign_24 = 1;\n    long power_sign_25 = 1;\n    long power_sign_26 = 1;\n    long power_sign_27 = 1;\n    long power_sign_28 = 1;\n    long power_sign_29 = 1;\n    long power_sign_30 = 1;\n    long power_sign_31 = 1;\n    long power_sign_32 = 1;\n    long power_sign_33 = 1;\n    long power_sign_34 = 1;\n    long power_sign_35 = 1;\n    long power_sign_36 = 1;\n    long power_sign_37 = 1;\n    long power_sign_38 = 1;\n    long power_sign_39 = 1;\n    long power_sign_40 = 1;\n    long power_sign_41 = 1;\n    long power_sign_42 = 1;\n    long power_sign_43 = 1;\n    long power_sign_44 = 1;\n    long power_sign_45\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpio8500hs.d(72): Error: semicolon expected, not `unittest`\n/tmp/tmpio8500hs.d(72): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpio8500hs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long int_part_len = 0;\n    long frac_part_len = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmplp8vojta.d(94): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplp8vojta.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_int_2 = 0;\n    long frac_part_int_3 = 0;\n    long frac_part_int_4 = 0;\n    long frac_part_int_5 = 0;\n    long frac_part_int_6 = 0;\n    long frac_part_int_7 = 0;\n    long frac_part_int_8 = 0;\n    long frac_part_int_9 = 0;\n    long frac_part_int_10 = 0;\n    long frac_part_int_11 = 0;\n    long frac_part_int_12 = 0;\n    long frac_part_int_13 = 0;\n    long frac_part_int_14 = 0;\n    long frac_part_int_15 = 0;\n    long frac_part_int_16 = 0;\n    long frac_part_int_17 = 0;\n    long frac_part_int_18 = 0;\n    long frac_part_int_19 = 0;\n    long frac_part_int_20 = 0;\n    long frac_part_int_21 = 0;\n    long frac_part_int_22 = 0;\n    long frac_part_int_23 = 0;\n    long frac_part_int_24 = 0;\n    long frac_part_int_25 = 0;\n    long frac_part_int_26 = 0;\n    long frac_part_int_27 = 0;\n    long frac_part_int_28 = 0;\n    long frac_part_int_29 = 0;\n    long frac_part_int_30 = 0;\n    long frac_part_int_31 = 0;\n    long frac_part_int_32 = 0;\n    long frac_part_int_33 = 0;\n    long frac_part_int_34 = 0;\n    long frac_part_int_35\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7b_ko4h5.d(62): Error: semicolon expected, not `unittest`\n/tmp/tmp7b_ko4h5.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7b_ko4h5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpf9jnar94.d(89): Error: no identifier for declarator `long`\n/tmp/tmpf9jnar94.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9jnar94.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_abs_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long frac_part_sign_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long int_part_sign_sign = 1;\n    long int_part_abs_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign = 1;\n    long int_part_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign = 1;\n    long frac_part_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_sign_sign_sign_sign = 1\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpp6ng19l4.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmpp6ng19l4.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp6ng19l4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long diff = 0;\n    long abs_diff = 0;\n    long abs_max = 0;\n    long abs_min = 0;\n    long abs_diff_min = 0;\n    long abs_diff_max = 0;\n    long abs_diff_min_max = 0;\n    long abs_diff_min_max_step = 0;\n    long abs_diff_min_max_step_diff = 0;\n    long abs_diff_min_max_step_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long abs_diff_min_max_step_diff_diff_diff_diff_diff\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpo9k6zcjc.d(50): Error: semicolon expected, not `unittest`\n/tmp/tmpo9k6zcjc.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo9k6zcjc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long abs_diff = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long int_part_old = 0;\n    long frac_part_old = 0;\n    long int_part_new = 0;\n    long frac_part_new = 0;\n    long int_part_new_old = 0;\n    long frac_part_new_old = 0;\n    long int_part_new_old_old = 0;\n    long frac_part_new_old_old = 0;\n    long int_part_new_old_old_old = 0;\n    long frac_part_new_old_old_old = 0;\n    long int_part_new_old_old_old_old = 0;\n    long frac_part_new_old_old_old_old = 0;\n    long int_part_new_old_old_old_old_old = 0;\n    long frac_part_new_old_old_old_old_old = 0;\n    long int_part_new_old_old_old_old_old_old = 0;\n    long frac_part_new_old_old_old_old_old_old = 0;\n    long int_part_new_old_old_old_old_old_old_old = 0;\n    long frac_part_new_old_old_old_old_old_old_old = 0;\n    long int_part_new_old_old_old_old_old_old_old_old = 0;\n    long frac_part_new_old_old_old_old_old_old_old_old = 0;\n    long int_part_new_old_old_old_old_old_old_old_old_old = 0;\n    long frac_part_new_old_old_old_old_old_old_old_old_old = 0;\n    long int_part_new_old_old_old_old_old_old_old_old_old_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp54v6gvns.d(53): Error: semicolon expected, not `unittest`\n/tmp/tmp54v6gvns.d(53): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp54v6gvns.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    \n    if (value.length() == 0)\n    {\n        return result;\n    }\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        if (value[i] == '.')\n        {\n            continue;\n        }\n        \n        temp = value[i] - '0';\n        \n        if (temp < 0)\n        {\n            temp = temp * -1;\n        }\n        \n        if (result == 0)\n        {\n            result = temp;\n            min = result;\n            max = result;\n        }\n        else\n        {\n            if (temp < min)\n            {\n                min = temp;\n            }\n            else if (temp > max)\n            {\n                max = temp;\n            }\n        }\n    }\n    \n    diff = max - min;\n    \n    if (diff == 0)\n    {\n        return max;\n    }\n    \n    if (diff > 0)\n    {\n        if (result - min > 0)\n        {\n            result = result - min;\n        }\n        else\n        {\n            result = result + min;\n        }\n    }\n    else\n    {\n        if (result - max > 0)\n        {\n            result = result - max;\n        }\n        else\n        {\n            result = result + max;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpfwd7vkzy.d(30): Error: no property `length` for type `string`\n/tmp/tmpfwd7vkzy.d(35): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfwd7vkzy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long int_part_prev = 0;\n    long frac_part_prev = 0;\n    \n    // get the integer part\n    int_part = std.math.floor(std.math.to_double(value));\n    \n    // get the fractional part\n    frac_part = std.math.modf(std.math.to_double(value))[1];\n    \n    // get the difference between the integer part and the fractional part\n    diff = int_part - frac_part;\n    \n    // get the maximum difference between the integer part and the fractional part\n    max_diff = std.math.abs(diff);\n    \n    // if the difference is greater than the maximum difference, return the integer part\n    if(max_diff > max_diff)\n    {\n        result = int_part;\n    }\n    // if the difference is less than the maximum difference, return the fractional part\n    else if(max_diff < max_diff)\n    {\n        result = frac_part;\n    }\n    // if the difference is equal to the maximum difference, return the integer part\n    else if(max_diff == max_diff)\n    {\n        result = int_part;\n    }\n    // if the difference is less than zero, return the integer part\n    else if(diff < 0)\n    {\n        result = int_part;\n    }\n    // if the difference is greater than zero, return the fractional part\n    else if(diff > 0)\n    {\n        result = frac_part;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp43azwe7y.d(33): Error: undefined identifier `to_double` in module `std.math`\n/tmp/tmp43azwe7y.d(36): Error: undefined identifier `to_double` in module `std.math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp43azwe7y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp1xw2r5go.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp1xw2r5go.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1xw2r5go.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long sign = 1;\n    long power = 1;\n    long exponent = 0;\n    long exponent_sign = 1;\n    long exponent_power = 1;\n    long exponent_value = 0;\n    long exponent_value_sign = 1;\n    long exponent_value_power = 1;\n    long exponent_value_value = 0;\n    long exponent_value_value_sign = 1;\n    long exponent_value_value_power = 1;\n    long exponent_value_value_value = 0;\n    long exponent_value_value_value_sign = 1;\n    long exponent_value_value_value_power = 1;\n    long exponent_value_value_value_value = 0;\n    long exponent_value_value_value_value_sign = 1;\n    long exponent_value_value_value_value_power = 1;\n    long exponent_value_value_value_value_value = 0;\n    long exponent_value_value_value_value_value_sign = 1;\n    long exponent_value_value_value_value_value_power = 1;\n    long exponent_value_value_value_value_value_value = 0;\n    long exponent_value_value_value_value_value_value_sign = 1;\n    long exponent_value_value_value_value_value_value_power = 1;\n    long exponent_value_value_value_value_value_value_value = 0;\n    long exponent_value_value_value_value_value_value_value_sign = 1;\n    long exponent_value_value_value_value_value_value_value_power = 1;\n    long exponent_value_value_value_value_value_value_value_value = 0;\n    long exponent_value_value_value_value_value_value_value_value_sign = 1;\n    long exponent_value_value_value_value_value_value_value_value_power = 1;\n    long exponent_value_value_value_value_value_value_value_value_value = 0;\n    long exponent_value_value_value_value_value_value_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmprd9fyrau.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmprd9fyrau.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprd9fyrau.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmppi72g0jk.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmppi72g0jk.d(45): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppi72g0jk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpf9jnar94.d(89): Error: no identifier for declarator `long`\n/tmp/tmpf9jnar94.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9jnar94.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_int_2 = 0;\n    long frac_part_int_3 = 0;\n    long frac_part_int_4 = 0;\n    long frac_part_int_5 = 0;\n    long frac_part_int_6 = 0;\n    long frac_part_int_7 = 0;\n    long frac_part_int_8 = 0;\n    long frac_part_int_9 = 0;\n    long frac_part_int_10 = 0;\n    long frac_part_int_11 = 0;\n    long frac_part_int_12 = 0;\n    long frac_part_int_13 = 0;\n    long frac_part_int_14 = 0;\n    long frac_part_int_15 = 0;\n    long frac_part_int_16 = 0;\n    long frac_part_int_17 = 0;\n    long frac_part_int_18 = 0;\n    long frac_part_int_19 = 0;\n    long frac_part_int_20 = 0;\n    long frac_part_int_21 = 0;\n    long frac_part_int_22 = 0;\n    long frac_part_int_23 = 0;\n    long frac_part_int_24 = 0;\n    long frac_part_int_25 = 0;\n    long frac_part_int_26 = 0;\n    long frac_part_int_27 = 0;\n    long frac_part_int_28 = 0;\n    long frac_part_int_29 = 0;\n    long frac_part_int_30 = 0;\n    long frac_part_int_31 = 0;\n    long frac_part_int_32 = 0;\n    long frac_part_int_33 = 0;\n    long frac_part_int_34 = 0;\n    long frac_part_int_35\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7b_ko4h5.d(62): Error: semicolon expected, not `unittest`\n/tmp/tmp7b_ko4h5.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7b_ko4h5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpr1iwbrp4.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmpr1iwbrp4.d(45): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr1iwbrp4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long diff_max = 0;\n    long diff_min = 0;\n    long diff_diff = 0;\n    long diff_diff_max = 0;\n    long diff_diff_min = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_diff_diff_max\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5gqeuc5r.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmp5gqeuc5r.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5gqeuc5r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long sign = 1;\n    long power = 1;\n    long power_of_ten = 1;\n    long power_of_ten_minus_1 = 1;\n    long power_of_ten_minus_2 = 1;\n    long power_of_ten_minus_3 = 1;\n    long power_of_ten_minus_4 = 1;\n    long power_of_ten_minus_5 = 1;\n    long power_of_ten_minus_6 = 1;\n    long power_of_ten_minus_7 = 1;\n    long power_of_ten_minus_8 = 1;\n    long power_of_ten_minus_9 = 1;\n    long power_of_ten_minus_10 = 1;\n    long power_of_ten_minus_11 = 1;\n    long power_of_ten_minus_12 = 1;\n    long power_of_ten_minus_13 = 1;\n    long power_of_ten_minus_14 = 1;\n    long power_of_ten_minus_15 = 1;\n    long power_of_ten_minus_16 = 1;\n    long power_of_ten_minus_17 = 1;\n    long power_of_ten_minus_18 = 1;\n    long power_of_ten_minus_19 = 1;\n    long power_of_ten_minus_20 = 1;\n    long power_of_ten_minus_21 = 1;\n    long power_of_ten_minus_22 = 1;\n    long power_of_ten_minus_23 = 1;\n    long power_of_ten_minus_24 = 1;\n    long power_of_ten_minus_25 = 1;\n    long power_of_ten_minus_26 = 1;\n    long power_of_ten_minus_27 = 1;\n    long power_of_ten_minus_28 = 1;\n    long power_of_ten_minus_29 = 1;\n    long power_of_ten_minus_30 = 1;\n    long power_of_ten_minus_31 = 1;\n    long power_of_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7swbhyh_.d(61): Error: semicolon expected, not `unittest`\n/tmp/tmp7swbhyh_.d(61): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7swbhyh_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_temp = 0;\n    long diff_diff = 0;\n    long diff_diff_min = 0;\n    long diff_diff_max = 0;\n    long diff_diff_temp = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpg1j8ck77.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmpg1j8ck77.d(60): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg1j8ck77.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    long diff_abs = 0;\n    long int_value = 0;\n    long int_value_abs = 0;\n    long int_value_diff = 0;\n    long int_value_diff_abs = 0;\n    long int_value_diff_abs_max = 0;\n    long int_value_diff_abs_min = 0;\n    long int_value_diff_abs_max_diff = 0;\n    long int_value_diff_abs_min_diff = 0;\n    long int_value_diff_abs_max_diff_abs = 0;\n    long int_value_diff_abs_min_diff_abs = 0;\n    long int_value_diff_abs_max_diff_abs_abs = 0;\n    long int_value_diff_abs_min_diff_abs_abs = 0;\n    long int_value_diff_abs_max_diff_abs_abs_diff = 0;\n    long int_value_diff_abs_min_diff_abs_abs_diff = 0;\n    long int_value_diff_abs_max_diff_abs_abs_diff_abs = 0;\n    long int_value_diff_abs_min_diff_abs_abs_diff_abs = 0;\n    long int_value_diff_abs_max_diff_abs_abs_diff_abs_diff = 0;\n    long int_value_diff_abs_min_diff_abs_abs_diff_abs_diff = 0;\n    long int_value_diff_abs_max_diff_abs_abs_diff_abs_diff_abs = 0;\n    long int_value_diff_abs_min_diff_abs_abs_diff_abs_diff_abs = 0;\n    long int_value_diff_abs_max_diff_abs_abs_diff_abs_diff_abs_diff = 0;\n    long int_value_diff_abs_min_diff_abs_abs_diff_abs_diff_abs_diff = 0;\n    long int_value_diff_abs_max\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpp91w6_j9.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpp91w6_j9.d(52): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp91w6_j9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long temp2 = 0;\n    long diff2 = 0;\n    long temp3 = 0;\n    long diff3 = 0;\n    long temp4 = 0;\n    long diff4 = 0;\n    long temp5 = 0;\n    long diff5 = 0;\n    long temp6 = 0;\n    long diff6 = 0;\n    long temp7 = 0;\n    long diff7 = 0;\n    long temp8 = 0;\n    long diff8 = 0;\n    long temp9 = 0;\n    long diff9 = 0;\n    long temp10 = 0;\n    long diff10 = 0;\n    long temp11 = 0;\n    long diff11 = 0;\n    long temp12 = 0;\n    long diff12 = 0;\n    long temp13 = 0;\n    long diff13 = 0;\n    long temp14 = 0;\n    long diff14 = 0;\n    long temp15 = 0;\n    long diff15 = 0;\n    long temp16 = 0;\n    long diff16 = 0;\n    long temp17 = 0;\n    long diff17 = 0;\n    long temp18 = 0;\n    long diff18 = 0;\n    long temp19 = 0;\n    long diff19 = 0;\n    long temp20 = 0;\n    long diff20 = 0;\n    long temp21 = 0;\n    long diff21 = 0;\n    long temp22 = 0;\n    long diff22 = 0;\n    long temp23 = 0;\n    long diff23 = 0;\n    long temp24 = 0;\n    long diff24 = 0;\n    long temp25 = 0;\n    long diff25 = 0;\n    long temp26 = 0;\n    long diff26 = 0;\n    long temp27 = 0;\n    long diff27 = 0;\n    long temp28 = 0;\n    long diff28 = 0;\n    long temp29 = 0;\n    long diff29 = 0;\n    long temp30 = 0;\n    long diff30 = 0;\n    long temp31 = 0;\n    long diff\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpn97ryv28.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmpn97ryv28.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn97ryv28.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long diff_max = 0;\n    long diff_min = 0;\n    long diff_temp = 0;\n    long diff_temp_max = 0;\n    long diff_temp_min = 0;\n    long diff_temp_temp = 0;\n    long diff_temp_temp_max = 0;\n    long diff_temp_temp_min = 0;\n    long diff_temp_temp_temp = 0;\n    long diff_temp_temp_temp_max = 0;\n    long diff_temp_temp_temp_min = 0;\n    long diff_temp_temp_temp_temp = 0;\n    long diff_temp_temp_temp_temp_max = 0;\n    long diff_temp_temp_temp_temp_min = 0;\n    long diff_temp_temp_temp_temp_temp = 0;\n    long diff_temp_temp_temp_temp_temp_max = 0;\n    long diff_temp_temp_temp_temp_temp_min = 0;\n    long diff_temp_temp_temp_temp_temp_temp = 0;\n    long diff_temp_temp_temp_temp_temp_temp_max = 0;\n    long diff_temp_temp_temp_temp_temp_temp_min = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp_max = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp_min = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp_temp_max = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp_temp_min = 0;\n    long diff_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long diff_temp_temp_temp_temp_temp_temp_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpbil94isn.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmpbil94isn.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbil94isn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_abs = 0;\n    long exp_abs_sign = 1;\n    long exp_abs_val = 0;\n    long exp_abs_val_sign = 1;\n    long exp_abs_val_int = 0;\n    long exp_abs_val_int_sign = 1;\n    long exp_abs_val_frac = 0;\n    long exp_abs_val_frac_sign = 1;\n    long exp_abs_val_frac_int = 0;\n    long exp_abs_val_frac_int_sign = 1;\n    long exp_abs_val_frac_frac = 0;\n    long exp_abs_val_frac_frac_sign = 1;\n    long exp_abs_val_frac_frac_int = 0;\n    long exp_abs_val_frac_frac_int_sign = 1;\n    long exp_abs_val_frac_frac_frac = 0;\n    long exp_abs_val_frac_frac_frac_sign = 1;\n    long exp_abs_val_frac_frac_frac_int = 0;\n    long exp_abs_val_frac_frac_frac_int_sign = 1;\n    long exp_abs_val_frac_frac_frac_frac = 0;\n    long exp_abs_val_frac_frac_frac_frac_sign = 1;\n    long exp_abs_val_frac_frac_frac_frac_int = 0;\n    long exp_abs_val_frac_frac_frac_frac_int_sign = 1;\n    long exp_abs_val_frac_frac_frac_frac_frac = 0;\n    long exp_abs_val_frac_frac_frac_frac_frac_sign = 1;\n    long exp_abs_val_frac_frac_frac_frac_frac_int = 0;\n    long exp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpsd4yohli.d(58): Error: semicolon expected, not `unittest`\n/tmp/tmpsd4yohli.d(58): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsd4yohli.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long min_diff = 0;\n    long max_int = 0;\n    long min_int = 0;\n    long int_val = 0;\n    long int_diff = 0;\n    long int_min_diff = 0;\n    long int_max_diff = 0;\n    long int_min_int = 0;\n    long int_max_int = 0;\n    long int_min_int_diff = 0;\n    long int_max_int_diff = 0;\n    long int_min_int_min_diff = 0;\n    long int_max_int_max_diff = 0;\n    long int_min_int_min_int = 0;\n    long int_max_int_max_int = 0;\n    long int_min_int_min_int_diff = 0;\n    long int_max_int_max_int_diff = 0;\n    long int_min_int_min_int_min_diff = 0;\n    long int_max_int_max_int_max_diff = 0;\n    long int_min_int_min_int_min_int = 0;\n    long int_max_int_max_int_min_int = 0;\n    long int_min_int_min_int_min_int_diff = 0;\n    long int_max_int_max_int_min_int_diff = 0;\n    long int_min_int_min_int_min_int_min_diff = 0;\n    long int_max_int_max_int_min_int_max_diff = 0;\n    long int_min_int_min_int_min_int_min_int = 0;\n    long int_max_int_min_int_min_int_min_int = 0;\n    long int_min_int_min_int_min_int_min_int_diff = 0;\n    long int_max_int_min_int_min_int_min_int_diff = 0;\n    long int_min_int_min_int_min_int_min_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp38p52l2l.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmp38p52l2l.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp38p52l2l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_int_2 = 0;\n    long frac_part_int_3 = 0;\n    long frac_part_int_4 = 0;\n    long frac_part_int_5 = 0;\n    long frac_part_int_6 = 0;\n    long frac_part_int_7 = 0;\n    long frac_part_int_8 = 0;\n    long frac_part_int_9 = 0;\n    long frac_part_int_10 = 0;\n    long frac_part_int_11 = 0;\n    long frac_part_int_12 = 0;\n    long frac_part_int_13 = 0;\n    long frac_part_int_14 = 0;\n    long frac_part_int_15 = 0;\n    long frac_part_int_16 = 0;\n    long frac_part_int_17 = 0;\n    long frac_part_int_18 = 0;\n    long frac_part_int_19 = 0;\n    long frac_part_int_20 = 0;\n    long frac_part_int_21 = 0;\n    long frac_part_int_22 = 0;\n    long frac_part_int_23 = 0;\n    long frac_part_int_24 = 0;\n    long frac_part_int_25 = 0;\n    long frac_part_int_26 = 0;\n    long frac_part_int_27 = 0;\n    long frac_part_int_28 = 0;\n    long frac_part_int_29 = 0;\n    long frac_part_int_30 = 0;\n    long frac_part_int_31 = 0;\n    long frac_part_int_32 = 0;\n    long frac_part_int_33 = 0;\n    long frac_part_int_34 = 0;\n    long frac_part_int_35\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7b_ko4h5.d(62): Error: semicolon expected, not `unittest`\n/tmp/tmp7b_ko4h5.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7b_ko4h5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long temp = 0;\n    long temp_sign = 1;\n    long temp_power = 1;\n    long temp_result = 0;\n    long temp_result_sign = 1;\n    long temp_result_power = 1;\n    long temp_result_temp = 0;\n    long temp_result_temp_sign = 1;\n    long temp_result_temp_power = 1;\n    long temp_result_temp_result = 0;\n    long temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp = 0;\n    long temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp = 0;\n    long temp_result_temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp = 0;\n    long temp_result_temp_result_temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_temp_result_temp_result_sign\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpzdgq22e2.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmpzdgq22e2.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzdgq22e2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpjyhpwdg6.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjyhpwdg6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5ebkllec.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp5ebkllec.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ebkllec.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    long number = 0;\n    long number_diff = 0;\n    long number_diff_abs = 0;\n    long number_diff_abs_max = 0;\n    long number_diff_abs_min = 0;\n    long number_diff_abs_max_diff = 0;\n    long number_diff_abs_min_diff = 0;\n    long number_diff_abs_max_diff_abs = 0;\n    long number_diff_abs_min_diff_abs = 0;\n    long number_diff_abs_max_diff_abs_max = 0;\n    long number_diff_abs_min_diff_abs_min = 0;\n    long number_diff_abs_max_diff_abs_min = 0;\n    long number_diff_abs_max_diff_abs_max_diff = 0;\n    long number_diff_abs_min_diff_abs_min_diff = 0;\n    long number_diff_abs_max_diff_abs_min_diff = 0;\n    long number_diff_abs_max_diff_abs_max_diff_abs = 0;\n    long number_diff_abs_min_diff_abs_min_diff_abs = 0;\n    long number_diff_abs_max_diff_abs_min_diff_abs = 0;\n    long number_diff_abs_max_diff_abs_max_diff_abs_max = 0;\n    long number_diff_abs_min_diff_abs_min_diff_abs_min = 0;\n    long number_diff_abs_max_diff_abs_min_diff_abs_min = 0;\n    long number_diff_abs_max_diff_abs_max_diff_abs_min = 0;\n    long number_diff_abs_min_diff_abs_max_diff_abs_max = 0;\n    long number_diff_abs_min_diff_abs_min_diff_abs_max = 0;\n    long number_diff_abs_max_diff_abs_max_diff_abs_min =\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmphdq0trix.d(53): Error: expression expected, not `unittest`\n/tmp/tmphdq0trix.d(54): Error: semicolon expected, not `{`\n/tmp/tmphdq0trix.d(63): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphdq0trix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    \n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] == '.') {\n            min = 0;\n            max = 0;\n            diff = 0;\n            break;\n        }\n        \n        if (value[i] == '0') {\n            min = 0;\n            max = 0;\n            diff = 0;\n            break;\n        }\n        \n        if (value[i] == '1') {\n            min = 1;\n            max = 1;\n            diff = 1;\n            break;\n        }\n        \n        if (value[i] == '2') {\n            min = 2;\n            max = 2;\n            diff = 2;\n            break;\n        }\n        \n        if (value[i] == '3') {\n            min = 3;\n            max = 3;\n            diff = 3;\n            break;\n        }\n        \n        if (value[i] == '4') {\n            min = 4;\n            max = 4;\n            diff = 4;\n            break;\n        }\n        \n        if (value[i] == '5') {\n            min = 5;\n            max = 5;\n            diff = 5;\n            break;\n        }\n        \n        if (value[i] == '6') {\n            min = 6;\n            max = 6;\n            diff = 6;\n            break;\n        }\n        \n        if (value[i] == '7') {\n            min = 7;\n            max = 7;\n            diff = 7;\n            break;\n        }\n        \n        if (value[i] == '8') {\n            min = 8;\n            max = 8;\n            diff = 8;\n            break;\n        }\n        \n        if (value[i] == '9') {\n            min = 9;\n            max = 9;\n            diff = 9;\n            break;\n        }\n        \n        if (value[i] == '-') {\n            min = 0;\n            max =\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpmpzh1ina.d(110): Error: expression expected, not `unittest`\n/tmp/tmpmpzh1ina.d(111): Error: found `{` when expecting `;` following statement\n/tmp/tmpmpzh1ina.d(120): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpmpzh1ina.d(120): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmpzh1ina.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long frac_part_int_part_abs = 0;\n    long frac_part_int_part_sign = 1;\n    long int_part_int_part_abs = 0;\n    long int_part_int_part_sign = 1;\n    long int_part_int_part_int_part_abs = 0;\n    long int_part_int_part_int_part_sign = 1;\n    long frac_part_int_part_abs = 0;\n    long frac_part_int_part_sign = 1;\n    long frac_part_int_part_int_part_abs = 0;\n    long frac_part_int_part_int_part_sign = 1;\n    long frac_part_int_part_int_part_int_part_abs = 0;\n    long frac_part_int_part_int_part_int_part_sign = 1;\n    long frac_part_int_part_int_part_int_part_int_part_abs = 0;\n    long frac_part_int_part_int_part_int_part_int_part_sign = 1;\n    long int_part_int_part_int_part_int_part_int_part_abs = 0;\n    long int_part_int_part_int_part_int_part_int_part_sign = 1;\n    long frac_part_int_part_int_part_int_part_int_part_int_part_abs = 0;\n    long frac_part_int_part_int_part_int_part_int_part_int_part_sign = 1;\n    long int_part_int_part_int_part_int_part_int_part_int_part_int_part_abs = 0;\n    long int_part_int_part\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpb42ja3xy.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpb42ja3xy.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb42ja3xy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_min_max = 0;\n    long diff_min_min = 0;\n    long diff_max_max = 0;\n    long diff_min_max_min = 0;\n    long diff_min_min_max = 0;\n    long diff_max_max_min = 0;\n    long diff_min_max_max = 0;\n    long diff_min_min_min = 0;\n    long diff_max_max_max = 0;\n    long diff_min_min_min_min = 0;\n    long diff_max_max_min_min = 0;\n    long diff_min_min_min_min_min = 0;\n    long diff_max_max_min_min_min = 0;\n    long diff_min_min_min_min_min_min = 0;\n    long diff_max_max_min_min_min_min = 0;\n    long diff_min_min_min_min_min_min_min = 0;\n    long diff_max_max_min_min_min_min_min = 0;\n    long diff_min_min_min_min_min_min_min_min = 0;\n    long diff_max_max_min_min_min_min_min_min = 0;\n    long diff_min_min_min_min_min_min_min_min_min = 0;\n    long diff_max_max_min_min_min_min_min_min_min_min = 0;\n    long diff_min_min_min_min_min_min_min_min_min_min_min = 0;\n    long diff_max_max_min_min_min_min_min_min_min_min_min_min = 0;\n    long diff_min_min_min_min_min_min_min_min_min_min_min_min_min = 0;\n    long diff_max_max_min_min\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpkpyjmnqc.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmpkpyjmnqc.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkpyjmnqc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long power_sign = 1;\n    long power_sign_prev = 1;\n    long power_prev = 1;\n    long power_prev_prev = 1;\n    long power_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    long power_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 1;\n    \nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpffqcjnf0.d(48): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpffqcjnf0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 0;\n    long step_size = 0;\n    long step_size_half = 0;\n    long step_size_half_plus_one = 0;\n    long step_size_half_minus_one = 0;\n    long step_size_half_plus_two = 0;\n    long step_size_half_minus_two = 0;\n    long step_size_half_plus_three = 0;\n    long step_size_half_minus_three = 0;\n    long step_size_half_plus_four = 0;\n    long step_size_half_minus_four = 0;\n    long step_size_half_plus_five = 0;\n    long step_size_half_minus_five = 0;\n    long step_size_half_plus_six = 0;\n    long step_size_half_minus_six = 0;\n    long step_size_half_plus_seven = 0;\n    long step_size_half_minus_seven = 0;\n    long step_size_half_plus_eight = 0;\n    long step_size_half_minus_eight = 0;\n    long step_size_half_plus_nine = 0;\n    long step_size_half_minus_nine = 0;\n    long step_size_half_plus_ten = 0;\n    long step_size_half_minus_ten = 0;\n    long step_size_half_plus_eleven = 0;\n    long step_size_half_minus_eleven = 0;\n    long step_size_half_plus_twelve = 0;\n    long step_size_half_minus_twelve = 0;\n    long step_size_half_plus_thirteen = 0;\n    long step_size_half_minus_thirteen = 0;\n    long step_size_half_plus_fourteen = 0;\n    long step_size_half_minus_fourteen = 0;\n    long step_size_half_plus_fifteen = 0;\n    long step_size_half_minus_fifteen = 0;\n    long\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcs3gu91d.d(61): Error: no identifier for declarator `long`\n/tmp/tmpcs3gu91d.d(61): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcs3gu91d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp2gxtulgm.d(66): Error: semicolon expected, not `unittest`\n/tmp/tmp2gxtulgm.d(66): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2gxtulgm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long exponent = 0;\n    long mantissa = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpx5y6u0eh.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmpx5y6u0eh.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx5y6u0eh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long fr\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp2sclqjbe.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmp2sclqjbe.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2sclqjbe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 0;\n    long step_size = 0;\n    long step_size_2 = 0;\n    long step_size_3 = 0;\n    long step_size_4 = 0;\n    long step_size_5 = 0;\n    long step_size_6 = 0;\n    long step_size_7 = 0;\n    long step_size_8 = 0;\n    long step_size_9 = 0;\n    long step_size_10 = 0;\n    long step_size_11 = 0;\n    long step_size_12 = 0;\n    long step_size_13 = 0;\n    long step_size_14 = 0;\n    long step_size_15 = 0;\n    long step_size_16 = 0;\n    long step_size_17 = 0;\n    long step_size_18 = 0;\n    long step_size_19 = 0;\n    long step_size_20 = 0;\n    long step_size_21 = 0;\n    long step_size_22 = 0;\n    long step_size_23 = 0;\n    long step_size_24 = 0;\n    long step_size_25 = 0;\n    long step_size_26 = 0;\n    long step_size_27 = 0;\n    long step_size_28 = 0;\n    long step_size_29 = 0;\n    long step_size_30 = 0;\n    long step_size_31 = 0;\n    long step_size_32 = 0;\n    long step_size_33 = 0;\n    long step_size_34 = 0;\n    long step_size_35 = 0;\n    long step_size_36 = 0;\n    long step_size_37 = 0;\n    long step_size_38 = 0;\n    long step_size_39 = 0;\n    long step_size_40 = 0;\n    long step_size_41 = 0;\n    long step_size_42 = 0;\n    long step_size_43 = 0;\n    long step_size_44 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp6743xsii.d(73): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6743xsii.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_abs_sign_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpo16pnxrd.d(62): Error: semicolon expected, not `unittest`\n/tmp/tmpo16pnxrd.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo16pnxrd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_abs_int_part = 0;\n    long int_part_abs_int_part_sign = 1;\n    long int_part_abs_int_part_abs = 0;\n    long int_part_abs_int_part_abs_sign = 1;\n    long frac_part_abs_frac_part = 0;\n    long frac_part_abs_frac_part_sign = 1;\n    long frac_part_abs_frac_part_abs = 0;\n    long frac_part_abs_frac_part_abs_sign = 1;\n    long frac_part_abs_frac_part_abs_frac_part = 0;\n    long frac_part_abs_frac_part_abs_frac_part_sign = 1;\n    long frac_part_abs_frac_part_abs_frac_part_abs = 0;\n    long frac_part_abs_frac_part_abs_frac_part_abs_sign = 1;\n    long frac_part_abs_frac_part_abs_frac_part_abs_frac_part = 0;\n    long frac_part_abs_frac_part_abs_frac_part_abs_frac_part_sign = 1;\n    long frac_part_abs_frac_part_abs_frac_part_abs_frac_part_abs = 0;\n    long frac_part_abs_frac_part_abs_frac_part_abs_frac_part_abs_sign = 1;\n    long frac_part_abs_frac_part_abs_frac_part_abs_frac_part_abs_frac_part = 0;\n    long frac_part_abs_frac_part_abs_frac_part_abs_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpkwrq42mj.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpkwrq42mj.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwrq42mj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 0;\n    long exponent = 0;\n    long mantissa = 0;\n    long mantissa_sign = 1;\n    long mantissa_exponent = 0;\n    long mantissa_mantissa = 0;\n    long mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_sign = 1;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mant\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcc1n0g8j.d(50): Error: semicolon expected, not `unittest`\n/tmp/tmpcc1n0g8j.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcc1n0g8j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long int_part_abs_min = 0;\n    long int_part_sign = 1;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long value_abs = 0;\n    long value_sign = 1;\n    long value_max = 0;\n    long value_min = 0;\n    long int_part_abs_max = 0;\n    long int_part_abs_min = 0;\n    long int_part_sign = 1;\n    long int_part_max = 0;\n    long int_part_min = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_sign = 1;\n    long frac_part_max = 0;\n    long frac_part_min = 0\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpsn0zj2ct.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpsn0zj2ct.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsn0zj2ct.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long temp2 = 0;\n    long diff2 = 0;\n    long temp3 = 0;\n    long diff3 = 0;\n    long temp4 = 0;\n    long diff4 = 0;\n    long temp5 = 0;\n    long diff5 = 0;\n    long temp6 = 0;\n    long diff6 = 0;\n    long temp7 = 0;\n    long diff7 = 0;\n    long temp8 = 0;\n    long diff8 = 0;\n    long temp9 = 0;\n    long diff9 = 0;\n    long temp10 = 0;\n    long diff10 = 0;\n    long temp11 = 0;\n    long diff11 = 0;\n    long temp12 = 0;\n    long diff12 = 0;\n    long temp13 = 0;\n    long diff13 = 0;\n    long temp14 = 0;\n    long diff14 = 0;\n    long temp15 = 0;\n    long diff15 = 0;\n    long temp16 = 0;\n    long diff16 = 0;\n    long temp17 = 0;\n    long diff17 = 0;\n    long temp18 = 0;\n    long diff18 = 0;\n    long temp19 = 0;\n    long diff19 = 0;\n    long temp20 = 0;\n    long diff20 = 0;\n    long temp21 = 0;\n    long diff21 = 0;\n    long temp22 = 0;\n    long diff22 = 0;\n    long temp23 = 0;\n    long diff23 = 0;\n    long temp24 = 0;\n    long diff24 = 0;\n    long temp25 = 0;\n    long diff25 = 0;\n    long temp26 = 0;\n    long diff26 = 0;\n    long temp27 = 0;\n    long diff27 = 0;\n    long temp28 = 0;\n    long diff28 = 0;\n    long temp29 = 0;\n    long diff29 = 0;\n    long temp30 = 0;\n    long diff30 = 0;\n    long temp31 = 0;\n    long diff\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpn97ryv28.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmpn97ryv28.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn97ryv28.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_abs = 0;\n    long exp_abs_sign = 1;\n    long exp_abs_int = 0;\n    long exp_abs_frac = 0;\n    long exp_abs_frac_sign = 1;\n    long exp_abs_frac_int = 0;\n    long exp_abs_frac_frac = 0;\n    long exp_abs_frac_frac_sign = 1;\n    long exp_abs_frac_frac_int = 0;\n    long exp_abs_frac_frac_frac = 0;\n    long exp_abs_frac_frac_frac_sign = 1;\n    long exp_abs_frac_frac_frac_int = 0;\n    long exp_abs_frac_frac_frac_frac = 0;\n    long exp_abs_frac_frac_frac_frac_sign = 1;\n    long exp_abs_frac_frac_frac_frac_int = 0;\n    long exp_abs_frac_frac_frac_frac_frac = 0;\n    long exp_abs_frac_frac_frac_frac_frac_sign = 1;\n    long exp_abs_frac_frac_frac_frac_frac_int = 0;\n    long exp_abs_frac_frac_frac_frac_frac_frac = 0;\n    long exp_abs_frac_frac_frac_frac_frac_frac_sign = 1;\n    long exp_abs_frac_frac_frac_frac_frac_frac_int = 0;\n    long exp_abs_frac_frac_frac_frac_frac_frac_frac = 0;\n    long exp_abs_frac_frac_frac_frac_frac_frac_frac_sign = 1;\n    long exp_abs_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long exp_abs_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long exp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmph0irsja8.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmph0irsja8.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph0irsja8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long int_part_prev = 0;\n    long frac_part_prev = 0;\n    long int_part_next = 0;\n    long frac_part_next = 0;\n    long int_part_next_prev = 0;\n    long frac_part_next_prev = 0;\n    long int_part_next_next = 0;\n    long frac_part_next_next = 0;\n    long int_part_next_next_prev = 0;\n    long frac_part_next_next_prev = 0;\n    long int_part_next_next_next = 0;\n    long frac_part_next_next_next = 0;\n    long int_part_next_next_next_prev = 0;\n    long frac_part_next_next_next_prev = 0;\n    long int_part_next_next_next_next = 0;\n    long frac_part_next_next_next_next = 0;\n    long int_part_next_next_next_next_prev = 0;\n    long frac_part_next_next_next_next_prev = 0;\n    long int_part_next_next_next_next_next = 0;\n    long frac_part_next_next_next_next_next = 0;\n    long int_part_next_next_next_next_next_prev = 0;\n    long frac_part_next_next_next_next_next_prev = 0;\n    long int_part_next_next_next_next_next_next = 0;\n    long frac_part_next_next_next_next_next_next = 0;\n    long int_part_next_next_next_next_next_next_prev = 0;\n    long frac_part_next_next_next_next_next_next_prev = 0;\n    long int_part_next_next_next_next_next_next_next = 0;\n    long\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpiycvkvh4.d(57): Error: no identifier for declarator `long`\n/tmp/tmpiycvkvh4.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiycvkvh4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_temp = 0;\n    \n    if (value.length() == 0)\n        return 0;\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        if (value[i] == '.')\n            continue;\n        \n        temp = value[i] - 48;\n        \n        if (temp > max)\n            max = temp;\n        if (temp < min)\n            min = temp;\n    }\n    \n    diff_max = max - min;\n    diff_min = min - max;\n    \n    if (diff_max == 0)\n        return max;\n    if (diff_min == 0)\n        return min;\n    \n    if (diff_max > diff_min)\n    {\n        diff = diff_max;\n        result = max;\n    }\n    else\n    {\n        diff = diff_min;\n        result = min;\n    }\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        if (value[i] == '.')\n            continue;\n        \n        temp = value[i] - 48;\n        \n        if (temp > result)\n            result = temp;\n        if (temp < result)\n            result = temp;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmph2wybx0g.d(33): Error: no property `length` for type `string`\n/tmp/tmph2wybx0g.d(36): Error: no property `length` for type `string`\n/tmp/tmph2wybx0g.d(68): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph2wybx0g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    \n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] == '.') {\n            min = 0;\n            max = 0;\n            break;\n        }\n        if (value[i] == '-') {\n            min = 0;\n            max = 0;\n            break;\n        }\n        if (value[i] >= '0' && value[i] <= '9') {\n            min = min * 10 + value[i] - '0';\n            max = max * 10 + '9' - 1;\n        }\n    }\n    \n    diff = max - min;\n    \n    if (diff == 0) {\n        result = max;\n    }\n    else if (diff > 0) {\n        result = min + (diff / 2);\n    }\n    else {\n        result = max - (diff / 2);\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpqnswxnyh.d(29): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqnswxnyh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_sign_abs = 0;\n    long frac_part_sign_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_sign_abs = 0;\n    long int_part_sign_abs_sign = 0;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_abs = 0;\n    long int_part_abs_sign_abs_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_abs = 0;\n    long frac_part_abs_sign_abs_sign = 0;\n    long frac_part_abs_sign_abs_sign_abs = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_sign = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_sign_abs = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_sign_abs_sign = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_sign_abs_sign_abs = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_sign_abs_sign_abs_sign = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_sign_abs_sign_abs_sign_abs = 0;\n    long frac_part_abs_sign_abs_sign_abs_sign_abs_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3xhgen0l.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmp3xhgen0l.d(52): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3xhgen0l.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long max_number = 0;\n    long min_number = 0;\n    long diff = 0;\n    long diff_max = 0;\n    long diff_min = 0;\n    long diff_number = 0;\n    long diff_number_max = 0;\n    long diff_number_min = 0;\n    long diff_number_number = 0;\n    long diff_number_number_max = 0;\n    long diff_number_number_min = 0;\n    long diff_number_number_number = 0;\n    long diff_number_number_number_max = 0;\n    long diff_number_number_number_min = 0;\n    long diff_number_number_number_number = 0;\n    long diff_number_number_number_number_max = 0;\n    long diff_number_number_number_number_min = 0;\n    long diff_number_number_number_number_number = 0;\n    long diff_number_number_number_number_number_max = 0;\n    long diff_number_number_number_number_number_min = 0;\n    long diff_number_number_number_number_number_number = 0;\n    long diff_number_number_number_number_number_number_max = 0;\n    long diff_number_number_number_number_number_number_min = 0;\n    long diff_number_number_number_number_number_number_number = 0;\n    long diff_number_number_number_number_number_number_number_max = 0;\n    long diff_number_number_number_number_number_number_number_min = 0;\n    long diff_number_number_number_number_number_number_number_number = 0;\n    long diff_number_number_number_number_number_number_number_number_max = 0;\n    long diff_number_number_number_number_number_number_number_number_min = 0;\n    long diff_number_number_number_number_number_number_number_number_number = 0;\n    long diff_number_number_number_number_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp6ffx1lcw.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmp6ffx1lcw.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ffx1lcw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long frac_part_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs_sign = 1;\n    long int_part_abs_sign = 1;\n    long frac_part_abs\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpvtxd2n0q.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmpvtxd2n0q.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvtxd2n0q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long sign = 1;\n    long exponent = 0;\n    long mantissa = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpq08ivl3q.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmpq08ivl3q.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq08ivl3q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long int_part_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpzrd_bd5y.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpzrd_bd5y.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzrd_bd5y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long sign = 1;\n    long power = 1;\n    long temp_power = 1;\n    long temp_sign = 1;\n    long temp_result = 0;\n    long temp_temp = 0;\n    long temp_temp_power = 1;\n    long temp_temp_sign = 1;\n    long temp_temp_result = 0;\n    long temp_temp_temp = 0;\n    long temp_temp_temp_power = 1;\n    long temp_temp_temp_sign = 1;\n    long temp_temp_temp_result = 0;\n    long temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_power = 1;\n    long temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_power = 1;\n    long temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_power = 1;\n    long temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_power = 1;\n    long temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_power = 1;\n    long temp_temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpqph315zh.d(59): Error: semicolon expected, not `unittest`\n/tmp/tmpqph315zh.d(59): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqph315zh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp_diff = 0;\n    long temp_diff_2 = 0;\n    long temp_diff_3 = 0;\n    long temp_diff_4 = 0;\n    long temp_diff_5 = 0;\n    long temp_diff_6 = 0;\n    long temp_diff_7 = 0;\n    long temp_diff_8 = 0;\n    long temp_diff_9 = 0;\n    long temp_diff_10 = 0;\n    long temp_diff_11 = 0;\n    long temp_diff_12 = 0;\n    long temp_diff_13 = 0;\n    long temp_diff_14 = 0;\n    long temp_diff_15 = 0;\n    long temp_diff_16 = 0;\n    long temp_diff_17 = 0;\n    long temp_diff_18 = 0;\n    long temp_diff_19 = 0;\n    long temp_diff_20 = 0;\n    long temp_diff_21 = 0;\n    long temp_diff_22 = 0;\n    long temp_diff_23 = 0;\n    long temp_diff_24 = 0;\n    long temp_diff_25 = 0;\n    long temp_diff_26 = 0;\n    long temp_diff_27 = 0;\n    long temp_diff_28 = 0;\n    long temp_diff_29 = 0;\n    long temp_diff_30 = 0;\n    long temp_diff_31 = 0;\n    long temp_diff_32 = 0;\n    long temp_diff_33 = 0;\n    long temp_diff_34 = 0;\n    long temp_diff_35 = 0;\n    long temp_diff_36 = 0;\n    long temp_diff_37 = 0;\n    long temp_diff_38 = 0;\n    long temp_diff_39 = 0;\n    long temp_diff_40 = 0;\n    long temp_diff_41 = 0;\n    long temp_diff_42 = 0;\n    long temp_diff_43 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpnpxfgljv.d(73): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnpxfgljv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5ebkllec.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp5ebkllec.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5ebkllec.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long frac_part_abs_int_part_abs_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long frac_part_abs_int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpg5znl4cg.d(46): Error: semicolon expected, not `unittest`\n/tmp/tmpg5znl4cg.d(46): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg5znl4cg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_int_2 = 0;\n    long frac_part_int_3 = 0;\n    long frac_part_int_4 = 0;\n    long frac_part_int_5 = 0;\n    long frac_part_int_6 = 0;\n    long frac_part_int_7 = 0;\n    long frac_part_int_8 = 0;\n    long frac_part_int_9 = 0;\n    long frac_part_int_10 = 0;\n    long frac_part_int_11 = 0;\n    long frac_part_int_12 = 0;\n    long frac_part_int_13 = 0;\n    long frac_part_int_14 = 0;\n    long frac_part_int_15 = 0;\n    long frac_part_int_16 = 0;\n    long frac_part_int_17 = 0;\n    long frac_part_int_18 = 0;\n    long frac_part_int_19 = 0;\n    long frac_part_int_20 = 0;\n    long frac_part_int_21 = 0;\n    long frac_part_int_22 = 0;\n    long frac_part_int_23 = 0;\n    long frac_part_int_24 = 0;\n    long frac_part_int_25 = 0;\n    long frac_part_int_26 = 0;\n    long frac_part_int_27 = 0;\n    long frac_part_int_28 = 0;\n    long frac_part_int_29 = 0;\n    long frac_part_int_30 = 0;\n    long frac_part_int_31 = 0;\n    long frac_part_int_32 = 0;\n    long frac_part_int_33 = 0;\n    long frac_part_int_34 = 0;\n    long frac_part_int_35\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7b_ko4h5.d(62): Error: semicolon expected, not `unittest`\n/tmp/tmp7b_ko4h5.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7b_ko4h5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long power = 1;\n    long sign = 1;\n    long exponent = 0;\n    long exponent_sign = 1;\n    long exponent_value = 0;\n    long exponent_power = 1;\n    long exponent_exponent = 0;\n    long exponent_exponent_sign = 1;\n    long exponent_exponent_value = 0;\n    long exponent_exponent_power = 1;\n    long exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_value = 0;\n    long exponent_exponent_exponent_power = 1;\n    long exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_value = 0;\n    long exponent_exponent_exponent_exponent_power = 1;\n    long exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_value = 0;\n    long exponent_exponent_exponent_exponent_exponent_power = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent_value = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_power = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_sign = 1;\n    long exponent_exponent_exponent_exponent_exponent_exponent_exponent_value = 0;\n    long exponent_exponent_exponent_exponent_exponent_exponent_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpya60tvfq.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmpya60tvfq.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpya60tvfq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp1xw2r5go.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp1xw2r5go.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1xw2r5go.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long tmp = 0;\n    \n    for(int i = 0; i < value.length(); i++)\n    {\n        tmp = value[i] - '0';\n        diff = abs(tmp);\n        if(diff > max_diff)\n        {\n            max_diff = diff;\n            result = tmp;\n        }\n    }\n    \n    if(max_diff == 0)\n    {\n        return result;\n    }\n    \n    if(max_diff == 1)\n    {\n        return result + 1;\n    }\n    \n    if(max_diff == 2)\n    {\n        return result + 2;\n    }\n    \n    if(max_diff == 3)\n    {\n        return result + 3;\n    }\n    \n    if(max_diff == 4)\n    {\n        return result + 4;\n    }\n    \n    if(max_diff == 5)\n    {\n        return result + 5;\n    }\n    \n    if(max_diff == 6)\n    {\n        return result + 6;\n    }\n    \n    if(max_diff == 7)\n    {\n        return result + 7;\n    }\n    \n    if(max_diff == 8)\n    {\n        return result + 8;\n    }\n    \n    if(max_diff == 9)\n    {\n        return result + 9;\n    }\n    \n    if(max_diff == 10)\n    {\n        return result + 10;\n    }\n    \n    if(max_diff == 11)\n    {\n        return result + 11;\n    }\n    \n    if(max_diff == 12)\n    {\n        return result + 12;\n    }\n    \n    if(max_diff == 13)\n    {\n        return result + 13;\n    }\n    \n    if(max_diff == 14)\n    {\n        return result + 14;\n    }\n    \n    if(max_diff == 15)\n    {\n        return result + 15;\n    }\n    \n    if(max_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpujj21lyr.d(121): Error: found `unittest` when expecting `)`\n/tmp/tmpujj21lyr.d(131): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpujj21lyr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpta1vyoes.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmpta1vyoes.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpta1vyoes.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_distance = 0;\n    long min_distance = 0;\n    long distance = 0;\n    long number = 0;\n    long number_of_digits = 0;\n    long number_of_decimals = 0;\n    long number_of_whole_digits = 0;\n    long number_of_decimals_to_round = 0;\n    long number_of_whole_digits_to_round = 0;\n    long number_of_whole_digits_to_round_up = 0;\n    long number_of_whole_digits_to_round_down = 0;\n    long number_of_whole_digits_to_round_half_up = 0;\n    long number_of_whole_digits_to_round_half_down = 0;\n    long number_of_whole_digits_to_round_half_even = 0;\n    long number_of_whole_digits_to_round_half_odd = 0;\n    long number_of_whole_digits_to_round_half_odd_up = 0;\n    long number_of_whole_digits_to_round_half_odd_down = 0;\n    long number_of_whole_digits_to_round_half_odd_even = 0;\n    long number_of_whole_digits_to_round_half_odd_odd = 0;\n    long number_of_whole_digits_to_round_half_odd_odd_up = 0;\n    long number_of_whole_digits_to_round_half_odd_odd_down = 0;\n    long number_of_whole_digits_to_round_half_odd_odd_even = 0;\n    long number_of_whole_digits_to_round_half_odd_odd_odd = 0;\n    long number_of_whole_digits_to_round_half_odd_odd_odd_up = 0;\n    long number_of_whole_digits_to_round_half_odd_odd_odd_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3i2yilor.d(50): Error: semicolon expected, not `unittest`\n/tmp/tmp3i2yilor.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3i2yilor.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_abs_rounded = 0;\n    long frac_part_abs_rounded = 0;\n    long frac_part_abs_rounded_sign = 1;\n    long int_part_abs_rounded_sign = 1;\n    long frac_part_abs_rounded_sign_negative = -1;\n    long int_part_abs_rounded_sign_negative = -1;\n    long frac_part_abs_rounded_sign_negative_negative = 1;\n    long int_part_abs_rounded_sign_negative_negative = 1;\n    long frac_part_abs_rounded_sign_positive = 1;\n    long int_part_abs_rounded_sign_positive = 1;\n    long frac_part_abs_rounded_sign_positive_positive = -1;\n    long int_part_abs_rounded_sign_positive_positive = -1;\n    long frac_part_abs_rounded_sign_positive_negative = -1;\n    long int_part_abs_rounded_sign_positive_negative = -1;\n    long frac_part_abs_rounded_sign_negative_positive = 1;\n    long int_part_abs_rounded_sign_negative_positive = 1;\n    long frac_part_abs_rounded_sign_negative_negative = -1;\n    long int_part_abs_rounded_sign_negative_negative = -1;\n    long frac_part_abs_rounded_sign_positive_positive = 1;\n    long int_part_abs_rounded_sign_positive_positive = 1;\n    long frac_part_abs_rounded_sign_positive_negative = -1;\n    long int_part_abs_rounded_sign_positive_negative = -1;\n    long frac_part_abs_rounded_sign_negative_positive = 1;\n    long int_part_abs\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp9n4f2wwp.d(55): Error: semicolon expected, not `unittest`\n/tmp/tmp9n4f2wwp.d(55): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9n4f2wwp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_abs_prev = 0;\n    long frac_part_abs_prev = 0;\n    long frac_part_abs_next = 0;\n    long frac_part_abs_next_prev = 0;\n    long frac_part_abs_next_next = 0;\n    long int_part_abs_next = 0;\n    long int_part_abs_next_prev = 0;\n    long int_part_abs_next_next = 0;\n    long frac_part_abs_next_next = 0;\n    long frac_part_abs_next_next_prev = 0;\n    long frac_part_abs_next_next_next = 0;\n    long int_part_abs_next_next_prev = 0;\n    long int_part_abs_next_next_next = 0;\n    long frac_part_abs_next_next_next = 0;\n    long frac_part_abs_next_next_next_prev = 0;\n    long frac_part_abs_next_next_next_next = 0;\n    long int_part_abs_next_next_next_prev = 0;\n    long int_part_abs_next_next_next_next = 0;\n    long frac_part_abs_next_next_next_next = 0;\n    long frac_part_abs_next_next_next_next_prev = 0;\n    long frac_part_abs_next_next_next_next_next = 0;\n    long int_part_abs_next_next_next_next_prev = 0;\n    long int_part_abs_next_next_next_next_next = 0;\n    long frac_part_abs_next_next_next_next_next = 0;\n    long frac_part_abs_next_next\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpj8tg1yii.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmpj8tg1yii.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj8tg1yii.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    \n    number = std.math.to_long(value);\n    \n    if (number < 0)\n    {\n        result = number * -1;\n    }\n    else\n    {\n        result = number;\n    }\n    \n    max_diff = result - (result / 2);\n    min_diff = result - (result / 2);\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        diff = std.math.to_long(value.substr(i, 1)) - (result / 2);\n        \n        if (diff > max_diff)\n        {\n            max_diff = diff;\n        }\n        \n        if (diff < min_diff)\n        {\n            min_diff = diff;\n        }\n    }\n    \n    if (max_diff == min_diff)\n    {\n        if (max_diff < 0)\n        {\n            result = result - 1;\n        }\n        else\n        {\n            result = result + 1;\n        }\n    }\n    \n    return result;\n}\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpvy48g4ru.d(30): Error: undefined identifier `to_long` in module `std.math`\n/tmp/tmpvy48g4ru.d(44): Error: no property `length` for type `string`\n/tmp/tmpvy48g4ru.d(46): Error: undefined identifier `to_long` in module `std.math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvy48g4ru.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_sign = 0;\n    long int_part_sign_sign = 0;\n    long frac_part_sign_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long int_part_abs_sign = 0;\n    long int_part_abs_sign_sign = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpi14tx3bk.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi14tx3bk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    long diff = 0;\n    long diff_max = 0;\n    long diff_min = 0;\n    long diff_temp = 0;\n    \n    for(int i = 0; i < value.length(); i++)\n    {\n        if(value[i] == '.')\n        {\n            continue;\n        }\n        else\n        {\n            temp = value[i] - 48;\n            if(temp > max)\n            {\n                max = temp;\n            }\n            if(temp < min)\n            {\n                min = temp;\n            }\n        }\n    }\n    \n    diff = max - min;\n    diff_max = max - (max/2);\n    diff_min = min - (min/2);\n    \n    if(diff == 0)\n    {\n        if(diff_max > 0)\n        {\n            result = max;\n        }\n        else\n        {\n            result = min;\n        }\n    }\n    else if(diff > 0)\n    {\n        if(diff_max > 0)\n        {\n            result = max;\n        }\n        else\n        {\n            result = min;\n        }\n    }\n    else if(diff < 0)\n    {\n        if(diff_min > 0)\n        {\n            result = min;\n        }\n        else\n        {\n            result = max;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpuip00yir.d(33): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuip00yir.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long temp = 0;\n    \n    for(int i = 0; i < value.length(); i++)\n    {\n        temp = value[i] - '0';\n        if(temp > max)\n            max = temp;\n        if(temp < min)\n            min = temp;\n    }\n    diff = max - min;\n    if(diff == 0)\n    {\n        result = max;\n    }\n    else\n    {\n        if(diff > 0)\n            result = max + 1;\n        else\n            result = max - 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp123_ugp6.d(30): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp123_ugp6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_value = 0;\n    long min_value = 0;\n    long temp = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpfv7c5d41.d(97): Error: no identifier for declarator `int`\n/tmp/tmpfv7c5d41.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfv7c5d41.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_sign_abs = 0;\n    long frac_part_sign_sign = 0;\n    long frac_part_sign_sign_abs = 0;\n    long int_part_abs = 0;\n    long int_part_sign = 0;\n    long int_part_sign_abs = 0;\n    long int_part_sign_sign = 0;\n    long int_part_sign_sign_abs = 0;\n    long int_part_sign_sign_sign = 0;\n    long int_part_sign_sign_sign_abs = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_abs = 0;\n    long frac_part_abs_sign_sign = 0;\n    long frac_part_abs_sign_sign_abs = 0;\n    long frac_part_abs_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_abs = 0;\n    long frac_part_sign_abs_sign = 0;\n    long frac_part_sign_abs_sign_abs = 0;\n    long frac_part_sign_abs_sign_sign = 0;\n    long frac_part_sign_abs_sign_sign_abs = 0;\n    long frac_part_sign_abs_sign_sign_sign = 0;\n    long frac_part_sign_abs_sign_sign_sign_abs = 0;\n    long frac_part_sign_sign_abs_sign = 0;\n    long frac_part_sign_sign_abs_sign_abs = 0;\n    long frac_part_sign_sign_abs_sign_sign = 0;\n    long frac_part_sign_sign_abs_sign_sign_abs = 0;\n    long frac_part_sign_sign_sign_abs_sign = 0;\n    long frac_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpn6zzaw8g.d(57): Error: semicolon expected, not `unittest`\n/tmp/tmpn6zzaw8g.d(57): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn6zzaw8g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long decimal = 0;\n    long decimal_sign = 1;\n    long decimal_place = 0;\n    long decimal_max = 0;\n    long decimal_min = 0;\n    long decimal_max_sign = 1;\n    long decimal_min_sign = 1;\n    long decimal_max_place = 0;\n    long decimal_min_place = 0;\n    long decimal_max_max = 0;\n    long decimal_min_min = 0;\n    long decimal_max_max_sign = 1;\n    long decimal_min_min_sign = 1;\n    long decimal_max_max_place = 0;\n    long decimal_min_min_place = 0;\n    long decimal_max_max_max = 0;\n    long decimal_min_min_min = 0;\n    long decimal_max_max_max_sign = 1;\n    long decimal_min_min_min_sign = 1;\n    long decimal_max_max_max_place = 0;\n    long decimal_min_min_min_place = 0;\n    long decimal_max_max_max_max = 0;\n    long decimal_min_min_min_min = 0;\n    long decimal_max_max_max_max_sign = 1;\n    long decimal_min_min_min_min_sign = 1;\n    long decimal_max_max_max_max_place = 0;\n    long decimal_min_min_min_min_place = 0;\n    long decimal_max_max_max_max_max = 0;\n    long decimal_min_min_min_min_min = 0;\n    long decimal_max_max_max_max_max_sign = 1;\n    long decimal_min_min_min_min_min_sign = 1;\n    long decimal_max_max_max_max_max_place = 0;\n    long decimal_min_min_min_min_min_place = 0;\n    long decimal_max_max_max_max_max_max = 0;\n    long decimal_min_min_min_min_min_min = 0;\n    long decimal\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7urlp938.d(62): Error: semicolon expected, not `unittest`\n/tmp/tmp7urlp938.d(62): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7urlp938.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long sign = 1;\n    long temp_sign = 1;\n    long temp_result = 0;\n    long temp_temp = 0;\n    long temp_temp_sign = 1;\n    long temp_temp_result = 0;\n    long temp_temp_temp = 0;\n    long temp_temp_temp_sign = 1;\n    long temp_temp_temp_result = 0;\n    long temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp2ud2gt3e.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmp2ud2gt3e.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ud2gt3e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long power = 1;\n    long sign = 1;\n    long exponent = 0;\n    long fraction = 0;\n    long fraction_power = 0;\n    long fraction_power_2 = 0;\n    long fraction_power_3 = 0;\n    long fraction_power_4 = 0;\n    long fraction_power_5 = 0;\n    long fraction_power_6 = 0;\n    long fraction_power_7 = 0;\n    long fraction_power_8 = 0;\n    long fraction_power_9 = 0;\n    long fraction_power_10 = 0;\n    long fraction_power_11 = 0;\n    long fraction_power_12 = 0;\n    long fraction_power_13 = 0;\n    long fraction_power_14 = 0;\n    long fraction_power_15 = 0;\n    long fraction_power_16 = 0;\n    long fraction_power_17 = 0;\n    long fraction_power_18 = 0;\n    long fraction_power_19 = 0;\n    long fraction_power_20 = 0;\n    long fraction_power_21 = 0;\n    long fraction_power_22 = 0;\n    long fraction_power_23 = 0;\n    long fraction_power_24 = 0;\n    long fraction_power_25 = 0;\n    long fraction_power_26 = 0;\n    long fraction_power_27 = 0;\n    long fraction_power_28 = 0;\n    long fraction_power_29 = 0;\n    long fraction_power_30 = 0;\n    long fraction_power_31 = 0;\n    long fraction_power_32 = 0;\n    long fraction_power_33 = 0;\n    long fraction_power_34 = 0;\n    long fraction_power_35 = 0;\n    long fraction_power_36 = 0;\n    long fraction_power_37 = 0;\n    long fraction_power_38 = 0;\n    long fraction_power_39 = 0;\n    long fraction_power_40 = 0;\n    long fraction_power_41 = 0;\n    long fraction_power_42 = 0;\n    long fraction_power_43 =\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpaupr_8ir.d(73): Error: expression expected, not `unittest`\n/tmp/tmpaupr_8ir.d(74): Error: semicolon expected, not `{`\n/tmp/tmpaupr_8ir.d(83): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaupr_8ir.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1;\n    long frac_part_abs_int_part_sign = 1\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmprm9z3s5j.d(56): Error: semicolon expected, not `unittest`\n/tmp/tmprm9z3s5j.d(56): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprm9z3s5j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_abs = 0;\n    long exp_abs_sign = 1;\n    long exp_abs_value = 0;\n    long exp_abs_value_sign = 1;\n    long exp_abs_value_abs = 0;\n    long exp_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_value = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_value_sign = 1;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs_value_abs = 0;\n    long exp_abs_value_abs_value_abs_value_abs_value_abs\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp_mxv2duv.d(54): Error: semicolon expected, not `unittest`\n/tmp/tmp_mxv2duv.d(54): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_mxv2duv.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpta1vyoes.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmpta1vyoes.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpta1vyoes.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long frac_part_abs_min = 0;\n    long frac_part_abs_min = 0;\n    long int_part_abs_min = 0;\n    long int_part_abs_max = 0;\n    long frac_part_abs_max = 0;\n    long fr\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpsxf1vbs6.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmpsxf1vbs6.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsxf1vbs6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long temp = 0;\n    int i = 0;\n    int len = value.length();\n    for(i = 0; i < len; i++)\n    {\n        if(value[i] == '.')\n        {\n            temp = atol(value.substr(0, i).c_str());\n            max = max + temp;\n            min = min + temp;\n            break;\n        }\n        else\n        {\n            temp = atol(value.substr(i, len).c_str());\n            max = max + temp;\n            min = min + temp;\n        }\n    }\n    if(max == min)\n    {\n        result = max;\n    }\n    else\n    {\n        result = max - min;\n        if(result < 0)\n        {\n            result = result * -1;\n        }\n        if(result == 0)\n        {\n            result = max;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmprd5ro1jo.d(29): Error: no property `length` for type `string`\n/tmp/tmprd5ro1jo.d(34): Error: undefined identifier `atol`, did you mean function `atan`?\n/tmp/tmprd5ro1jo.d(41): Error: undefined identifier `atol`, did you mean function `atan`?\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprd5ro1jo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_distance = 0;\n    long distance = 0;\n    long min_distance = 0;\n    long min_distance_value = 0;\n    long max_distance_value = 0;\n    long min_distance_value_index = 0;\n    long max_distance_value_index = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    \nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp9otijoi3.d(93): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9otijoi3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp5jv8cj6y.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp5jv8cj6y.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5jv8cj6y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long num = 0;\n    long num2 = 0;\n    long num3 = 0;\n    long num4 = 0;\n    long num5 = 0;\n    long num6 = 0;\n    long num7 = 0;\n    long num8 = 0;\n    long num9 = 0;\n    long num10 = 0;\n    long num11 = 0;\n    long num12 = 0;\n    long num13 = 0;\n    long num14 = 0;\n    long num15 = 0;\n    long num16 = 0;\n    long num17 = 0;\n    long num18 = 0;\n    long num19 = 0;\n    long num20 = 0;\n    long num21 = 0;\n    long num22 = 0;\n    long num23 = 0;\n    long num24 = 0;\n    long num25 = 0;\n    long num26 = 0;\n    long num27 = 0;\n    long num28 = 0;\n    long num29 = 0;\n    long num30 = 0;\n    long num31 = 0;\n    long num32 = 0;\n    long num33 = 0;\n    long num34 = 0;\n    long num35 = 0;\n    long num36 = 0;\n    long num37 = 0;\n    long num38 = 0;\n    long num39 = 0;\n    long num40 = 0;\n    long num41 = 0;\n    long num42 = 0;\n    long num43 = 0;\n    long num44 = 0;\n    long num45 = 0;\n    long num46 = 0;\n    long num47 = 0;\n    long num48 = 0;\n    long num49 = 0;\n    long num50 = 0;\n    long num51 = 0;\n    long num52 = 0;\n    long num53 = 0;\n    long num54 = 0;\n    long num55 = 0;\n    long num56 = 0;\n    long num57 = 0;\n    long num58 = 0;\n    long num59 = 0;\n    long num60 = 0;\n    long num61 = 0;\n    long num62 = 0;\n    \nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp77x1482j.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp77x1482j.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long exp = 0;\n    long frac_part_len = 0;\n    long int_part_len = 0;\n    long frac_part_max = 0;\n    long int_part_max = 0;\n    long frac_part_min = 0;\n    long int_part_min = 0;\n    long frac_part_max_len = 0;\n    long int_part_max_len = 0;\n    long frac_part_min_len = 0;\n    long int_part_min_len = 0;\n    long frac_part_max_exp = 0;\n    long int_part_max_exp = 0;\n    long frac_part_min_exp = 0;\n    long int_part_min_exp = 0;\n    long frac_part_max_exp_len = 0;\n    long int_part_max_exp_len = 0;\n    long frac_part_min_exp_len = 0;\n    long int_part_min_exp_len = 0;\n    long frac_part_max_len_exp = 0;\n    long int_part_max_len_exp = 0;\n    long frac_part_min_len_exp = 0;\n    long int_part_min_len_exp = 0;\n    long frac_part_max_len_exp_len = 0;\n    long int_part_max_len_exp_len = 0;\n    long frac_part_min_len_exp_len = 0;\n    long int_part_min_len_exp_len = 0;\n    long frac_part_max_len_exp_len_exp = 0;\n    long int_part_max_len_exp_len_exp = 0;\n    long frac_part_min_len_exp_len_exp = 0;\n    long int_part_min_len_exp_len_exp = 0;\n    long frac_part_max_len_exp_len_exp_len = 0;\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp6cbppfd8.d(60): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6cbppfd8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    long temp = 0;\n    \n    if (value.length() == 0)\n        return 0;\n    \n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] == '.')\n            continue;\n        \n        temp = value[i] - '0';\n        if (temp < 0)\n            temp = 10 + temp;\n        \n        if (i == 0) {\n            min = max = temp;\n        } else {\n            if (temp < min)\n                min = temp;\n            if (temp > max)\n                max = temp;\n        }\n    }\n    \n    diff = max - min;\n    if (diff == 0) {\n        result = max;\n    } else if (diff > 0) {\n        result = min + 1;\n    } else {\n        result = max - 1;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpdd95mgb_.d(30): Error: no property `length` for type `string`\n/tmp/tmpdd95mgb_.d(33): Error: no property `length` for type `string`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdd95mgb_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_step = 0;\n    long diff_diff = 0;\n    long diff_diff_min = 0;\n    long diff_diff_max = 0;\n    long diff_diff_step = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_step = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_step = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_step = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_step = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_step = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp6pi6hygi.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmp6pi6hygi.d(60): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6pi6hygi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long mid = 0;\n    long diff = 0;\n    \n    if (value.length() == 0)\n        return 0;\n    \n    for (int i = 0; i < value.length(); i++)\n    {\n        if (value[i] == '.')\n            continue;\n        \n        if (value[i] == '-')\n        {\n            if (i == 0)\n                continue;\n            else\n                break;\n        }\n        \n        if (value[i] == '0')\n            continue;\n        \n        if (value[i] == '1')\n        {\n            min = 1;\n            max = 1;\n            mid = 1;\n            break;\n        }\n        \n        if (value[i] == '2')\n        {\n            min = 2;\n            max = 2;\n            mid = 2;\n            break;\n        }\n        \n        if (value[i] == '3')\n        {\n            min = 3;\n            max = 3;\n            mid = 3;\n            break;\n        }\n        \n        if (value[i] == '4')\n        {\n            min = 4;\n            max = 4;\n            mid = 4;\n            break;\n        }\n        \n        if (value[i] == '5')\n        {\n            min = 5;\n            max = 5;\n            mid = 5;\n            break;\n        }\n        \n        if (value[i] == '6')\n        {\n            min = 6;\n            max = 6;\n            mid = 6;\n            break;\n        }\n        \n        if (value[i] == '7')\n        {\n            min = 7;\n            max = 7;\n            mid = 7;\n            break;\n        }\n        \n        if (value[i] == '8')\n        {\n            min = 8;\n            max = 8;\n            mid = 8;\n            break;\n        }\n        \n        if (value[i] == '9')\n        {\n            min = 9;\n            max =\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpe9ghqrct.d(117): Error: expression expected, not `unittest`\n/tmp/tmpe9ghqrct.d(118): Error: found `{` when expecting `;` following statement\n/tmp/tmpe9ghqrct.d(127): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmpe9ghqrct.d(127): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe9ghqrct.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long step_size = 1;\n    long step_size_max = 1;\n    long step_size_min = 1;\n    long step_size_min_max = 1;\n    long step_size_min_min = 1;\n    long step_size_min_max_max = 1;\n    long step_size_min_min_max = 1;\n    long step_size_min_min_max_max = 1;\n    long step_size_min_min_max_min = 1;\n    long step_size_min_min_max_min_max = 1;\n    long step_size_min_min_max_min_max_max = 1;\n    long step_size_min_min_max_min_max_min = 1;\n    long step_size_min_min_max_min_max_min_max = 1;\n    long step_size_min_min_max_min_max_min_max_max = 1;\n    long step_size_min_min_max_min_max_min_max_min = 1;\n    long step_size_min_min_max_min_max_min_max_min_max = 1;\n    long step_size_min_min_max_min_max_min_max_min_max_max = 1;\n    long step_size_min_min_max_min_max_min_max_min_max_min = 1;\n    long step_size_min_min_max_min_max_min_max_min_max_min_max = 1;\n    long step_size_min_min_max_min_max_min_max_min_max_min_max_max = 1;\n    long step_size_min_min_max_min_max_min_max_min_max_min_max_min = 1;\n    long step_size_min_min_max_min_max_min_max_min_max_min_max_min_max = 1;\n    long step_size_min_min_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp81htk1ek.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmp81htk1ek.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp81htk1ek.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 1;\n    long int_part_abs = 0;\n    long int_part_sign = 1;\n    long int_part_abs_temp = 0;\n    long frac_part_abs_temp = 0;\n    long frac_part_abs_temp_sign = 1;\n    long frac_part_abs_temp_sign_temp = 1;\n    long int_part_abs_temp_sign_temp = 1;\n    long int_part_abs_temp_sign_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp_temp = 1;\n    long int_part_abs_temp_sign_temp_temp_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp_temp_temp_temp = 1;\n    long int_part_abs_temp_sign_temp_temp_temp_temp_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp_temp_temp_temp_temp_temp = 1;\n    long int_part_abs_temp_sign_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long int_part_abs_temp_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long int_part_abs_temp_sign_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp = 1;\n    long frac_part_abs_temp_sign_temp_temp\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpp1qvn1q8.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmpp1qvn1q8.d(49): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp1qvn1q8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long exponent = 0;\n    long mantissa = 0;\n    long exponent_sign = 1;\n    long mantissa_sign = 1;\n    long mantissa_exponent = 0;\n    long mantissa_mantissa = 0;\n    long mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_exponent = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa = 0;\n    long mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mantissa_mant\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmps0yap7p5.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmps0yap7p5.d(49): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps0yap7p5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long int_part_prev;\n    long frac_part_prev;\n    long frac_part_next;\n    long int_part_next;\n    long frac_part_next_prev;\n    long int_part_next_prev;\n    long frac_part_next_next;\n    long int_part_next_next;\n    long frac_part_next_next_prev;\n    long int_part_next_next_prev;\n    long frac_part_next_next_next;\n    long int_part_next_next_next;\n    long frac_part_next_next_next_prev;\n    long int_part_next_next_next_prev;\n    long frac_part_next_next_next_next;\n    long int_part_next_next_next_next;\n    long frac_part_next_next_next_next_prev;\n    long int_part_next_next_next_next_prev;\n    long frac_part_next_next_next_next_next;\n    long int_part_next_next_next_next_next;\n    long frac_part_next_next_next_next_next_prev;\n    long int_part_next_next_next_next_next_prev;\n    long frac_part_next_next_next_next_next_next;\n    long int_part_next_next_next_next_next_next;\n    long frac_part_next_next_next_next_next_next_prev;\n    long int_part_next_next_next_next_next_next_prev;\n    long frac_part_next_next_next_next_next_next_next;\n    long int_part_next_next_next_next_next_next_next;\n    long frac_part_next_next_next_next_next_next_next_prev;\n    long int_part_next_next_next_next_next_next_next_prev;\n    long frac_part_next_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcu5if30k.d(58): Error: semicolon expected, not `unittest`\n/tmp/tmpcu5if30k.d(58): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcu5if30k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long temp = 0;\n    long power = 1;\n    long power_of_ten = 1;\n    long power_of_ten_minus_1 = 1;\n    long power_of_ten_minus_2 = 1;\n    long power_of_ten_minus_3 = 1;\n    long power_of_ten_minus_4 = 1;\n    long power_of_ten_minus_5 = 1;\n    long power_of_ten_minus_6 = 1;\n    long power_of_ten_minus_7 = 1;\n    long power_of_ten_minus_8 = 1;\n    long power_of_ten_minus_9 = 1;\n    long power_of_ten_minus_10 = 1;\n    long power_of_ten_minus_11 = 1;\n    long power_of_ten_minus_12 = 1;\n    long power_of_ten_minus_13 = 1;\n    long power_of_ten_minus_14 = 1;\n    long power_of_ten_minus_15 = 1;\n    long power_of_ten_minus_16 = 1;\n    long power_of_ten_minus_17 = 1;\n    long power_of_ten_minus_18 = 1;\n    long power_of_ten_minus_19 = 1;\n    long power_of_ten_minus_20 = 1;\n    long power_of_ten_minus_21 = 1;\n    long power_of_ten_minus_22 = 1;\n    long power_of_ten_minus_23 = 1;\n    long power_of_ten_minus_24 = 1;\n    long power_of_ten_minus_25 = 1;\n    long power_of_ten_minus_26 = 1;\n    long power_of_ten_minus_27 = 1;\n    long power_of_ten_minus_28 = 1;\n    long power_of_ten_minus_29 = 1;\n    long power_of_ten_minus_30 = 1;\n    long power_of_ten_minus_31 = 1;\n    long power_of_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp2kbzco91.d(61): Error: semicolon expected, not `unittest`\n/tmp/tmp2kbzco91.d(61): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2kbzco91.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long max_diff_pos = 0;\n    long diff_pos = 0;\n    long pos = 0;\n    long pos_diff = 0;\n    long pos_diff_pos = 0;\n    long pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff = 0;\n    long pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos_diff_pos\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcxuutq30.d(48): Error: semicolon expected, not `unittest`\n/tmp/tmpcxuutq30.d(48): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcxuutq30.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long max_diff_pos = 0;\n    long diff_pos = 0;\n    long pos = 0;\n    long max_diff_neg = 0;\n    long diff_neg = 0;\n    long max_diff_neg_pos = 0;\n    long diff_neg_pos = 0;\n    long pos_neg = 0;\n    long max_diff_pos_neg = 0;\n    long diff_pos_neg = 0;\n    long pos_neg_pos = 0;\n    long diff_pos_neg_pos = 0;\n    long pos_neg_neg = 0;\n    long diff_pos_neg_neg = 0;\n    long pos_pos = 0;\n    long diff_pos_pos = 0;\n    long pos_pos_pos = 0;\n    long diff_pos_pos_pos = 0;\n    long pos_pos_neg = 0;\n    long diff_pos_pos_neg = 0;\n    long pos_pos_neg_pos = 0;\n    long diff_pos_pos_neg_pos = 0;\n    long pos_pos_neg_neg = 0;\n    long diff_pos_pos_neg_neg = 0;\n    long pos_pos_pos_pos = 0;\n    long diff_pos_pos_pos_pos = 0;\n    long pos_pos_pos_neg = 0;\n    long diff_pos_pos_pos_neg = 0;\n    long pos_pos_pos_neg_pos = 0;\n    long diff_pos_pos_pos_neg_pos = 0;\n    long pos_pos_pos_neg_neg = 0;\n    long diff_pos_pos_pos_neg_neg = 0;\n    long pos_pos_pos_pos_pos = 0;\n    long diff_pos_pos_pos_pos_pos = 0;\n    long pos_pos_pos_pos_neg = 0;\n    long diff_pos_pos_pos_pos_neg = 0;\n    long pos_pos_pos_pos_neg_pos = 0;\n    long diff_pos_pos_pos_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp44f68osw.d(65): Error: semicolon expected, not `unittest`\n/tmp/tmp44f68osw.d(65): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp44f68osw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long number = 0;\n    long number_of_digits = 0;\n    long number_of_decimals = 0;\n    long number_of_decimals_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_towards_zero = 0;\n    long number_of_decimals_to_round_towards_zero_max = 0;\n    long number_of_decimals_to_round_towards_zero_min = 0;\n    long number_of_decimals_to_round_away_from_zero_max = 0;\n    long number_of_decimals_to_round_away_from_zero_min = 0;\n    long number_of_decimals_to_round_towards_zero_max = 0;\n    long number_of_decimals_to_round_towards_zero_min = 0;\n    long number_of_decimals_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_towards_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_max = 0;\n    long number_of_decimals_to_round_away_from_zero_min = 0;\n    long number_of_decimals_to_round_towards_zero_max = 0;\n    long number_of_decimals_to_round_towards_zero_min = 0;\n    long number_of_decimals_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_towards_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_max = 0;\n    long number_of_decimals_to_round_away_from_zero_min = 0;\n    long number_of_decimals_to_round_towards_zero\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpkedthole.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmpkedthole.d(49): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkedthole.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long temp = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpm5hhih9z.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm5hhih9z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long sign = 1;\n    long frac_part_sign = 1;\n    long exp = 0;\n    long exp_sign = 1;\n    long exp_digit = 0;\n    long exp_digit_sign = 1;\n    long exp_digit_value = 0;\n    long frac_part_value = 0;\n    long frac_part_value_sign = 1;\n    long int_part_value = 0;\n    long int_part_value_sign = 1;\n    long int_part_value_value = 0;\n    long int_part_value_value_sign = 1;\n    long frac_part_value_value = 0;\n    long frac_part_value_value_sign = 1;\n    long frac_part_value_value_value = 0;\n    long frac_part_value_value_value_sign = 1;\n    long int_part_value_value_value = 0;\n    long int_part_value_value_value_sign = 1;\n    long int_part_value_value_value_value = 0;\n    long int_part_value_value_value_value_sign = 1;\n    long frac_part_value_value_value_value = 0;\n    long frac_part_value_value_value_value_sign = 1;\n    long frac_part_value_value_value_value_value = 0;\n    long frac_part_value_value_value_value_value_sign = 1;\n    long int_part_value_value_value_value_value = 0;\n    long int_part_value_value_value_value_value_sign = 1;\n    long int_part_value_value_value_value_value_value = 0;\n    long int_part_value_value_value_value_value_value_sign = 1;\n    long frac_part_value_value_value_value_value_value = 0;\n    long frac_part_value_value_value_value_value_value_sign = 1\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpeqdd9x86.d(58): Error: semicolon expected, not `unittest`\n/tmp/tmpeqdd9x86.d(58): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeqdd9x86.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp18dhevl5.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18dhevl5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long mid = 0;\n    long diff = 0;\n    long diff_min = 0;\n    long diff_max = 0;\n    long diff_mid = 0;\n    long diff_diff = 0;\n    long diff_diff_min = 0;\n    long diff_diff_max = 0;\n    long diff_diff_mid = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_mid = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_mid = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_mid = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_mid = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_diff_diff_mid = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmplk6hrxjw.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmplk6hrxjw.d(60): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplk6hrxjw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long int_value = 0;\n    long int_diff = 0;\n    long int_max_diff = 0;\n    long int_max_diff_int = 0;\n    long int_max_diff_int_int = 0;\n    long int_max_diff_int_int_int = 0;\n    long int_max_diff_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int_int = 0;\n    long int_max_diff_int_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp41a3c0zw.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp41a3c0zw.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp41a3c0zw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fraction = 0;\n    long frac_part_fraction_int = 0;\n    long frac_part_fraction_fraction = 0;\n    long frac_part_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_int = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long frac_part_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmps29br9vt.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmps29br9vt.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps29br9vt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_digit = 0;\n    long max_power = 0;\n    long max_digit_power = 0;\n    long max_digit_power_value = 0;\n    long max_digit_power_sign = 0;\n    long max_digit_power_sign_value = 0;\n    long max_digit_power_sign_sign = 0;\n    long max_digit_power_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpitgyd2ao.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpitgyd2ao.d(52): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpitgyd2ao.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result;\n    long int_part;\n    long frac_part;\n    long frac_part_int;\n    long frac_part_frac;\n    long frac_part_frac_int;\n    long frac_part_frac_frac;\n    long frac_part_frac_frac_int;\n    long frac_part_frac_frac_frac;\n    long frac_part_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int;\n    long frac_part_frac_frac_frac_frac_frac_frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpcgif8kq3.d(51): Error: semicolon expected, not `unittest`\n/tmp/tmpcgif8kq3.d(51): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgif8kq3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    long number = 0;\n    long number_of_digits = 0;\n    long number_of_decimals = 0;\n    long number_of_decimals_to_round = 0;\n    long number_of_decimals_to_round_away_from_zero = 0;\n    long number_of_decimals_to_round_away_from_zero_diff = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_min = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max_diff = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_min_diff = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max_diff_abs = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_min_diff_abs = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max_diff_abs_max = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_min_diff_abs_min = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max_diff_abs_min = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max_diff_abs_min_diff = 0;\n    long number_of_decimals_to_round_away_from_zero_diff_abs_max_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpo8_mlsob.d(46): Error: semicolon expected, not `unittest`\n/tmp/tmpo8_mlsob.d(46): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo8_mlsob.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 1;\n    long step_size = 1;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpg43wwtys.d(95): Error: expression expected, not `unittest`\n/tmp/tmpg43wwtys.d(96): Error: semicolon expected, not `{`\n/tmp/tmpg43wwtys.d(105): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg43wwtys.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long step = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp0_on7w6m.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp0_on7w6m.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0_on7w6m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long temp = 0;\n    long min_diff = 0;\n    long min_temp = 0;\n    long max_temp = 0;\n    long min_temp_diff = 0;\n    long max_temp_diff = 0;\n    long temp_diff = 0;\n    long temp_diff_min = 0;\n    long temp_diff_max = 0;\n    long temp_diff_min_temp = 0;\n    long temp_diff_max_temp = 0;\n    long temp_diff_min_temp_diff = 0;\n    long temp_diff_max_temp_diff = 0;\n    long temp_diff_min_temp_diff_min = 0;\n    long temp_diff_max_temp_diff_max = 0;\n    long temp_diff_min_temp_diff_min_temp = 0;\n    long temp_diff_max_temp_diff_max_temp = 0;\n    long temp_diff_min_temp_diff_min_temp_diff = 0;\n    long temp_diff_max_temp_diff_max_temp_diff = 0;\n    long temp_diff_min_temp_diff_min_temp_diff_min = 0;\n    long temp_diff_max_temp_diff_max_temp_diff_max = 0;\n    long temp_diff_min_temp_diff_min_temp_diff_min_temp = 0;\n    long temp_diff_max_temp_diff_max_temp_diff_max_temp = 0;\n    long temp_diff_min_temp_diff_min_temp_diff_min_temp_diff = 0;\n    long temp_diff_max_temp_diff_max_temp_diff_max_temp_diff = 0;\n    long temp_diff_min_temp_diff_min_temp_diff_min_temp_diff_min = 0;\n    long temp_diff_max_temp_diff_max_temp_diff_max_temp_diff_max = 0;\n    long temp_diff_min_temp_diff_min_temp_diff_min_temp_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpfjcntrbw.d(55): Error: semicolon expected, not `unittest`\n/tmp/tmpfjcntrbw.d(55): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfjcntrbw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long number = 0;\n    long sign = 1;\n    long factor = 1;\n    long power = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp9j_parco.d(89): Error: semicolon expected, not `unittest`\n/tmp/tmp9j_parco.d(89): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9j_parco.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_sign = 1;\n    long frac_part_abs = 0;\n    long frac_part_abs_sign = 1;\n    long int_part_abs = 0;\n    long int_part_abs_sign = 1;\n    long int_part_sign = 1;\n    long frac_part_abs_sign = 1;\n    long frac_part_abs_sign_sign = 1;\n    long int_part_abs_sign_sign = 1;\n    long int_part_abs_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 1;\n    long int_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp4h5rsu0q.d(49): Error: semicolon expected, not `unittest`\n/tmp/tmp4h5rsu0q.d(49): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4h5rsu0q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    long temp = 0;\n    long temp_diff = 0;\n    long temp_min_diff = 0;\n    long temp_max_diff = 0;\n    long temp_diff_min = 0;\n    long temp_diff_max = 0;\n    long temp_diff_min_max = 0;\n    long temp_diff_min_max_min = 0;\n    long temp_diff_min_max_max = 0;\n    long temp_diff_min_max_min_max = 0;\n    long temp_diff_min_max_min_max_min = 0;\n    long temp_diff_min_max_min_max_max = 0;\n    long temp_diff_min_max_min_max_min_max = 0;\n    long temp_diff_min_max_min_max_min_max_min = 0;\n    long temp_diff_min_max_min_max_min_max_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_min = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_min_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_min_max_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_min_max_min_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_min_max_min_max_max = 0;\n    long temp_diff_min_max_min_max_min_max_min_max_min_max_min_max_min_max = 0;\n    long temp_diff_min_max\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmpguilsqe_.d(52): Error: semicolon expected, not `unittest`\n/tmp/tmpguilsqe_.d(52): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpguilsqe_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_fract = 0;\n    long frac_part_fract_int = 0;\n    long frac_part_fract_fract = 0;\n    long frac_part_fract_fract_int = 0;\n    long frac_part_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract = 0;\n    long frac_part_fract_fract_fract_fract_fract_fract_fract_fract_fract_int = 0;\n    long frac\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp3jr7dheo.d(47): Error: semicolon expected, not `unittest`\n/tmp/tmp3jr7dheo.d(47): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3jr7dheo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_abs = 0;\n    long frac_part_sign = 0;\n    long frac_part_abs_sign = 0;\n    long frac_part_abs_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long frac_part_abs_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmppi72g0jk.d(45): Error: semicolon expected, not `unittest`\n/tmp/tmppi72g0jk.d(45): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppi72g0jk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long int_part = 0;\n    long frac_part = 0;\n    long frac_part_int = 0;\n    long frac_part_frac = 0;\n    long frac_part_frac_int = 0;\n    long frac_part_frac_frac = 0;\n    long frac_part_frac_frac_int = 0;\n    long frac_part_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int = 0;\n    long frac_part_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac = 0;\n\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmp7ehdrhk8.d(50): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7ehdrhk8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer(\"10\")\n    10L\n    >>> closest_integer(\"15.3\")\n    15L\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \n*/\nlong closest_integer(string value) \n{\n    long result = 0;\n    long min = 0;\n    long max = 0;\n    long diff = 0;\n    \n    for(int i = 0; i < value.length(); i++)\n    {\n        if(value[i] == '.')\n        {\n            continue;\n        }\n        \n        if(value[i] == '-')\n        {\n            if(i == 0)\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '-')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '.')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '0')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '1')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '2')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '3')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '4')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '5')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '6')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '7')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '8')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '9')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '0')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '1')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '2')\n            {\n                continue;\n            }\n            \n            if(value[i-1] == '\nunittest\n{\n    alias candidate = closest_integer;\n\n    assert(candidate(\"10\") == 10L);\n    assert(candidate(\"14.5\") == 15L);\n    assert(candidate(\"-15.5\") == -16L);\n    assert(candidate(\"15.3\") == 15L);\n    assert(candidate(\"0\") == 0L);\n}\nvoid main(){}",
      "timestamp": 1664293253,
      "stdout": "",
      "stderr": "/tmp/tmppfz4qz8t.d(118): Error: unterminated character constant\n/tmp/tmppfz4qz8t.d(119): Error: found `unittest` when expecting `)`\n/tmp/tmppfz4qz8t.d(129): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppfz4qz8t.d(129): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmppfz4qz8t.d(129): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfz4qz8t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}