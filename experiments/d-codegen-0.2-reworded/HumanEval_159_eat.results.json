{
  "name": "HumanEval_159_eat",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n",
  "tests": "unittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_now = 0;\n    long left = 0;\n    long left_now = 0;\n    \n    if (number >= need) {\n        eaten = number - need;\n        left = remaining - eaten;\n        ans[0] = eaten + left;\n        ans[1] = left;\n        return ans;\n    }\n    \n    if (number < need) {\n        eaten = number;\n        left = need - eaten;\n        ans[0] = eaten + left;\n        ans[1] = left;\n        return ans;\n    }\n    \n    if (number == need) {\n        eaten = number;\n        left = remaining - eaten;\n        ans[0] = eaten + left;\n        ans[1] = left;\n        return ans;\n    }\n    \n    if (number > need) {\n        eaten = number - need;\n        left = remaining - eaten;\n        ans[0] = eaten + left;\n        ans[1] = left;\n        return ans;\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpvix2gknm.d(83): unittest failure\n----------------\n??:? _d_unittestp [0x4285cd]\n??:? void tmpvix2gknm.__unittest_L79_C1() [0x42807c]\n??:? void tmpvix2gknm.__modtest() [0x428350]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c687]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b51a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307a5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c54]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430731]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4f1]\n??:? runModuleUnitTests [0x42c45d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a90]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0)\n        result[1] = 0;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpg3rjht_w.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpg3rjht_w.__unittest_L46_C1() [0x42809d]\n??:? void tmpg3rjht_w.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_remaining = 0;\n    if (number >= need) {\n        eaten = number - need;\n        eaten_remaining = remaining - eaten;\n        ans[0] = eaten + eaten_remaining;\n        ans[1] = eaten_remaining;\n    } else {\n        ans[0] = number;\n        ans[1] = remaining;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx_6c5qeo.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x4284bd]\n??:? void tmpx_6c5qeo.__unittest_L53_C1() [0x427f68]\n??:? void tmpx_6c5qeo.__modtest() [0x42823c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c577]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b40a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430695]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b44]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430621]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e1]\n??:? runModuleUnitTests [0x42c34d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428980]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long eaten_remaining = 0;\n    \n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number < need) {\n        ans[0] = 0;\n        ans[1] = need - number;\n        return ans;\n    }\n    \n    if (number == need) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number > need) {\n        if (remaining >= need) {\n            ans[0] = number - need;\n            ans[1] = 0;\n            return ans;\n        }\n        \n        if (remaining < need) {\n            ans[0] = number - need;\n            ans[1] = 0;\n            return ans;\n        }\n        \n        if (remaining == need) {\n            ans[0] = number - need;\n            ans[1] = 0;\n            return ans;\n        }\n    }\n    \n    if (number == need) {\n        if (remaining == need) {\n            ans[0] = 0;\n            ans[1] = 0;\n            return ans;\n        }\n        \n        if (remaining > need) {\n            ans[0] = 0;\n            ans[1] = need - remaining;\n            return ans;\n        }\n        \n        if (remaining < need) {\n            ans[0] = 0;\n            ans[1] = need - remaining;\n            return ans;\n        }\n    }\n    \n    if (number < need) {\n        if (remaining == need) {\n            ans[0] = 0;\n            ans[1] = 0;\n            return ans;\n        }\n        \n        if (remaining > need) {\n            ans[0] = 0;\n            ans[1] = need - remaining;\n            return ans;\n        }\n        \n        if (remaining < need\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292598,
      "stdout": "",
      "stderr": "/tmp/tmp5_fu087y.d(116): Error: found `unittest` when expecting `)`\n/tmp/tmp5_fu087y.d(127): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp5_fu087y.d(127): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5_fu087y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (need > remaining) {\n        ans[0] = number;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    while (need > 0) {\n        if (need > remaining) {\n            eaten = remaining;\n            left = 0;\n        } else {\n            eaten = need;\n            left = need - eaten;\n        }\n        \n        number += eaten;\n        need -= eaten;\n        remaining -= eaten;\n    }\n    \n    ans[0] = number;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpurabhkdp.d(77): unittest failure\n----------------\n??:? _d_unittestp [0x42857d]\n??:? void tmpurabhkdp.__unittest_L73_C1() [0x428028]\n??:? void tmpurabhkdp.__modtest() [0x4282fc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c637]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430755]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c04]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a1]\n??:? runModuleUnitTests [0x42c40d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a40]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    ans[0] = number + need;\n    ans[1] = remaining - need;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx820zlq9.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpx820zlq9.__unittest_L44_C1() [0x428049]\n??:? void tmpx820zlq9.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n    } else {\n        ans[0] = 0;\n        ans[1] = need - number;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8q4b6jh5.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp8q4b6jh5.__unittest_L49_C1() [0x427f60]\n??:? void tmp8q4b6jh5.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        eaten = need;\n        left = 0;\n    } else if (number < need) {\n        eaten = number;\n        left = need - number;\n    } else {\n        eaten = number;\n        left = 0;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgp0c42ew.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x42849d]\n??:? void tmpgp0c42ew.__unittest_L59_C1() [0x427f48]\n??:? void tmpgp0c42ew.__modtest() [0x42821c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c557]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430675]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b24]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430601]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c1]\n??:? runModuleUnitTests [0x42c32d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428960]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        eaten = number - need;\n        left = 0;\n    } else {\n        eaten = number;\n        left = need - number;\n    }\n    \n    if (eaten > remaining) {\n        eaten = remaining;\n        left = 0;\n    } else {\n        left = remaining - eaten;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp00hs6_f8.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp00hs6_f8.__unittest_L63_C1() [0x427f60]\n??:? void tmp00hs6_f8.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = number;\n    long eat = need;\n    long left = remaining;\n    \n    while(eat > 0 && left > 0)\n    {\n        if(eat >= left)\n        {\n            eat -= left;\n            left = 0;\n        }\n        else\n        {\n            left -= eat;\n            eat = 0;\n        }\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpl44fy32c.d(66): unittest failure\n----------------\n??:? _d_unittestp [0x42849d]\n??:? void tmpl44fy32c.__unittest_L62_C1() [0x427f4c]\n??:? void tmpl44fy32c.__modtest() [0x428220]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c557]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430675]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b24]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430601]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c1]\n??:? runModuleUnitTests [0x42c32d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428960]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    ans[0] = number + need;\n    ans[1] = remaining - need;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx820zlq9.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpx820zlq9.__unittest_L44_C1() [0x428049]\n??:? void tmpx820zlq9.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    ans[0] = number + need;\n    ans[1] = remaining - need;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpx820zlq9.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpx820zlq9.__unittest_L44_C1() [0x428049]\n??:? void tmpx820zlq9.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    ans[0] = number + need;\n    ans[1] = remaining - need;\n    if (ans[1] < 0)\n        ans[1] = 0;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0e_dlczy.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmp0e_dlczy.__unittest_L46_C1() [0x42809d]\n??:? void tmp0e_dlczy.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = number;\n    long eaten_need = 0;\n    long left = remaining;\n    \n    if (need > 0)\n    {\n        if (need <= remaining)\n        {\n            eaten_need = need;\n            left -= need;\n        }\n        else\n        {\n            eaten_need = remaining;\n            left = 0;\n        }\n        \n        if (eaten_need > 0)\n        {\n            eaten += eaten_need;\n        }\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n    } else {\n        ans[0] = 0;\n        ans[1] = need - number;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8q4b6jh5.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp8q4b6jh5.__unittest_L49_C1() [0x427f60]\n??:? void tmp8q4b6jh5.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0)\n    {\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgjcvashi.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpgjcvashi.__unittest_L48_C1() [0x42809d]\n??:? void tmpgjcvashi.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long eaten_remaining = 0;\n    \n    if (number < need) {\n        ans[0] = number;\n        ans[1] = need - number;\n        return ans;\n    }\n    \n    while (need > 0) {\n        if (remaining > 0) {\n            if (need > remaining) {\n                eaten_need = remaining;\n                eaten_remaining = need - eaten_need;\n                eaten = eaten_need + eaten_remaining;\n                need = 0;\n            } else {\n                eaten_need = need;\n                eaten_remaining = 0;\n                eaten = eaten_need;\n                need = need - eaten_need;\n            }\n        } else {\n            eaten_need = need;\n            eaten_remaining = 0;\n            eaten = eaten_need;\n            need = 0;\n        }\n    }\n    \n    ans[0] = eaten;\n    ans[1] = eaten_remaining;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpp73o2k5a.d(79): unittest failure\n----------------\n??:? _d_unittestp [0x428535]\n??:? void tmpp73o2k5a.__unittest_L75_C1() [0x427fe0]\n??:? void tmpp73o2k5a.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b482]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43070d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430699]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b459]\n??:? runModuleUnitTests [0x42c3c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    if (number >= need) {\n        eaten = number - need;\n        left = need;\n    } else {\n        eaten = number;\n        left = need - number;\n    }\n    ans[0] = eaten;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpenyjx6v2.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42848d]\n??:? void tmpenyjx6v2.__unittest_L53_C1() [0x427f38]\n??:? void tmpenyjx6v2.__modtest() [0x42820c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c547]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430665]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]\n??:? runModuleUnitTests [0x42c31d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428950]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0)\n    {\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgjcvashi.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpgjcvashi.__unittest_L48_C1() [0x42809d]\n??:? void tmpgjcvashi.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number;\n        ans[1] = 0;\n        return ans;\n    }\n    long[] ans1 = eat(number + 1, need, remaining);\n    long[] ans2 = eat(number + 1, need - number, remaining - number);\n    ans[0] = ans1[0] + ans2[0];\n    ans[1] = ans1[1] + ans2[1];\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfedgdi15.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428585]\n??:? void tmpfedgdi15.__unittest_L51_C1() [0x428030]\n??:? void tmpfedgdi15.__modtest() [0x428304]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c63f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43075d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c0c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a9]\n??:? runModuleUnitTests [0x42c415]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long eaten_remaining = 0;\n    \n    if(number >= need)\n    {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if(number < need)\n    {\n        ans[0] = 0;\n        ans[1] = need - number;\n        return ans;\n    }\n    \n    if(number < remaining)\n    {\n        ans[0] = number;\n        ans[1] = remaining - number;\n        return ans;\n    }\n    \n    if(number == remaining)\n    {\n        ans[0] = number;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if(number > remaining)\n    {\n        ans[0] = remaining;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpypljcve0.d(85): unittest failure\n----------------\n??:? _d_unittestp [0x42861d]\n??:? void tmpypljcve0.__unittest_L81_C1() [0x4280cc]\n??:? void tmpypljcve0.__modtest() [0x4283a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c6d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b56a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4307f5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ca4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430781]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b541]\n??:? runModuleUnitTests [0x42c4ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ae0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number >= need) {\n        result[0] = number - need;\n        result[1] = 0;\n    } else {\n        result[0] = 0;\n        result[1] = need - number;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_gq6vjt6.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp_gq6vjt6.__unittest_L49_C1() [0x427f60]\n??:? void tmp_gq6vjt6.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_remaining = 0;\n    long eaten_need = 0;\n    long eaten_remaining_need = 0;\n    \n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number < need) {\n        ans[0] = 0;\n        ans[1] = need - number;\n        return ans;\n    }\n    \n    if (remaining >= need) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (remaining < need) {\n        ans[0] = 0;\n        ans[1] = need - remaining;\n        return ans;\n    }\n    \n    if (number >= remaining) {\n        ans[0] = number - remaining;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number < remaining) {\n        ans[0] = 0;\n        ans[1] = remaining - number;\n        return ans;\n    }\n    \n    if (number == remaining) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number > remaining) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number == remaining) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number == remaining) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number == remaining) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number == remaining) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292598,
      "stdout": "",
      "stderr": "/tmp/tmplvdranib.d(118): Error: expression expected, not `unittest`\n/tmp/tmplvdranib.d(119): Error: found `{` when expecting `)`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplvdranib.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long left = 0;\n    if(number >= need)\n    {\n        eaten = number - need;\n        left = number - eaten;\n        ans[0] = eaten + left;\n        ans[1] = 0;\n    }\n    else if(number < need)\n    {\n        eaten = number;\n        left = need - number;\n        ans[0] = eaten + left;\n        ans[1] = 0;\n    }\n    else\n    {\n        eaten = number;\n        left = need;\n        ans[0] = eaten + left;\n        ans[1] = 0;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppgfjzdxx.d(70): unittest failure\n----------------\n??:? _d_unittestp [0x428545]\n??:? void tmppgfjzdxx.__unittest_L66_C1() [0x427ff4]\n??:? void tmppgfjzdxx.__modtest() [0x4282c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ff]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b492]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43071d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bcc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b469]\n??:? runModuleUnitTests [0x42c3d5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a08]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    if (number >= need) {\n        eaten = need;\n        left = number - need;\n    } else {\n        eaten = number;\n        left = need - number;\n    }\n    if (left > remaining) {\n        eaten = eaten + left;\n        left = 0;\n    }\n    ans[0] = eaten;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplqkidlip.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x4284ad]\n??:? void tmplqkidlip.__unittest_L57_C1() [0x427f58]\n??:? void tmplqkidlip.__modtest() [0x42822c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c567]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430685]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b34]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430611]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d1]\n??:? runModuleUnitTests [0x42c33d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428970]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number >= need) {\n        result[0] = number - need;\n        result[1] = 0;\n    } else {\n        result[0] = 0;\n        result[1] = need - number;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_gq6vjt6.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp_gq6vjt6.__unittest_L49_C1() [0x427f60]\n??:? void tmp_gq6vjt6.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    if (number >= need) {\n        eaten = number - need;\n        left = need;\n    } else {\n        eaten = number;\n        left = need - number;\n    }\n    ans[0] = eaten;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpenyjx6v2.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x42848d]\n??:? void tmpenyjx6v2.__unittest_L53_C1() [0x427f38]\n??:? void tmpenyjx6v2.__modtest() [0x42820c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c547]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430665]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]\n??:? runModuleUnitTests [0x42c31d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428950]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long left = 0;\n    \n    if(number >= need)\n    {\n        eaten = number - need;\n        left = number - eaten;\n        ans[0] = eaten + left;\n        ans[1] = 0;\n    }\n    else if(number < need)\n    {\n        eaten = number;\n        left = need - eaten;\n        ans[0] = eaten + left;\n        ans[1] = 0;\n    }\n    else if(number == need)\n    {\n        eaten = need;\n        left = 0;\n        ans[0] = need;\n        ans[1] = 0;\n    }\n    else if(number > need)\n    {\n        eaten = need;\n        left = number - need;\n        ans[0] = need;\n        ans[1] = left;\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0rbbe0bc.d(79): unittest failure\n----------------\n??:? _d_unittestp [0x428595]\n??:? void tmp0rbbe0bc.__unittest_L75_C1() [0x428040]\n??:? void tmp0rbbe0bc.__modtest() [0x428314]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c64f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43076d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4b9]\n??:? runModuleUnitTests [0x42c425]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a58]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    if(number >= need)\n    {\n        eaten = number - need;\n        left = need;\n    }\n    else\n    {\n        eaten = number;\n        left = need - number;\n    }\n    ans[0] = eaten;\n    ans[1] = left;\n    return ans;\n}\n\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpy9eq53fm.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x42848d]\n??:? void tmpy9eq53fm.__unittest_L57_C1() [0x427f38]\n??:? void tmpy9eq53fm.__modtest() [0x42820c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c547]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430665]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b14]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305f1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b1]\n??:? runModuleUnitTests [0x42c31d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428950]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eat = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        eaten = number - need;\n        left = need;\n    } else {\n        eaten = number;\n        left = need - number;\n    }\n    \n    if (eaten > remaining) {\n        eaten = remaining;\n        left = remaining - eaten;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1l2tjl4m.d(66): unittest failure\n----------------\n??:? _d_unittestp [0x4284ad]\n??:? void tmp1l2tjl4m.__unittest_L62_C1() [0x427f58]\n??:? void tmp1l2tjl4m.__modtest() [0x42822c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c567]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430685]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b34]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430611]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d1]\n??:? runModuleUnitTests [0x42c33d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428970]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        eaten = need;\n        left = number - need;\n    } else if (number < need && number < remaining) {\n        eaten = number;\n        left = need - number;\n    } else {\n        eaten = number;\n        left = 0;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpno2bbdpi.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x4284ad]\n??:? void tmpno2bbdpi.__unittest_L59_C1() [0x427f58]\n??:? void tmpno2bbdpi.__modtest() [0x42822c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c567]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430685]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b34]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430611]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d1]\n??:? runModuleUnitTests [0x42c33d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428970]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long eaten_remaining = 0;\n    \n    if (number < need)\n    {\n        ans[0] = number;\n        ans[1] = need - number;\n        return ans;\n    }\n    \n    while (need > 0)\n    {\n        if (need > remaining)\n        {\n            eaten_need = remaining;\n            eaten_remaining = need - eaten_need;\n            eaten = eaten_need + eaten_remaining;\n            need = 0;\n        }\n        else\n        {\n            eaten_need = need;\n            eaten_remaining = 0;\n            eaten = eaten_need;\n            need = need - eaten_need;\n        }\n    }\n    \n    ans[0] = eaten;\n    ans[1] = eaten_remaining;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpj38zhaef.d(77): unittest failure\n----------------\n??:? _d_unittestp [0x428515]\n??:? void tmpj38zhaef.__unittest_L73_C1() [0x427fc4]\n??:? void tmpj38zhaef.__modtest() [0x428298]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5cf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b462]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306ed]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b9c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430679]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b439]\n??:? runModuleUnitTests [0x42c3a5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long eaten_remaining = 0;\n    \n    if(number >= need)\n    {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if(number < need)\n    {\n        ans[0] = 0;\n        ans[1] = need - number;\n        return ans;\n    }\n    \n    if(number == need)\n    {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if(number > need)\n    {\n        if(remaining >= need)\n        {\n            ans[0] = number - need;\n            ans[1] = 0;\n            return ans;\n        }\n        \n        if(remaining < need)\n        {\n            ans[0] = number - need;\n            ans[1] = need - remaining;\n            return ans;\n        }\n    }\n    \n    if(number == need)\n    {\n        if(remaining == 0)\n        {\n            ans[0] = 0;\n            ans[1] = 0;\n            return ans;\n        }\n        \n        if(remaining > 0)\n        {\n            ans[0] = 0;\n            ans[1] = need - remaining;\n            return ans;\n        }\n    }\n    \n    if(number > need)\n    {\n        if(remaining == 0)\n        {\n            ans[0] = 0;\n            ans[1] = need - number;\n            return ans;\n        }\n        \n        if(remaining > 0)\n        {\n            ans[0] = 0;\n            ans[1] = need - remaining;\n            return ans;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6zp_r7b2.d(122): unittest failure\n----------------\n??:? _d_unittestp [0x4287ed]\n??:? void tmp6zp_r7b2.__unittest_L118_C1() [0x42829c]\n??:? void tmp6zp_r7b2.__modtest() [0x428570]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b73a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4309c5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430e74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430951]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b711]\n??:? runModuleUnitTests [0x42c67d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cb0]\n??:? void rt.dmain2._d",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    if (number + remaining >= need) {\n        ans[0] = number + remaining;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    ans[0] = number + remaining;\n    ans[1] = need - (number + remaining);\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxylzdd_q.d(60): unittest failure\n----------------\n??:? _d_unittestp [0x428535]\n??:? void tmpxylzdd_q.__unittest_L56_C1() [0x427fe0]\n??:? void tmpxylzdd_q.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b482]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43070d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bbc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430699]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b459]\n??:? runModuleUnitTests [0x42c3c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_now = 0;\n    long left = 0;\n    long left_now = 0;\n    \n    if (number < need) {\n        eaten = number;\n        left = need - number;\n    } else {\n        eaten = need;\n        left = 0;\n    }\n    \n    if (remaining < left) {\n        left = remaining;\n        left_now = remaining;\n    } else {\n        left_now = left;\n    }\n    \n    eaten_now = eaten;\n    \n    ans[0] = eaten_now;\n    ans[1] = left_now;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphef509np.d(71): unittest failure\n----------------\n??:? _d_unittestp [0x4284ad]\n??:? void tmphef509np.__unittest_L67_C1() [0x427f58]\n??:? void tmphef509np.__modtest() [0x42822c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c567]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430685]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b34]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430611]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d1]\n??:? runModuleUnitTests [0x42c33d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428970]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number >= need) {\n        result[0] = number - need;\n        result[1] = 0;\n    } else {\n        result[0] = 0;\n        result[1] = need - number;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_gq6vjt6.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp_gq6vjt6.__unittest_L49_C1() [0x427f60]\n??:? void tmp_gq6vjt6.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    if (number + remaining >= need) {\n        ans[0] = number + remaining - need;\n        ans[1] = 0;\n        return ans;\n    }\n    if (number + remaining == 0) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    ans[0] = 0;\n    ans[1] = remaining;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9cj5zwvi.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x42859d]\n??:? void tmp9cj5zwvi.__unittest_L59_C1() [0x428048]\n??:? void tmp9cj5zwvi.__modtest() [0x42831c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c657]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430775]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c24]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430701]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4c1]\n??:? runModuleUnitTests [0x42c42d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a60]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n    } else {\n        ans[0] = 0;\n        ans[1] = need - number;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8q4b6jh5.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp8q4b6jh5.__unittest_L49_C1() [0x427f60]\n??:? void tmp8q4b6jh5.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        eaten = number - need;\n        left = 0;\n    } else {\n        eaten = number;\n        left = need - number;\n    }\n    \n    if (left > remaining) {\n        left = remaining;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeii0cxky.d(64): unittest failure\n----------------\n??:? _d_unittestp [0x42849d]\n??:? void tmpeii0cxky.__unittest_L60_C1() [0x427f48]\n??:? void tmpeii0cxky.__modtest() [0x42821c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c557]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430675]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b24]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430601]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c1]\n??:? runModuleUnitTests [0x42c32d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428960]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number >= need) {\n        result[0] = number;\n        result[1] = 0;\n    } else {\n        result[0] = number + need - remaining;\n        result[1] = remaining;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3fsw6nmm.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp3fsw6nmm.__unittest_L49_C1() [0x427f64]\n??:? void tmp3fsw6nmm.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number >= need) {\n        result[0] = number;\n        result[1] = 0;\n    } else {\n        result[0] = number + need - remaining;\n        result[1] = remaining;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3fsw6nmm.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp3fsw6nmm.__unittest_L49_C1() [0x427f64]\n??:? void tmp3fsw6nmm.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0) {\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa2p8bynt.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpa2p8bynt.__unittest_L47_C1() [0x42809d]\n??:? void tmpa2p8bynt.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0)\n        result[1] = 0;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpg3rjht_w.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpg3rjht_w.__unittest_L46_C1() [0x42809d]\n??:? void tmpg3rjht_w.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long eaten_remaining = 0;\n    \n    if (number >= need) {\n        eaten = number - need;\n        eaten_need = need;\n        eaten_remaining = remaining;\n    } else {\n        eaten = number;\n        eaten_need = number;\n        eaten_remaining = remaining - number;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = eaten_need;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp67ngucxp.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x428495]\n??:? void tmp67ngucxp.__unittest_L59_C1() [0x427f40]\n??:? void tmp67ngucxp.__modtest() [0x428214]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c54f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43066d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3b9]\n??:? runModuleUnitTests [0x42c325]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428958]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    if (number >= need) {\n        result[0] = number;\n        result[1] = 0;\n        return result;\n    }\n    \n    if (remaining < need) {\n        result[0] = number + remaining;\n        result[1] = 0;\n        return result;\n    }\n    \n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n    } else {\n        ans[0] = 0;\n        ans[1] = need - number;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8q4b6jh5.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp8q4b6jh5.__unittest_L49_C1() [0x427f60]\n??:? void tmp8q4b6jh5.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0) {\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpa2p8bynt.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpa2p8bynt.__unittest_L47_C1() [0x42809d]\n??:? void tmpa2p8bynt.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    if (result[1] < 0)\n    {\n        result[1] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgjcvashi.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpgjcvashi.__unittest_L48_C1() [0x42809d]\n??:? void tmpgjcvashi.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n        return ans;\n    }\n    if (number < need) {\n        ans[0] = number;\n        ans[1] = need - number;\n        return ans;\n    }\n    if (number == need) {\n        ans[0] = 0;\n        ans[1] = 0;\n        return ans;\n    }\n    if (number > need) {\n        ans[0] = 0;\n        ans[1] = number - need;\n        return ans;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpu5p090kl.d(66): unittest failure\n----------------\n??:? _d_unittestp [0x4285a5]\n??:? void tmpu5p090kl.__unittest_L62_C1() [0x428054]\n??:? void tmpu5p090kl.__modtest() [0x428328]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c65f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43077d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430709]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4c9]\n??:? runModuleUnitTests [0x42c435]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a68]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = number;\n    long eat = need;\n    long left = remaining;\n    \n    while(eat > 0 && left > 0)\n    {\n        if(eat >= left)\n        {\n            eat -= left;\n            left = 0;\n        }\n        else\n        {\n            left -= eat;\n            eat = 0;\n        }\n        \n        eaten += eat;\n    }\n    \n    ans[0] = eaten;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpujv2689m.d(69): unittest failure\n----------------\n??:? _d_unittestp [0x4284a5]\n??:? void tmpujv2689m.__unittest_L65_C1() [0x427f54]\n??:? void tmpujv2689m.__modtest() [0x428228]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c55f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3f2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43067d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b2c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430609]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3c9]\n??:? runModuleUnitTests [0x42c335]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428968]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = number;\n    long left = need;\n    long eaten_this_time = 0;\n    long left_this_time = 0;\n    \n    while (left > 0) {\n        if (left >= remaining) {\n            left_this_time = remaining;\n            left -= remaining;\n            eaten_this_time += remaining;\n        } else {\n            left_this_time = left;\n            left = 0;\n            eaten_this_time += left_this_time;\n        }\n        eaten += eaten_this_time;\n        left -= left_this_time;\n        remaining -= eaten_this_time;\n    }\n    ans[0] = eaten;\n    ans[1] = remaining;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292614,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number - need;\n        ans[1] = 0;\n    } else {\n        ans[0] = 0;\n        ans[1] = need - number;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8q4b6jh5.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4284b5]\n??:? void tmp8q4b6jh5.__unittest_L49_C1() [0x427f60]\n??:? void tmp8q4b6jh5.__modtest() [0x428234]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c56f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b402]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43068d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b3c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430619]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3d9]\n??:? runModuleUnitTests [0x42c345]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428978]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    if (number >= need) {\n        ans[0] = number;\n        ans[1] = 0;\n        return ans;\n    }\n    \n    long eaten = 0;\n    long left = 0;\n    while (need > 0) {\n        if (need > remaining) {\n            eaten += remaining;\n            left = 0;\n        } else {\n            eaten += need;\n            left = remaining - need;\n        }\n        need -= eaten;\n        remaining -= eaten;\n    }\n    \n    ans[0] = eaten + number;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292614,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = number;\n    long eat = need;\n    long left = remaining;\n    \n    if (eat >= left) {\n        eat = left;\n        left = 0;\n    } else {\n        left -= eat;\n    }\n    \n    ans[0] = eaten + eat;\n    ans[1] = left;\n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] ans = new long[2];\n    long eaten = 0;\n    long eaten_need = 0;\n    long left = 0;\n    \n    if (number >= need) {\n        eaten = number - need;\n        left = number - eaten;\n    } else {\n        eaten = number;\n        left = need - eaten;\n    }\n    \n    if (left >= remaining) {\n        eaten_need = left - remaining;\n        left = remaining;\n    } else {\n        eaten_need = 0;\n    }\n    \n    ans[0] = eaten + eaten_need;\n    ans[1] = left;\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7mgt0eau.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x4284c5]\n??:? void tmp7mgt0eau.__unittest_L64_C1() [0x427f70]\n??:? void tmp7mgt0eau.__modtest() [0x428244]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c57f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b412]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43069d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b4c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430629]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3e9]\n??:? runModuleUnitTests [0x42c355]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428988]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n    \n    Example:\n    >>> eat(5L, 6L, 10L)\n    [11L, 4L]\n    >>> eat(4L, 8L, 9L)\n    [12L, 1L]\n    >>> eat(1L, 10L, 10L)\n    [11L, 0L]\n    >>> eat(2L, 11L, 5L)\n    [7L, 0L]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n\n    Have fun :)\n    \n*/\nlong[] eat(long number, long need, long remaining) \n{\n    long[] result = new long[2];\n    result[0] = number + need;\n    result[1] = remaining - need;\n    return result;\n}\nunittest\n{\n    alias candidate = eat;\n\n    assert(candidate(5L, 6L, 10L) == [11L, 4L]);\n    assert(candidate(4L, 8L, 9L) == [12L, 1L]);\n    assert(candidate(1L, 10L, 10L) == [11L, 0L]);\n    assert(candidate(2L, 11L, 5L) == [7L, 0L]);\n    assert(candidate(4L, 5L, 7L) == [9L, 2L]);\n    assert(candidate(4L, 5L, 1L) == [5L, 0L]);\n}\nvoid main(){}",
      "timestamp": 1664292599,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcx85l_iv.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428455]\n??:? void tmpcx85l_iv.__unittest_L44_C1() [0x428049]\n??:? void tmpcx85l_iv.__modtest() [0x4281d4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c50f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b3a2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x43062d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430adc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4305b9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b379]\n??:? runModuleUnitTests [0x42c2e5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428918]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}