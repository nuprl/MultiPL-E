{
  "name": "HumanEval_70_strange_sort_list",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n",
  "tests": "unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = Arrays.copyOf(result, k);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp3zcrg55x.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp3zcrg55x.d(35): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3zcrg55x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmptoam_dxi.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptoam_dxi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpb_1mwq60.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_1mwq60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        \n        if (lst[i] == min) {\n            for (int j = i + 1; j < lst.length; j++) {\n                if (lst[j] > max) {\n                    result[i] = lst[j];\n                    result[j] = lst[i];\n                    break;\n                }\n            }\n        }\n        \n        if (lst[i] == max) {\n            for (int j = i - 1; j >= 0; j--) {\n                if (lst[j] < min) {\n                    result[i] = lst[j];\n                    result[j] = lst[i];\n                    break;\n                }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp_ybda61p.d(62): unittest failure\n----------------\n??:? _d_unittestp [0x428c05]\n??:? void tmp_ybda61p.__unittest_L58_C1() [0x428332]\n??:? void tmp_ybda61p.__modtest() [0x428988]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cce3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb76]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e01]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430d8d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb4d]\n??:? runModuleUnitTests [0x42cab9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290c8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpul9eqla0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpul9eqla0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        if (lst[i] == min) {\n            for (int j = 0; j < lst.length; j++) {\n                if (lst[j] == max) {\n                    result[i] = lst[j];\n                    break;\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9dh7l1u6.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428add]\n??:? void tmp9dh7l1u6.__unittest_L50_C1() [0x42820a]\n??:? void tmp9dh7l1u6.__modtest() [0x428860]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbbb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431188]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba25]\n??:? runModuleUnitTests [0x42c991]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2)\n        return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int left = 0;\n    int right = lst.length - 1;\n    \n    while (left < right) {\n        if (lst[left] <= lst[right]) {\n            result[left] = lst[left];\n            left++;\n        } else {\n            result[right] = lst[right];\n            right--;\n        }\n    }\n    \n    if (left == right) {\n        result[left] = lst[left];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpanhxbnh6.d(26): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpanhxbnh6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int index = 0;\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[index++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[index++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[index++] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeepj1ddd.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpeepj1ddd.__unittest_L52_C1() [0x4281e6]\n??:? void tmpeepj1ddd.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int i = 0;\n    for (int j = 0; j < lst.length; j++) {\n        if (lst[j] == min) {\n            result[i] = max;\n            i++;\n            max = min;\n            min = lst[j];\n        } else if (lst[j] == max) {\n            result[i] = min;\n            i++;\n            max = min;\n            min = lst[j];\n        } else {\n            result[i] = lst[j];\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp36w5zn69.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428ab5]\n??:? void tmp36w5zn69.__unittest_L47_C1() [0x4281e2]\n??:? void tmp36w5zn69.__modtest() [0x428838]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb93]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba26]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431160]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c3d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9fd]\n??:? runModuleUnitTests [0x42c969]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f78]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == min) {\n                j++;\n            }\n            \n            int k = j - 1;\n            while (k >= 0 && result[k] == max) {\n                k--;\n            }\n            \n            if (k < 0) {\n                result[i] = max;\n                result[j] = min;\n            } else {\n                result[i] = max;\n                result[k] = min;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt68ua6w4.d(63): unittest failure\n----------------\n??:? _d_unittestp [0x428b1d]\n??:? void tmpt68ua6w4.__unittest_L59_C1() [0x428246]\n??:? void tmpt68ua6w4.__modtest() [0x42889c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ca5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba65]\n??:? runModuleUnitTests [0x42c9d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fe0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpul9eqla0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpul9eqla0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpley79sb_.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpley79sb_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            \n            i++;\n            j--;\n        } else {\n            i++;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpadibg8yl.d(26): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpadibg8yl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n        {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        }\n        else if (lst[i] == max)\n        {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        }\n        else\n        {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpna1_ptkj.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpna1_ptkj.__unittest_L57_C1() [0x4281fe]\n??:? void tmpna1_ptkj.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    while (i < lst.length) {\n        if (lst[i] == min) {\n            result[i] = max;\n            i++;\n        } else {\n            result[i] = min;\n            i++;\n        }\n    }\n    while (j < lst.length) {\n        result[j] = lst[j];\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp44p6hkcf.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428a3d]\n??:? void tmp44p6hkcf.__unittest_L45_C1() [0x42816a]\n??:? void tmp44p6hkcf.__modtest() [0x4287c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b985]\n??:? runModuleUnitTests [0x42c8f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int i = 0;\n    for (int j = 0; j < lst.length; j++) {\n        if (lst[j] == min) {\n            result[i++] = max;\n            max = min;\n            min = lst[j];\n        } else if (lst[j] == max) {\n            result[i++] = min;\n            min = max;\n            max = lst[j];\n        } else {\n            result[i++] = lst[j];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpm032ar42.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpm032ar42.__unittest_L44_C1() [0x4281e6]\n??:? void tmpm032ar42.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpsc7eaqkf.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc7eaqkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = strange_sort_list(result);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp4y07hk6c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y07hk6c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = Arrays.copyOf(result, k);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp3zcrg55x.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp3zcrg55x.d(35): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3zcrg55x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    \n    while (i < lst.length) {\n        if (lst[i] == min) {\n            result[j++] = lst[i++];\n            while (i < lst.length && lst[i] == min)\n                i++;\n        }\n        else if (lst[i] == max) {\n            result[j++] = lst[i++];\n            while (i < lst.length && lst[i] == max)\n                i++;\n        }\n        else {\n            result[j++] = lst[i++];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp59mwd4vd.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428b25]\n??:? void tmp59mwd4vd.__unittest_L55_C1() [0x428252]\n??:? void tmp59mwd4vd.__modtest() [0x4288a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc03]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430cad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba6d]\n??:? runModuleUnitTests [0x42c9d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fe8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    \n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    \n    if (i == j) {\n        result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmps4v0hd93.d(24): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps4v0hd93.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long min, max, tmp;\n    int i, j, k;\n    \n    if (lst.length < 2)\n        return lst;\n    \n    min = lst[0];\n    max = lst[0];\n    \n    for (i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            tmp = lst[i];\n            lst[i] = lst[0];\n            lst[0] = tmp;\n        }\n        if (lst[i] == max) {\n            tmp = lst[i];\n            lst[i] = lst[lst.length - 1];\n            lst[lst.length - 1] = tmp;\n        }\n    }\n    \n    for (i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            tmp = lst[i];\n            lst[i] = lst[0];\n            lst[0] = tmp;\n        }\n        if (lst[i] == max) {\n            tmp = lst[i];\n            lst[i] = lst[lst.length - 1];\n            lst[lst.length - 1] = tmp;\n        }\n    }\n    \n    for (i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            tmp = lst[i];\n            lst[i] = lst[0];\n            lst[0] = tmp;\n        }\n        if (lst[i] == max) {\n            tmp = lst[i];\n            lst[i] = lst[lst.length - 1];\n            lst[lst.length - 1] = tmp;\n        }\n    }\n    \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp2dyag_21.d(75): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2dyag_21.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        } else if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n        } else if (lst[i] == max) {\n            result[i] = min;\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo0fvvzig.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpo0fvvzig.__unittest_L46_C1() [0x42818a]\n??:? void tmpo0fvvzig.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = strange_sort_list(result);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp4y07hk6c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y07hk6c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    result[k++] = lst[i++];\n    result[k++] = lst[j--];\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp8c3nkr55.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8c3nkr55.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpsc7eaqkf.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc7eaqkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpmqcp10ry.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqcp10ry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpmqcp10ry.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqcp10ry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            long temp = lst[i];\n            lst[i] = lst[j];\n            lst[j] = temp;\n        }\n        i++;\n        j--;\n    }\n    for (int k = 0; k < lst.length; k++) {\n        result[k] = lst[k];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpoipdwcz2.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoipdwcz2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while(i < j) {\n        if(lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if(i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphusq6737.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphusq6737.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        } else if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n        } else if (lst[i] == max) {\n            result[i] = min;\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbmcgdr6h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpbmcgdr6h.__unittest_L46_C1() [0x42818a]\n??:? void tmpbmcgdr6h.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmps9yg2n5o.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps9yg2n5o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpsc7eaqkf.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc7eaqkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpley79sb_.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpley79sb_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else if (lst[i] > lst[j]) {\n            result[k++] = lst[j--];\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp1ya5kmsp.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1ya5kmsp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpb_1mwq60.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_1mwq60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    } else if (i < j) {\n        result[k] = lst[i];\n        i++;\n        k++;\n        while (i < j) {\n            result[k] = lst[j];\n            j--;\n            k++;\n        }\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp42w9mtfi.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp42w9mtfi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        } else if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n        } else if (lst[i] == max) {\n            result[i] = min;\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbmcgdr6h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpbmcgdr6h.__unittest_L46_C1() [0x42818a]\n??:? void tmpbmcgdr6h.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int j = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[j++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[j++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[j++] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf58ed8dh.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpf58ed8dh.__unittest_L47_C1() [0x4281e6]\n??:? void tmpf58ed8dh.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpul9eqla0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpul9eqla0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmptoam_dxi.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptoam_dxi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpdvynp7q0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdvynp7q0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int j = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[j++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[j++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[j++] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyx20am2u.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpyx20am2u.__unittest_L49_C1() [0x4281e6]\n??:? void tmpyx20am2u.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8ffy5uyb.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmp8ffy5uyb.__unittest_L51_C1() [0x4281fe]\n??:? void tmp8ffy5uyb.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpsc7eaqkf.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc7eaqkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp9rkf52x_.d(25): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9rkf52x_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n        } else {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpgvjqsygm.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgvjqsygm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int j = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[j++] = lst[i];\n            continue;\n        }\n        if (lst[i] == max) {\n            result[j++] = lst[i];\n            continue;\n        }\n        for (int k = 0; k < lst.length; k++) {\n            if (lst[k] == lst[i]) {\n                result[j++] = lst[k];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpg268gv_9.d(57): unittest failure\n----------------\n??:? _d_unittestp [0x428b0d]\n??:? void tmpg268gv_9.__unittest_L53_C1() [0x428236]\n??:? void tmpg268gv_9.__modtest() [0x42888c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbeb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d09]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c95]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba55]\n??:? runModuleUnitTests [0x42c9c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8ffy5uyb.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmp8ffy5uyb.__unittest_L51_C1() [0x4281fe]\n??:? void tmp8ffy5uyb.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        if (lst[i] == min) {\n            for (int j = 0; j < lst.length; j++) {\n                if (lst[j] == max) {\n                    result[i] = max;\n                    max = lst[j];\n                    break;\n                }\n            }\n        }\n        else if (lst[i] == max) {\n            for (int j = 0; j < lst.length; j++) {\n                if (lst[j] == min) {\n                    result[i] = min;\n                    min = lst[j];\n                    break;\n                }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3n0es2xa.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428b45]\n??:? void tmp3n0es2xa.__unittest_L55_C1() [0x42826e]\n??:? void tmp3n0es2xa.__modtest() [0x4288c4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc23]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bab6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ccd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba8d]\n??:? runModuleUnitTests [0x42c9f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429008]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmptoam_dxi.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptoam_dxi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        } else if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv2ziajs4.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpv2ziajs4.__unittest_L49_C1() [0x4281fe]\n??:? void tmpv2ziajs4.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min)\n            result[i] = max;\n        else if (lst[i] == max)\n            result[i] = min;\n        else\n            result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbq846igr.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpbq846igr.__unittest_L46_C1() [0x42818a]\n??:? void tmpbq846igr.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int start = 0;\n    int end = lst.length - 1;\n    \n    while (start < end) {\n        if (lst[start] <= lst[end]) {\n            result[start] = lst[start];\n            start++;\n        } else {\n            result[end] = lst[end];\n            end--;\n        }\n    }\n    \n    if (start == end) {\n        result[start] = lst[start];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvhmo1v3m.d(26): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvhmo1v3m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgdupmt00.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpgdupmt00.__unittest_L50_C1() [0x4281fe]\n??:? void tmpgdupmt00.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    \n    if (i == j) {\n        result[i] = lst[i];\n        i++;\n    }\n    \n    for (; i < result.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpbz_dz6fl.d(25): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbz_dz6fl.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    int j = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[j++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[j++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[j++] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpblbox4av.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpblbox4av.__unittest_L52_C1() [0x4281e6]\n??:? void tmpblbox4av.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int start = 0;\n    int end = lst.length - 1;\n    \n    while (start < end) {\n        if (lst[start] < lst[end]) {\n            result[start] = lst[start];\n            result[end] = lst[end];\n            start++;\n            end--;\n        } else {\n            result[start] = lst[end];\n            result[end] = lst[start];\n            start++;\n            end--;\n        }\n    }\n    \n    if (start == end) {\n        result[start] = lst[start];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpx5tklj94.d(25): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx5tklj94.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpmqcp10ry.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqcp10ry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdkhbodif.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpdkhbodif.__unittest_L51_C1() [0x4281fe]\n??:? void tmpdkhbodif.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    if (i < j) {\n        result[j] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp0ejv1ybb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0ejv1ybb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpns1mt88c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpns1mt88c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpm_tjdy9n.d(24): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm_tjdy9n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpt0_81wv2.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpt0_81wv2.__unittest_L49_C1() [0x4281fe]\n??:? void tmpt0_81wv2.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpb_1mwq60.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_1mwq60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpul9eqla0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpul9eqla0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == min) {\n                j++;\n            }\n            \n            for (int k = i; k < j; k++) {\n                long temp = result[k];\n                result[k] = result[k + 1];\n                result[k + 1] = temp;\n            }\n            \n            i = j - 1;\n        }\n        \n        if (result[i] == max) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == max) {\n                j++;\n            }\n            \n            for (int k = i; k < j; k++) {\n                long temp = result[k];\n                result[k] = result[k + 1];\n                result[k + 1] = temp;\n            }\n            \n            i = j - 1;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292657,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpbsbg7rjz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbsbg7rjz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpmqcp10ry.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqcp10ry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpe_lg5prf.d(24): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe_lg5prf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpsc7eaqkf.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc7eaqkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    int n = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[n] = lst[i];\n            i++;\n        } else {\n            result[n] = lst[j];\n            j--;\n        }\n        n++;\n    }\n    if (i == j) {\n        result[n] = lst[i];\n        n++;\n    }\n    if (i > j) {\n        result[n] = lst[j];\n        n++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp2efutqip.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2efutqip.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpns1mt88c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpns1mt88c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        else if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            result[i] = max;\n        else if (lst[i] == max)\n            result[i] = min;\n        else\n            result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmdiajfc3.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpmdiajfc3.__unittest_L48_C1() [0x42818a]\n??:? void tmpmdiajfc3.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    int temp;\n    \n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            temp = lst[i];\n            lst[i] = lst[j];\n            lst[j] = temp;\n            i++;\n            j--;\n        } else {\n            j--;\n        }\n    }\n    \n    for (k = 0; k < lst.length; k++) {\n        result[k] = lst[k];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpy91gflrm.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmpy91gflrm.d(28): Error: cannot implicitly convert expression `lst[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy91gflrm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min)\n            result[i] = max;\n        else if (lst[i] == max)\n            result[i] = min;\n        else\n            result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbq846igr.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpbq846igr.__unittest_L46_C1() [0x42818a]\n??:? void tmpbq846igr.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if(lst.length == 0)\n        return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while(i < j)\n    {\n        if(lst[i] < lst[j])\n        {\n            result[i] = lst[i];\n            i++;\n        }\n        else\n        {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    \n    if(i == j)\n        result[i] = lst[i];\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpu70xj3j9.d(26): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu70xj3j9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            for (int j = i; j < lst.length; j++) {\n                if (result[j] == max) {\n                    result[i] = result[j];\n                    result[j] = min;\n                    break;\n                }\n            }\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz6umc5f0.d(58): unittest failure\n----------------\n??:? _d_unittestp [0x428b1d]\n??:? void tmpz6umc5f0.__unittest_L54_C1() [0x428246]\n??:? void tmpz6umc5f0.__modtest() [0x42889c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ca5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba65]\n??:? runModuleUnitTests [0x42c9d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fe0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = strange_sort_list(result);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp4y07hk6c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y07hk6c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp89kkghhh.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89kkghhh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    while (i < lst.length) {\n        if (lst[i] == min) {\n            result[i] = max;\n            i++;\n        } else {\n            result[i] = lst[i];\n            i++;\n        }\n    }\n    \n    while (j < lst.length) {\n        result[j] = lst[j];\n        j++;\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnuaom71c.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428a6d]\n??:? void tmpnuaom71c.__unittest_L52_C1() [0x428196]\n??:? void tmpnuaom71c.__modtest() [0x4287ec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb4b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c69]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431118]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bf5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9b5]\n??:? runModuleUnitTests [0x42c921]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    while (i < lst.length) {\n        while (j < lst.length && lst[j] <= max) {\n            result[i++] = lst[j++];\n        }\n        while (j < lst.length && lst[j] > min) {\n            result[i++] = lst[j++];\n        }\n        result[i++] = min;\n        min = max;\n        max = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpog7crcox.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b76]\n??:? long[] tmpog7crcox.strange_sort_list(long[]) [0x4280d2]\n??:? void tmpog7crcox.__unittest_L43_C1() [0x42817f]\n??:? void tmpog7crcox.__modtest() [0x428848]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cba3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431170]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c4d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba0d]\n??:? runModuleUnitTests [0x42c979]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int j = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[j++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[j++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[j++] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpiddr3nm3.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpiddr3nm3.__unittest_L44_C1() [0x4281e6]\n??:? void tmpiddr3nm3.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    \n    if (i == j) {\n        result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp90dvulla.d(25): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp90dvulla.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    int min = 0;\n    int max = 0;\n    \n    while (i < j) {\n        min = i;\n        max = j;\n        while (i < j) {\n            if (lst[i] < lst[j]) {\n                min = i;\n            } else if (lst[i] > lst[j]) {\n                max = j;\n            }\n            i++;\n            j--;\n        }\n        if (min != max) {\n            result[k] = lst[min];\n            k++;\n            result[k] = lst[max];\n            k++;\n        }\n        i = min + 1;\n        j = max - 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpy2nbo37r.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy2nbo37r.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            result[i] = max;\n        else if (lst[i] == max)\n            result[i] = min;\n        else\n            result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuz389hiv.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpuz389hiv.__unittest_L48_C1() [0x42818a]\n??:? void tmpuz389hiv.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjuhsbida.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpjuhsbida.__unittest_L50_C1() [0x4281fe]\n??:? void tmpjuhsbida.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpxd2bni_q.d(25): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxd2bni_q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    int i = 0;\n    int j = lst.length - 1;\n    \n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[i];\n            result[i] = lst[j];\n            j--;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp7uqazfbb.d(25): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7uqazfbb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpese7y3r4.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpese7y3r4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else if (lst[i] > lst[j]) {\n            result[k] = lst[j];\n            j--;\n        } else {\n            result[k] = lst[i];\n            i++;\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpbk5pamwq.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbk5pamwq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        }\n        else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpspk1quzp.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpspk1quzp.__unittest_L50_C1() [0x4281fe]\n??:? void tmpspk1quzp.__modtest() [0x428854]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpb_1mwq60.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_1mwq60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int index = 0;\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[index++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[index++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[index++] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeepj1ddd.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpeepj1ddd.__unittest_L52_C1() [0x4281e6]\n??:? void tmpeepj1ddd.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = Arrays.copyOf(result, k);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp3zcrg55x.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp3zcrg55x.d(35): Error: undefined identifier `Arrays`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3zcrg55x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == min) {\n                j++;\n            }\n            \n            for (int k = i; k < j; k++) {\n                result[k] = result[k + 1];\n            }\n            \n            result[j] = min;\n            i = j - 1;\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == max) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == max) {\n                j++;\n            }\n            \n            for (int k = i; k < j; k++) {\n                result[k] = result[k + 1];\n            }\n            \n            result[j] = max;\n            i = j - 1;\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == min) {\n                j++;\n            }\n            \n            for (int k = i; k < j; k++) {\n                result[k] = result[k + 1];\n            }\n            \n            \nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp_q789cja.d(80): Error: found `unittest` instead of statement\n/tmp/tmp_q789cja.d(94): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp_q789cja.d(94): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_q789cja.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpb_1mwq60.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_1mwq60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        }\n        if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (result[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        } else if (result[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (result[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp401s7pwr.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428c15]\n??:? void tmp401s7pwr.__unittest_L55_C1() [0x42833e]\n??:? void tmp401s7pwr.__modtest() [0x428994]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430d9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb5d]\n??:? runModuleUnitTests [0x42cac9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290d8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    result[k++] = lst[i];\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpjzxh5wjj.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjzxh5wjj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpykjxbtz7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpykjxbtz7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpbsbg7rjz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbsbg7rjz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2)\n        return lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    result[k++] = lst[i++];\n    result[k++] = lst[j--];\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpkwx3amxp.d(24): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkwx3amxp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpese7y3r4.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpese7y3r4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int index = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[index++] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[index++] = min;\n            min = max;\n            max = lst[i];\n        } else {\n            result[index++] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc0rneh17.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpc0rneh17.__unittest_L44_C1() [0x4281e6]\n??:? void tmpc0rneh17.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpul9eqla0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpul9eqla0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            i++;\n        } else {\n            result[j] = lst[j];\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpb_1mwq60.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb_1mwq60.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        for (int j = 0; j < lst.length - i - 1; j++)\n        {\n            if (result[j] > result[j+1])\n            {\n                long temp = result[j];\n                result[j] = result[j+1];\n                result[j+1] = temp;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6zs9djba.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x4289a5]\n??:? void tmp6zs9djba.__unittest_L44_C1() [0x4280ce]\n??:? void tmp6zs9djba.__modtest() [0x428724]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b916]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ba1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431050]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b2d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8ed]\n??:? runModuleUnitTests [0x42c859]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e68]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        } else if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n        } else if (lst[i] == max) {\n            result[i] = min;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxf98o8zy.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a65]\n??:? void tmpxf98o8zy.__unittest_L48_C1() [0x428192]\n??:? void tmpxf98o8zy.__modtest() [0x4287e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb43]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c61]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431110]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9ad]\n??:? runModuleUnitTests [0x42c919]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    } else {\n        result[k] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmphob7e9d_.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphob7e9d_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    int max = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            max = Math.max(max, k);\n            result[k++] = lst[i++];\n        } else {\n            max = Math.max(max, k);\n            result[k++] = lst[j--];\n        }\n    }\n    max = Math.max(max, k);\n    for (int m = 0; m < max; m++) {\n        result[k++] = lst[i++];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp2ohpg0nw.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\n/tmp/tmp2ohpg0nw.d(27): Error: undefined identifier `Math`\n/tmp/tmp2ohpg0nw.d(30): Error: undefined identifier `Math`\n/tmp/tmp2ohpg0nw.d(34): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2ohpg0nw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    result[k++] = lst[i];\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpi2quahln.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi2quahln.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        \n        if (lst[i] == min) {\n            result[i] = max;\n            max = min;\n            min = lst[i];\n        } else if (lst[i] == max) {\n            result[i] = min;\n            min = max;\n            max = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpcr5d21a_.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428ad5]\n??:? void tmpcr5d21a_.__unittest_L48_C1() [0x428202]\n??:? void tmpcr5d21a_.__modtest() [0x428858]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cd1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431180]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba1d]\n??:? runModuleUnitTests [0x42c989]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f98]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmphektfkra.d(24): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphektfkra.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (result[i] == min) {\n            int j = i;\n            while (j < lst.length - 1 && result[j] == min) {\n                j++;\n            }\n            \n            int k = j - 1;\n            while (k >= 0 && result[k] == max) {\n                k--;\n            }\n            \n            int l = k + 1;\n            while (l < j) {\n                long temp = result[l];\n                result[l] = result[k];\n                result[k] = temp;\n                l++;\n                k--;\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmgp5ioxl.d(65): unittest failure\n----------------\n??:? _d_unittestp [0x428b15]\n??:? void tmpmgp5ioxl.__unittest_L61_C1() [0x42823e]\n??:? void tmpmgp5ioxl.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fd8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpdvynp7q0.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdvynp7q0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpmqcp10ry.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqcp10ry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp89kkghhh.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89kkghhh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpns1mt88c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpns1mt88c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp89kkghhh.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89kkghhh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int index = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n        {\n            result[index++] = lst[i];\n            for (int j = i + 1; j < lst.length; j++)\n            {\n                if (lst[j] == max)\n                {\n                    result[index++] = lst[j];\n                    break;\n                }\n                else\n                    result[index++] = lst[j];\n            }\n            break;\n        }\n        else if (lst[i] == max)\n        {\n            result[index++] = lst[i];\n            for (int j = i + 1; j < lst.length; j++)\n            {\n                if (lst[j] == min)\n                {\n                    result[index++] = lst[j];\n                    break;\n                }\n                else\n                    result[index++] = lst[j];\n            }\n            break;\n        }\n        else\n            result[index++] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxhtnwku7.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428c95]\n??:? void tmpxhtnwku7.__unittest_L72_C1() [0x4283be]\n??:? void tmpxhtnwku7.__modtest() [0x428a14]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cd73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e91]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431340]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e1d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bbdd]\n??:? runModuleUnitTests [0x42cb49]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429158]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp89kkghhh.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp89kkghhh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = strange_sort_list(result);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp4y07hk6c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y07hk6c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int j = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[j++] = max;\n            max = lst[i];\n        }\n        else if (lst[i] == max) {\n            result[j++] = min;\n            min = lst[i];\n        }\n        else {\n            result[j++] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6tjc5dq0.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428aad]\n??:? void tmp6tjc5dq0.__unittest_L49_C1() [0x4281d6]\n??:? void tmp6tjc5dq0.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ca9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431158]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9f5]\n??:? runModuleUnitTests [0x42c961]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpsc7eaqkf.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc7eaqkf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long min = lst[0];\n    long max = lst[0];\n    for(int i = 1; i < lst.length; i++)\n    {\n        if(lst[i] < min)\n            min = lst[i];\n        if(lst[i] > max)\n            max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n    {\n        result[i] = lst[i];\n        if(lst[i] == min)\n            min = max;\n        else if(lst[i] == max)\n            max = min;\n        else\n            max = min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdc9g0ol3.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4289fd]\n??:? void tmpdc9g0ol3.__unittest_L42_C1() [0x428126]\n??:? void tmpdc9g0ol3.__modtest() [0x42877c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cadb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b96e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430bf9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310a8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b85]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b945]\n??:? runModuleUnitTests [0x42c8b1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428ec0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmp_6ds5g8k.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_6ds5g8k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = 0;\n    for (int k = 0; k < lst.length; k++) {\n        if (lst[k] == min) {\n            result[i++] = lst[k];\n            if (i == lst.length)\n                break;\n            for (int l = k + 1; l < lst.length; l++) {\n                if (lst[l] == max) {\n                    result[i++] = lst[l];\n                    if (i == lst.length)\n                        break;\n                }\n            }\n        }\n        else if (lst[k] == max) {\n            result[j++] = lst[k];\n            if (j == lst.length)\n                break;\n            for (int l = k + 1; l < lst.length; l++) {\n                if (lst[l] == min) {\n                    result[j++] = lst[l];\n                    if (j == lst.length)\n                        break;\n                }\n            }\n        }\n        else {\n            result[k] = lst[k];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz6p4an4_.d(68): unittest failure\n----------------\n??:? _d_unittestp [0x428c25]\n??:? void tmpz6p4an4_.__unittest_L64_C1() [0x428352]\n??:? void tmpz6p4an4_.__modtest() [0x4289a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cd03]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430dad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb6d]\n??:? runModuleUnitTests [0x42cad9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    int j = 0;\n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n        {\n            result[j++] = lst[i];\n            for (int k = i + 1; k < lst.length; k++)\n            {\n                if (lst[k] == max)\n                {\n                    result[j++] = lst[k];\n                    break;\n                }\n                else\n                    result[j++] = lst[k];\n            }\n        }\n        else\n            result[j++] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp58jvp1r1.d(52): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp58jvp1r1.strange_sort_list(long[]) [0x428129]\n??:? void tmp58jvp1r1.__unittest_L56_C1() [0x4281cb]\n??:? void tmp58jvp1r1.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (k != lst.length) {\n        result = strange_sort_list(result);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmp4y07hk6c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4y07hk6c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++) {\n        result[i] = lst[i];\n        \n        if (lst[i] == min) {\n            for (int j = i + 1; j < lst.length; j++) {\n                if (lst[j] == max) {\n                    result[i] = max;\n                    result[j] = min;\n                    break;\n                }\n            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpw30i3a5m.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a6d]\n??:? void tmpw30i3a5m.__unittest_L48_C1() [0x42819a]\n??:? void tmpw30i3a5m.__modtest() [0x4287f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb4b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9de]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c69]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431118]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bf5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9b5]\n??:? runModuleUnitTests [0x42c921]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i];\n    }\n    if (i < j) {\n        result[k++] = lst[j];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmphbp43rfz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphbp43rfz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpbsbg7rjz.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbsbg7rjz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j) {\n        if (lst[i] <= lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpns1mt88c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpns1mt88c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    long[] result = new long[lst.length];\n    \n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min = lst[i];\n        } else if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    \n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[i] = max;\n        } else if (lst[i] == max) {\n            result[i] = min;\n        } else {\n            result[i] = lst[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbmcgdr6h.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpbmcgdr6h.__unittest_L46_C1() [0x42818a]\n??:? void tmpbmcgdr6h.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0) return lst;\n    long min = lst[0];\n    long max = lst[0];\n    for (int i = 1; i < lst.length; i++) {\n        if (lst[i] < min) min = lst[i];\n        if (lst[i] > max) max = lst[i];\n    }\n    long[] result = new long[lst.length];\n    int index = 0;\n    for (int i = 0; i < lst.length; i++) {\n        if (lst[i] == min) {\n            result[index++] = lst[i];\n            for (int j = i + 1; j < lst.length; j++) {\n                if (lst[j] == max) {\n                    result[index++] = lst[j];\n                    break;\n                }\n            }\n        }\n        else if (lst[i] == max) {\n            result[index++] = lst[i];\n            for (int j = i + 1; j < lst.length; j++) {\n                if (lst[j] == min) {\n                    result[index++] = lst[j];\n                    break;\n                }\n            }\n        }\n        else {\n            result[index++] = lst[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292644,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpnkeqif2o.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c96]\n??:? long[] tmpnkeqif2o.strange_sort_list(long[]) [0x428105]\n??:? void tmpnkeqif2o.__unittest_L54_C1() [0x42829f]\n??:? void tmpnkeqif2o.__modtest() [0x428968]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccc3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430de1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431290]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430d6d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb2d]\n??:? runModuleUnitTests [0x42ca99]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int fun",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length < 2) return lst;\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpedtte7aq.d(23): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpedtte7aq.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    int max = 0;\n    int min = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    while (i < lst.length) {\n        result[k++] = lst[i++];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "/tmp/tmpcwnenn2c.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcwnenn2c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length == 0)\n        return lst;\n    \n    long min = lst[0];\n    long max = lst[0];\n    \n    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        else if (lst[i] > max)\n            max = lst[i];\n    }\n    \n    long[] result = new long[lst.length];\n    \n    for (int i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n            result[i] = max;\n        else if (lst[i] == max)\n            result[i] = min;\n        else\n            result[i] = lst[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292643,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmdiajfc3.d(52): unittest failure\n----------------\n??:? _d_unittestp [0x428a5d]\n??:? void tmpmdiajfc3.__unittest_L48_C1() [0x42818a]\n??:? void tmpmdiajfc3.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431108]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a5]\n??:? runModuleUnitTests [0x42c911]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    if (i == j) {\n        result[i] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpvmpveiwb.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvmpveiwb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[i] = lst[i];\n            result[j] = lst[j];\n            i++;\n            j--;\n        } else if (lst[i] < lst[j]) {\n            result[i] = lst[j];\n            result[j] = lst[i];\n            i++;\n            j--;\n        } else {\n            i++;\n            j--;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpk31qmqx7.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk31qmqx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] > lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpi1pkwlwr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi1pkwlwr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] < lst[j]) {\n            result[k] = lst[i];\n            i++;\n        } else {\n            result[k] = lst[j];\n            j--;\n        }\n        k++;\n    }\n    if (i == j) {\n        result[k] = lst[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmppfwkaszr.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppfwkaszr.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given array of integers, return array in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    >>> strange_sort_list([1L, 2L, 3L, 4L])\n    [1L, 4L, 2L, 3L]\n    >>> strange_sort_list([5L, 5L, 5L, 5L])\n    [5L, 5L, 5L, 5L]\n    >>> strange_sort_list([])\n    []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] result = new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i < j) {\n        if (lst[i] <= lst[j]) {\n            result[k++] = lst[i++];\n        } else {\n            result[k++] = lst[j--];\n        }\n    }\n    if (i == j) {\n        result[k++] = lst[i++];\n    }\n    if (i < j) {\n        result[k++] = lst[j--];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}",
      "timestamp": 1664292642,
      "stdout": "",
      "stderr": "/tmp/tmpmqcp10ry.d(22): Error: cannot implicitly convert expression `lst.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmqcp10ry.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}