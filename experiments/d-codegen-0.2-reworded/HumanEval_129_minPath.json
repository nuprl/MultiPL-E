{
  "name": "HumanEval_129_minPath",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered arrays of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered array of the values on the cells that the minimum path go through.\n\n    Examples:    \n    >>> minPath([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]], 3L)\n    [1L, 2L, 1L]\n\n    >>> minPath([[5L, 9L, 3L], [4L, 1L, 6L], [7L, 8L, 2L]], 1L)\n    [1L]\n    \n*/\nlong[] minPath(long[][] grid, long k) \n",
  "tests": "unittest\n{\n    alias candidate = minPath;\n\n    assert(candidate([[1L, 2L, 3L], [4L, 5L, 6L], [7L, 8L, 9L]], 3L) == [1L, 2L, 1L]);\n    assert(candidate([[5L, 9L, 3L], [4L, 1L, 6L], [7L, 8L, 2L]], 1L) == [1L]);\n    assert(candidate([[1L, 2L, 3L, 4L], [5L, 6L, 7L, 8L], [9L, 10L, 11L, 12L], [13L, 14L, 15L, 16L]], 4L) == [1L, 2L, 1L, 2L]);\n    assert(candidate([[6L, 4L, 13L, 10L], [5L, 7L, 12L, 1L], [3L, 16L, 11L, 15L], [8L, 14L, 9L, 2L]], 7L) == [1L, 10L, 1L, 10L, 1L, 10L, 1L]);\n    assert(candidate([[8L, 14L, 9L, 2L], [6L, 4L, 13L, 15L], [5L, 7L, 1L, 12L], [3L, 10L, 11L, 16L]], 5L) == [1L, 7L, 1L, 7L, 1L]);\n    assert(candidate([[11L, 8L, 7L, 2L], [5L, 16L, 14L, 4L], [9L, 3L, 15L, 6L], [12L, 13L, 10L, 1L]], 9L) == [1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L]);\n    assert(candidate([[12L, 13L, 10L, 1L], [9L, 3L, 15L, 6L], [5L, 16L, 14L, 4L], [11L, 8L, 7L, 2L]], 12L) == [1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L, 1L, 6L]);\n    assert(candidate([[2L, 7L, 4L], [3L, 1L, 5L], [6L, 8L, 9L]], 8L) == [1L, 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n    assert(candidate([[6L, 1L, 5L], [3L, 8L, 9L], [2L, 7L, 4L]], 8L) == [1L, 5L, 1L, 5L, 1L, 5L, 1L, 5L]);\n    assert(candidate([[1L, 2L], [3L, 4L]], 10L) == [1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L]);\n    assert(candidate([[1L, 3L], [3L, 2L]], 10L) == [1L, 3L, 1L, 3L, 1L, 3L, 1L, 3L, 1L, 3L]);\n}\nvoid main(){}",
  "completions": [
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int kk = 1; kk <= k; kk++)\n                if(dp[i][j] == kk)\n                    ans[kk] = grid[i][j];\n    \n    return ans;\n}",
    "{\n    long[] result = new long[k];\n    long[] lst = new long[k];\n    int[] dirs = {0, 1, 0, -1, 0};\n    int[] dirs_rev = {0, -1, 0, 1, 0};\n    int[] dirs_rev_rev = {0, 0, 1, -1, 0};\n    int[] dirs_rev_rev_rev = {0, 0, -1, 1, 0};\n    int[] dirs_rev_rev_rev_rev = {0, 0, 0, -1, 1};\n    int[] dirs_rev_rev_rev_rev_rev = {0, 0, 0, 1, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            lst[i] = Math.min(lst[i], grid[j][0] + grid[j][1]);\n        }\n        for (int j = 1; j < M; j++) {\n            lst[i] = Math.min(lst[i], grid[0][j] + grid[1][j]);\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[][] dp = new long[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                dp[i][j] = dp[i - 1][j];\n            }\n            if (j > 0 && dp[i][j - 1] < dp[i][j]) {\n                dp[i][j] = dp[i][j - 1];\n            }\n            if (i > 0 && j > 0 && dp[i - 1][j - 1] < dp[i][j]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            }\n        }\n    }\n    \n    long[] ans = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i > 0 && j > 0 && dp[i - 1][j - 1] == dp[i][j]) {\n                ans[0] = dp[i - 1][j - 1];\n                for (int k = 1; k <= k; k++) {\n                    ans[k] = dp[i - 1][j - 1];\n                }\n                return ans;\n            }\n        }\n    }\n    return ans;\n}",
    "{\n    long[] result = new long[k];\n    long[] lst = new long[k];\n    int[] dirs = new int[]{0, 1, 0, -1, 0};\n    int[] dir = new int[4];\n    int[] visited = new int[grid.length * grid[0].length];\n    int[] path = new int[grid.length * grid[0].length];\n    int[] path_len = new int[grid.length * grid[0].length];\n    int[] path_pos = new int[grid.length * grid[0].length];\n    int[] path_dir = new int[grid.length * grid[0].length];\n    int[] path_dir_len = new int[grid.length * grid[0].length];\n    int[] path_dir_pos = new int[grid.length * grid[0].length];\n    int[] path_dir_dir = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_len = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_pos = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_len = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_pos = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_dir = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_dir_len = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_dir_pos = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_dir_dir = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir_dir_dir_len = new int[grid.length * grid[0].length];\n    int[] path_dir_dir_dir",
    "{\n    int N = grid.length;\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i-1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i <= k; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            for (int k = 0; k < 4; k++)\n            {\n                int n = i + d[k][0];\n                int m = j + d[k][1];\n                if (n >= 0 && n < N && m >= 0 && m < M && grid[n][m] < lst[0])\n                    lst[0] = grid[n][m];\n            }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i + di][j + dj], dp[i][j]));\n    long[] ans = new long[k];\n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i + di][j + dj], dp[i][j]));\n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    return ans;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    \n    long[] lst = new long[k + 1];\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    \n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k]) {\n                    for (int l = 1; l < k; l++) {\n                        if (grid[i][j] < lst[l]) {\n                            lst[l] = grid[i][j];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (i > 1 && grid[i - 1][j] < lst[k]) {\n                    lst[k] = grid[i - 1][j];\n                }\n                if (j > 1 && grid[i][j - 1] < lst[k]) {\n                    lst[k] = grid[i][j - 1];\n                }\n                if (i > 1 && j > 1 && grid[i - 1][j - 1] < lst[k]) {\n                    lst[k] = grid[i - 1][j - 1];\n                }\n            }\n        }\n    }\n    return lst;\n}\n",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    long[] lst = new long[k];\n    long[] lst_prev = new long[k];\n    long[] lst_next = new long[k];\n    long[] lst_prev_next = new long[k];\n    \n    for (int i = 0; i < k; i++) {\n        lst[i] = grid[0][0];\n        lst_prev[i] = lst[i];\n        lst_next[i] = lst[i];\n        lst_prev_next[i] = lst[i];\n    }\n    \n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            for (int k = 0; k < k; k++) {\n                if (lst_prev[k] < grid[i][j]) {\n                    lst_prev[k] = grid[i][j];\n                    lst_prev_next[k] = lst[k];\n                }\n                if (lst_next[k] < grid[i][j]) {\n                    lst_next[k] = grid[i][j];\n                    lst_prev_next[k] = lst[k];\n                }\n            }\n        }\n        \n        for (int k = 0; k < k; k++) {\n            result[k] = lst_prev_next[k];\n        }\n        \n        for (int k = 0; k < k; k++) {\n            lst[k] = lst_next[k];\n        }\n    }\n    \n    return result;\n}",
    "{\n    int N = grid.length;\n    long[][] dp = new long[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int ii = 0; ii < N; ii++) {\n                for (int jj = 0; jj < N; jj++) {\n                    if (i == ii && j == jj) continue;\n                    dp[i][j] = Math.min(dp[i][j], dp[ii][jj] + grid[i][j]);\n                }\n            }\n        }\n    }\n    long[] ans = new long[k];\n    for (int i = 0; i < k; i++) {\n        ans[i] = dp[0][0];\n        for (int j = 0; j < N; j++) {\n            if (dp[0][j] < ans[i]) {\n                ans[i] = dp[0][j];\n            }\n        }\n        for (int j = 0; j < N; j++) {\n            if (dp[j][0] < ans[i]) {\n                ans[i] = dp[j][0];\n            }\n        }\n        for (int ii = 0; ii < N; ii++) {\n            for (int jj = 0; jj < N; jj++) {\n                if (dp[ii][jj] < ans[i]) {\n                    ans[i] = dp[ii][jj];\n                }\n            }\n        }\n    }\n    return ans;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = lst[i - 1] + 1;\n        for (int j = 0; j < N; j++) {\n            for (int m = 0; m < M; m++) {\n                if (grid[j][m] == i) {\n                    lst[i] = Math.min(lst[i], lst[i - 1] + 1);\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] lst_prev = new long[k + 1];\n    long[] lst_curr = new long[k + 1];\n    long[] lst_next = new long[k + 1];\n    long[] lst_prev_next = new long[k + 1];\n    long[] lst_curr_next = new long[k + 1];\n    long[] lst_next_next = new long[k + 1];\n    long[] lst_prev_next_next = new long[k + 1];\n    long[] lst_curr_next_next = new long[k + 1];\n    long[] lst_next_next_next = new long[k + 1];\n    long[] lst_prev_next_next_next = new long[k + 1];\n    long[] lst_curr_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next = new long[k + 1];\n    long[] lst_prev_next_next_next_next = new long[k + 1];\n    long[] lst_curr_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_next = new long[k + 1];\n    long[] lst_prev_next_next_next_next_next = new long[k + 1];\n    long[] lst_curr_next_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_next_next = new long[k + 1];\n    long[] lst_prev_next_next_next_next_next_next = new long[k + 1];\n    long[] lst_curr_next_next_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_next_next_next = new long[k + 1];\n    long[] lst_prev",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        for (int j = 0; j < grid.length; j++) {\n            for (int k = 0; k < grid[0].length; k++) {\n                if (grid[j][k] < lst[i-1]) {\n                    lst[i] = grid[j][k];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            for (int di = -1; di <= 1; di++) {\n                for (int dj = -1; dj <= 1; dj++) {\n                    if (di == 0 && dj == 0) continue;\n                    int n_i = i + di;\n                    int n_j = j + dj;\n                    if (n_i < 0 || n_i >= N || n_j < 0 || n_j >= M) continue;\n                    dp[n_i][n_j] = Math.min(dp[n_i][n_j], dp[i][j] + 1);\n                }\n            }\n        }\n    }\n    \n    long[] ans = new long[k];\n    for (int i = 0; i < k; i++) {\n        ans[i] = dp[0][0];\n        for (int j = 0; j < M; j++) {\n            if (dp[0][j] < ans[i]) {\n                ans[i] = dp[0][j];\n            }\n        }\n        for (int j = 0; j < N; j++) {\n            if (dp[j][0] < ans[i]) {\n                ans[i] = dp[j][0];\n            }\n        }\n    }\n    \n    return ans;\n}",
    "{\n    long[] lst = new long[k + 1];\n    int[] dirs = new int[]{0, 1, 0, -1, 0};\n    int[] dirs_rev = new int[]{0, -1, 0, 1, 0};\n    int[] dirs_rev2 = new int[]{0, 0, 1, 0, -1};\n    int[] dirs_rev3 = new int[]{0, 0, -1, 1, 0};\n    int[] dirs_rev4 = new int[]{0, 0, 0, 0, -1};\n    int[] dirs_rev5 = new int[]{0, 0, 0, -1, 1};\n    int[] dirs_rev6 = new int[]{0, 0, 0, 1, 0};\n    int[] dirs_rev7 = new int[]{0, 0, -1, 0, 1};\n    int[] dirs_rev8 = new int[]{0, 0, 1, 0, 0};\n    int[] dirs_rev9 = new int[]{0, -1, 0, 0, 1};\n    int[] dirs_rev10 = new int[]{0, 1, 0, 0, 0};\n    int[] dirs_rev11 = new int[]{-1, 0, 0, 0, 0};\n    int[] dirs_rev12 = new int[]{0, 0, 0, -1, 0};\n    int[] dirs_rev13 = new int[]{0, 0, 1, 0, -1};\n    int[] dirs_rev14 = new int[]{0, 0, 0, 1, 0};\n    int[] dirs_rev15 = new int[]{0, 1, 0, 0, 0};\n    int[] dirs_rev16 = new int[]{-1, 0, 0, 0, 0};\n    int[] dirs_rev17 = new int[]{0, 0, 0, 0, -1};\n    int[] dirs_rev18 = new int[]{0, 0, -1, 0, 0};\n    int[] dirs_rev19 = new int[]{0, 0, 0, -1, 0};\n    int[] dirs",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i <= k; i++) {\n        lst[i] = grid[0][0];\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i == 0 && j == 0) {\n                continue;\n            }\n            if (i == 0) {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            } else if (j == 0) {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            } else {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k < i; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for (int k = 1; k < j; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for (int k = 1; k < i; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for (int k = 1; k < j; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++) {\n        lst[i] = grid[0][0];\n    }\n    \n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            if (i > 0 && j > 0) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    \n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k+1];\n    result[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        result[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < result[i-1]) {\n                result[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < result[i-1]) {\n                result[i] = grid[0][j];\n            }\n        }\n    }\n    return result;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}\n",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < grid.length; i++)\n        for (int j = 0; j < grid[i].length; j++)\n            if (grid[i][j] > 0)\n                for (int d = 0; d < 4; d++) {\n                    int x = i + d[0], y = j + d[1];\n                    if (x >= 0 && x < grid.length && y >= 0 && y < grid[x].length && grid[x][y] > 0) {\n                        long val = grid[i][j] + grid[x][y];\n                        if (val < lst[k])\n                            lst[k] = val;\n                    }\n                }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k+1];\n    int[] dirs = new int[]{0, 1, 0, -1, 0};\n    int[] dirs2 = new int[]{1, 0, -1, 0, 1};\n    int[] dirs3 = new int[]{0, 1, 0, -1, 1};\n    int[] dirs4 = new int[]{1, 0, -1, 1, 0};\n    int[] dirs5 = new int[]{0, 1, 1, 0, -1};\n    int[] dirs6 = new int[]{1, 0, 1, -1, 0};\n    int[] dirs7 = new int[]{0, 1, 1, 0, 1};\n    int[] dirs8 = new int[]{1, 0, 1, 1, 0};\n    int[] dirs9 = new int[]{0, 1, 1, 1, -1};\n    int[] dirs10 = new int[]{1, 0, 1, 1, 1};\n    int[] dirs11 = new int[]{0, 1, 1, 1, 1};\n    int[] dirs12 = new int[]{1, 1, 0, -1, 0};\n    int[] dirs13 = new int[]{1, 1, 0, -1, 1};\n    int[] dirs14 = new int[]{1, 1, 0, 1, 0};\n    int[] dirs15 = new int[]{1, 1, 0, 1, 1};\n    int[] dirs16 = new int[]{1, 1, 1, 0, -1};\n    int[] dirs17 = new int[]{1, 1, 1, 0, 1};\n    int[] dirs18 = new int[]{1, 1, 1, 1, 0};\n    int[] dirs19 = new int[]{1, 1, 1, 1, -1};\n    int[] dirs20 = new int[]{1, 1, 1, 1, 1};\n    int[] dirs21 = new int[]{0, 0, 0, 0, 0};\n    int[] dirs22 = new int[]{0, 0,",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k - 1]) {\n                    lst[k - 1] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = lst[i - 1] + grid[0][0];\n        for (int j = 1; j < n; j++) {\n            lst[i] = Math.min(lst[i], lst[i - 1] + grid[j][0]);\n            for (int p = 1; p < m; p++) {\n                lst[i] = Math.min(lst[i], lst[i - 1] + grid[j][p]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            for (int di = -1; di <= 1; di++) {\n                for (int dj = -1; dj <= 1; dj++) {\n                    if (di == 0 && dj == 0) continue;\n                    int ri = i + di;\n                    int rj = j + dj;\n                    if (ri < 0 || ri >= N || rj < 0 || rj >= M) continue;\n                    dp[ri][rj] = Math.min(dp[ri][rj], dp[i][j] + grid[ri][rj]);\n                }\n            }\n        }\n    }\n    long[] ans = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            ans[0] = Math.min(ans[0], dp[i][j]);\n        }\n    }\n    for (int i = 1; i <= k; i++) {\n        ans[i] = Math.min(ans[i - 1], ans[i]);\n    }\n    return ans;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for(int i = 1; i < grid.length; i++) {\n        for(int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for(int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k-1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k+1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + grid[i][j-1] + grid[i-1][j] + grid[i-1][j-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k] && grid[i][j] > lst[k - 1]) {\n                    lst[k - 1] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] lst_tmp = new long[k + 1];\n    long[] lst_tmp2 = new long[k + 1];\n    long[] lst_tmp3 = new long[k + 1];\n    long[] lst_tmp4 = new long[k + 1];\n    long[] lst_tmp5 = new long[k + 1];\n    long[] lst_tmp6 = new long[k + 1];\n    long[] lst_tmp7 = new long[k + 1];\n    long[] lst_tmp8 = new long[k + 1];\n    long[] lst_tmp9 = new long[k + 1];\n    long[] lst_tmp10 = new long[k + 1];\n    long[] lst_tmp11 = new long[k + 1];\n    long[] lst_tmp12 = new long[k + 1];\n    long[] lst_tmp13 = new long[k + 1];\n    long[] lst_tmp14 = new long[k + 1];\n    long[] lst_tmp15 = new long[k + 1];\n    long[] lst_tmp16 = new long[k + 1];\n    long[] lst_tmp17 = new long[k + 1];\n    long[] lst_tmp18 = new long[k + 1];\n    long[] lst_tmp19 = new long[k + 1];\n    long[] lst_tmp20 = new long[k + 1];\n    long[] lst_tmp21 = new long[k + 1];\n    long[] lst_tmp22 = new long[k + 1];\n    long[] lst_tmp23 = new long[k + 1];\n    long[] lst_tmp24 = new long[k + 1];\n    long[] lst_tmp25 = new long[k + 1];\n    long[] lst_tmp26 = new long[k + 1];\n    long[] lst_tmp27 = new long[k + 1];\n    long[] lst_tmp28 = new long[k + 1];\n    ",
    "{\n    long[] lst = new long[k + 1];\n    int[] dirs = {0, 1, 0, -1, 0};\n    int[] dir = {0, 0, 0, 0, 0};\n    int[] row = {0, 0, 0, 0, 0};\n    int[] col = {0, 0, 0, 0, 0};\n    int[] r = {0, 0, 0, 0, 0};\n    int[] c = {0, 0, 0, 0, 0};\n    int[] r_ = {0, 0, 0, 0, 0};\n    int[] c_ = {0, 0, 0, 0, 0};\n    int[] r_2 = {0, 0, 0, 0, 0};\n    int[] c_2 = {0, 0, 0, 0, 0};\n    int[] r_3 = {0, 0, 0, 0, 0};\n    int[] c_3 = {0, 0, 0, 0, 0};\n    int[] r_4 = {0, 0, 0, 0, 0};\n    int[] c_4 = {0, 0, 0, 0, 0};\n    int[] r_5 = {0, 0, 0, 0, 0};\n    int[] c_5 = {0, 0, 0, 0, 0};\n    int[] r_6 = {0, 0, 0, 0, 0};\n    int[] c_6 = {0, 0, 0, 0, 0};\n    int[] r_7 = {0, 0, 0, 0, 0};\n    int[] c_7 = {0, 0, 0, 0, 0};\n    int[] r_8 = {0, 0, 0, 0, 0};\n    int[] c_8 = {0, 0, 0, 0, 0};\n    int[] r_9 = {0, 0, 0, 0, 0};\n    int[] c_9 = {0, 0, 0, 0, 0};\n    int[] r_10 = {0, 0, 0, 0, 0};\n    int[] c_10 = {0, 0, 0, 0, 0};\n    int[] r_11 = {0, 0, 0,",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i <= k; i++) {\n        lst[i] = grid[0][0];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < M; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k - 1]) {\n                    lst[k - 1] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}\n",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k < i; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for (int k = 1; k < j; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int n = grid.length;\n    int m = grid[0].length;\n    long[][] dp = new long[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int ii = i - 1; ii <= i + 1; ii++) {\n                for (int jj = j - 1; jj <= j + 1; jj++) {\n                    if (ii >= 0 && ii < n && jj >= 0 && jj < m) {\n                        dp[ii][jj] = Math.min(dp[ii][jj], dp[i][j] + grid[ii][jj]);\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            result[i] = Math.min(result[i], dp[i][j]);\n        }\n    }\n    return result;\n}",
    "{\n    long[] result = new long[k];\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int[] dirs_count = {0, 0, 0, 0};\n    int[] dirs_index = {0, 0, 0, 0};\n    int[] dirs_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_index_index = {0, 0, 0, 0};",
    "{\n    long[] result = new long[k];\n    long[] lst = new long[k];\n    for(int i = 0; i < k; i++)\n        lst[i] = grid[0][0];\n    for(int i = 0; i < grid.length; i++)\n        for(int j = 0; j < grid[i].length; j++)\n            lst[0] = Math.min(lst[0], grid[i][j]);\n    for(int i = 1; i < k; i++)\n    {\n        for(int j = 0; j < grid.length; j++)\n            for(int k = 0; k < grid[j].length; k++)\n                lst[i] = Math.min(lst[i], grid[j][k] + lst[i - 1]);\n    }\n    for(int i = 0; i < k; i++)\n        result[i] = lst[i];\n    return result;\n}",
    "{\n    long[] lst = new long[k+1];\n    long[] lst_prev = new long[k+1];\n    long[] lst_curr = new long[k+1];\n    \n    lst[0] = grid[0][0];\n    lst_prev[0] = grid[0][0];\n    lst_curr[0] = grid[0][0];\n    \n    for(int i = 1; i <= k; i++)\n    {\n        lst[i] = grid[0][0];\n        lst_prev[i] = grid[0][0];\n        lst_curr[i] = grid[0][0];\n    }\n    \n    for(int i = 1; i < grid.length; i++)\n    {\n        for(int j = 1; j < grid[i].length; j++)\n        {\n            lst_curr[0] = Math.min(lst_prev[0], lst[0]);\n            lst[0] = Math.min(lst_prev[0], lst_curr[0]);\n            \n            for(int k = 1; k <= k; k++)\n            {\n                lst_curr[k] = Math.min(lst_prev[k], lst[k]);\n                lst[k] = Math.min(lst_prev[k], lst_curr[k]);\n            }\n            \n            lst_prev[0] = lst_prev[1];\n            lst_prev[1] = lst_curr[1];\n            lst_prev[k+1] = lst_curr[k+1];\n            \n            lst_curr[0] = grid[i][j];\n            lst_curr[k+1] = grid[i][j];\n        }\n    }\n    \n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            lst[i] = Math.min(lst[i], grid[j][0] + grid[j][N - 1]);\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    long[] dp = new long[grid.length * grid[0].length];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            dp[i * grid[0].length + j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            for (int k = 1; k <= k; k++) {\n                if (i - 1 >= 0 && j - 1 >= 0) {\n                    if (dp[(i - 1) * grid[0].length + j - 1] < dp[i * grid[0].length + j]) {\n                        dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length + j - 1];\n                    }\n                }\n                if (i - 1 >= 0) {\n                    if (dp[(i - 1) * grid[0].length + j] < dp[i * grid[0].length + j]) {\n                        dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length + j];\n                    }\n                }\n                if (j - 1 >= 0) {\n                    if (dp[i * grid[0].length + j - 1] < dp[i * grid[0].length + j]) {\n                        dp[i * grid[0].length + j] = dp[i * grid[0].length + j - 1];\n                    }\n                }\n            }\n        }\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            lst[k] = grid[i][j];\n            k--;\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    int[] dirs = {0, 1, 0, -1, 0};\n    int[] dir = {0, 0, 0, 0, 0};\n    int[] row = {0, 0, 0, 0, 0};\n    int[] col = {0, 0, 0, 0, 0};\n    int[] r = {0, 0, 0, 0, 0};\n    int[] c = {0, 0, 0, 0, 0};\n    int[] r_ = {0, 0, 0, 0, 0};\n    int[] c_ = {0, 0, 0, 0, 0};\n    int[] r_2 = {0, 0, 0, 0, 0};\n    int[] c_2 = {0, 0, 0, 0, 0};\n    int[] r_3 = {0, 0, 0, 0, 0};\n    int[] c_3 = {0, 0, 0, 0, 0};\n    int[] r_4 = {0, 0, 0, 0, 0};\n    int[] c_4 = {0, 0, 0, 0, 0};\n    int[] r_5 = {0, 0, 0, 0, 0};\n    int[] c_5 = {0, 0, 0, 0, 0};\n    int[] r_6 = {0, 0, 0, 0, 0};\n    int[] c_6 = {0, 0, 0, 0, 0};\n    int[] r_7 = {0, 0, 0, 0, 0};\n    int[] c_7 = {0, 0, 0, 0, 0};\n    int[] r_8 = {0, 0, 0, 0, 0};\n    int[] c_8 = {0, 0, 0, 0, 0};\n    int[] r_9 = {0, 0, 0, 0, 0};\n    int[] c_9 = {0, 0, 0, 0, 0};\n    int[] r_10 = {0, 0, 0, 0, 0};\n    int[] c_10 = {0, 0, 0, 0, 0};\n    int[] r_11 = {0, 0, 0,",
    "{\n    long[] lst = new long[k+1];\n    long[] lst_tmp = new long[k+1];\n    long[] lst_tmp2 = new long[k+1];\n    long[] lst_tmp3 = new long[k+1];\n    long[] lst_tmp4 = new long[k+1];\n    long[] lst_tmp5 = new long[k+1];\n    long[] lst_tmp6 = new long[k+1];\n    long[] lst_tmp7 = new long[k+1];\n    long[] lst_tmp8 = new long[k+1];\n    long[] lst_tmp9 = new long[k+1];\n    long[] lst_tmp10 = new long[k+1];\n    long[] lst_tmp11 = new long[k+1];\n    long[] lst_tmp12 = new long[k+1];\n    long[] lst_tmp13 = new long[k+1];\n    long[] lst_tmp14 = new long[k+1];\n    long[] lst_tmp15 = new long[k+1];\n    long[] lst_tmp16 = new long[k+1];\n    long[] lst_tmp17 = new long[k+1];\n    long[] lst_tmp18 = new long[k+1];\n    long[] lst_tmp19 = new long[k+1];\n    long[] lst_tmp20 = new long[k+1];\n    long[] lst_tmp21 = new long[k+1];\n    long[] lst_tmp22 = new long[k+1];\n    long[] lst_tmp23 = new long[k+1];\n    long[] lst_tmp24 = new long[k+1];\n    long[] lst_tmp25 = new long[k+1];\n    long[] lst_tmp26 = new long[k+1];\n    long[] lst_tmp27 = new long[k+1];\n    long[] lst_tmp28 = new long[k+1];\n    long[] lst_tmp29 = new long[k+1];\n    long[] l",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i-1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k+1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k-1], Math.min(grid[i][j], grid[i][j+1]));\n                lst[k] = Math.min(lst[k], Math.min(grid[i][j], grid[i+1][j]));\n                lst[k] = Math.min(lst[k], Math.min(grid[i][j], grid[i][j-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k]) {\n                    for (int l = 1; l < k; l++) {\n                        if (lst[l] < lst[k]) {\n                            lst[k] = lst[l];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    int[] dirs = new int[]{0, 1, 0, -1, 0};\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 0; j < 4; j++) {\n            int x = i + dirs[j];\n            int y = j + 1;\n            if (x >= 0 && x < N && y >= 0 && y < N && grid[x][y] < lst[i]) {\n                lst[i] = grid[x][y];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    long[] dp = new long[N * N];\n    for (int i = 0; i < N * N; i++) {\n        dp[i] = grid[0][i];\n    }\n    for (int i = 1; i < N * N; i++) {\n        for (int j = 0; j < N * N; j++) {\n            if (i == j) {\n                continue;\n            }\n            if (grid[i / N][i % N] < grid[j / N][j % N]) {\n                dp[i] = Math.min(dp[i], dp[j] + grid[i / N][i % N]);\n            }\n        }\n    }\n    for (int i = 0; i < N * N; i++) {\n        lst[i] = dp[i];\n    }\n    for (int i = k; i >= 1; i--) {\n        for (int j = 0; j < N * N; j++) {\n            if (lst[j] == dp[j]) {\n                lst[j] = dp[j] = grid[j / N][j % N];\n            }\n        }\n    }\n    return lst;\n}\n",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (i - 1 >= 0 && grid[i - 1][j] < lst[k]) {\n                    lst[k] = grid[i - 1][j];\n                }\n                if (j - 1 >= 0 && grid[i][j - 1] < lst[k]) {\n                    lst[k] = grid[i][j - 1];\n                }\n                if (i + 1 < N && grid[i + 1][j] < lst[k]) {\n                    lst[k] = grid[i + 1][j];\n                }\n                if (j + 1 < N && grid[i][j + 1] < lst[k]) {\n                    lst[k] = grid[i][j + 1];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    int[] dp = new int[grid.length * grid[0].length];\n    \n    for(int i = 0; i < grid.length; i++)\n    {\n        for(int j = 0; j < grid[0].length; j++)\n        {\n            if(i == 0 && j == 0)\n            {\n                dp[i * grid[0].length + j] = 1;\n            }\n            else if(i == 0)\n            {\n                dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length + j] + 1;\n            }\n            else if(j == 0)\n            {\n                dp[i * grid[0].length + j] = dp[i * grid[0].length + j - 1] + 1;\n            }\n            else\n            {\n                dp[i * grid[0].length + j] = Math.min(dp[(i - 1) * grid[0].length + j], Math.min(dp[i * grid[0].length + j - 1], dp[(i - 1) * grid[0].length + j - 1]));\n            }\n        }\n    }\n    \n    for(int i = 0; i < grid.length; i++)\n    {\n        for(int j = 0; j < grid[0].length; j++)\n        {\n            if(i == 0 && j == 0)\n            {\n                lst[0] = grid[i][j];\n            }\n            else if(i == 0)\n            {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            }\n            else if(j == 0)\n            {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            }\n            else\n            {\n                lst[0] = Math.min(lst[0], dp[i * grid[0].length + j]);\n            }\n        }\n    }\n    \n    for(int i = 1; i < lst",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) \n    {\n        for (int j = 0; j < M; j++) \n        {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) \n            {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] ans = new long[k+1];\n    int n = grid.length;\n    int m = grid[0].length;\n    long[][] dp = new long[n][m];\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            dp[i][j] = grid[i][j];\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i+di][j+dj], dp[i][j]));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i+di][j+dj], dp[i][j]));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], Math.max(dp[i+di][j+dj], dp[i][j]));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < m; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj !=",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k - 1]) {\n                    lst[k - 1] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        ans[dp[i][j] - 1] = Math.min(ans[dp[i][j] - 1], dp[i + di][j + dj] + 1);\n    \n    return ans;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    lst[0] = 0;\n    for(int i = 1; i <= k; i++)\n    {\n        lst[i] = grid[0][0];\n        for(int j = 1; j < N; j++)\n        {\n            lst[i] = Math.min(lst[i], grid[j][0] + grid[j][1]);\n        }\n        for(int j = 1; j < M; j++)\n        {\n            lst[i] = Math.min(lst[i], grid[0][j] + grid[1][j]);\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < lst[i-1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < lst[i-1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int[] dirs = {0, 1, 0, -1, 0};\n    int[] dirs_rev = {0, -1, 0, 1, 0};\n    int[] dirs_rev_rev = {0, 0, 1, 0, -1};\n    int[] dirs_rev_rev_rev = {0, 0, -1, 1, 0};\n    int[] dirs_rev_rev_rev_rev = {0, 0, 0, -1, 1};\n    int[] dirs_rev_rev_rev_rev_rev = {0, 0, 0, 1, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = {0, 0, 0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev",
    "{\n    int N = grid.length;\n    long[][] lst = new long[N][N];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            lst[i][j] = grid[i][j];\n    \n    long[][] dp = new long[N][N];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            dp[i][j] = lst[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int ii = 0; ii < N; ii++)\n                for(int jj = 0; jj < N; jj++)\n                    if(i != ii && j != jj)\n                        dp[i][j] = Math.min(dp[i][j], Math.min(dp[i][ii], dp[ii][jj]) + dp[ii][jj]);\n    \n    long[] ans = new long[k];\n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            if(dp[i][j] == ans[0])\n                for(int ii = 0; ii < N; ii++)\n                    for(int jj = 0; jj < N; jj++)\n                        if(i != ii && j != jj)\n                            if(dp[i][j] == dp[i][ii] + dp[ii][jj])\n                                ans[0] = dp[i][j];\n    \n    return ans;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k - 1]) {\n                    lst[k - 1] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k + 1];\n    int[] dirs = {0, 1, 0, -1, 0};\n    int[] dir = {0, 0, 0, 0, 0};\n    int[] visited = new int[grid.length * grid[0].length];\n    int[] lst = new int[k + 1];\n    int[] lst_visited = new int[grid.length * grid[0].length];\n    int[] lst_dir = new int[grid.length * grid[0].length];\n    int[] lst_lst = new int[grid.length * grid[0].length];\n    int[] lst_lst_visited = new int[grid.length * grid[0].length];\n    int[] lst_lst_dir = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_visited = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_dir = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst_visited = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst_dir = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst_lst = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst_lst_visited = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst_lst_dir = new int[grid.length * grid[0].length];\n    int[] lst_lst_lst_lst_lst_lst = new int[grid.length * grid[0].length",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++) {\n        lst[i] = grid[0][0];\n    }\n    \n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            for (int d = 0; d < 4; d++) {\n                int x = i + d, y = j + d;\n                if (x >= 0 && x < grid.length && y >= 0 && y < grid[x].length) {\n                    lst[0] = Math.min(lst[0], grid[x][y]);\n                }\n            }\n        }\n    }\n    \n    for (int i = 1; i < lst.length; i++) {\n        lst[i] = Math.min(lst[i], lst[i - 1]);\n    }\n    \n    return lst;\n}",
    "{\n    int n = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1L) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < grid.length; i++)\n        for (int j = 0; j < grid[i].length; j++)\n            for (int d = 0; d < 4; d++)\n            {\n                int x = i + d, y = j + d;\n                if (x >= 0 && x < grid.length && y >= 0 && y < grid[x].length)\n                {\n                    if (grid[x][y] < lst[0])\n                        lst[0] = grid[x][y];\n                    else if (grid[x][y] == lst[0])\n                        lst[0] = Math.min(lst[0], lst[i + 1]);\n                }\n            }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    int[] dp = new int[grid.length * grid[0].length];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            dp[i * grid[0].length + j] = grid[i][j] + 1;\n        }\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[0].length; j++) {\n            for (int k = 1; k <= k; k++) {\n                if (i - 1 >= 0 && dp[(i - 1) * grid[0].length + j] < dp[i * grid[0].length + j]) {\n                    dp[i * grid[0].length + j] = dp[(i - 1) * grid[0].length + j];\n                }\n                if (j - 1 >= 0 && dp[i * grid[0].length + (j - 1)] < dp[i * grid[0].length + j]) {\n                    dp[i * grid[0].length + j] = dp[i * grid[0].length + (j - 1)];\n                }\n                if (i + 1 < grid.length && dp[(i + 1) * grid[0].length + j] < dp[i * grid[0].length + j]) {\n                    dp[i * grid[0].length + j] = dp[(i + 1) * grid[0].length + j];\n                }\n                if (j + 1 < grid[0].length && dp[i * grid[0].length + (j + 1)] < dp[i * grid[0].length + j]) {\n                    dp[i * grid[0].length + j] = dp[i * grid[0].length + (j + 1)];\n                }\n            }\n            lst[k] = Math.min(lst[k], dp[i * grid[0].length + j]);\n        }\n    }\n    return l",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int[] row = new int[grid.length];\n    int[] col = new int[grid[0].length];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            row[i] = Math.max(row[i], grid[i][j]);\n            col[j] = Math.max(col[j], grid[i][j]);\n        }\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            if (row[i] == grid[i][j] && col[j] == grid[i][j]) {\n                result[0] = grid[i][j];\n                for (int k = 1; k < k; k++) {\n                    result[k] = grid[i][j];\n                }\n                break;\n            }\n        }\n    }\n    return result;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] dp = new long[N * M];\n    for (int i = 0; i < N * M; i++)\n        dp[i] = grid[i / M][i % M] + 1;\n    for (int i = 1; i <= k; i++)\n        lst[i] = dp[0];\n    for (int i = 1; i < N * M; i++) {\n        for (int j = 1; j <= k; j++) {\n            if (dp[i - 1] < dp[i])\n                dp[i] = dp[i - 1];\n            else if (dp[i - 1] > dp[i] && dp[i - 1] < dp[i + 1])\n                dp[i] = dp[i - 1];\n            else if (dp[i - 1] > dp[i] && dp[i - 1] > dp[i + 1])\n                dp[i] = dp[i + 1];\n            else if (dp[i - 1] > dp[i] && dp[i - 1] > dp[i + 1] && dp[i - 1] < lst[j])\n                lst[j] = dp[i - 1];\n        }\n    }\n    return lst;\n}",
    "{\n    long[] ans = new long[k];\n    int n = grid.length;\n    long[][] dp = new long[n][n];\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            dp[i][j] = grid[i][j];\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int m = 1; m <= k; m++)\n                if(i + m < n && j + m < n)\n                    dp[i][j] = Math.min(dp[i][j], Math.min(dp[i + m][j], dp[i][j + m]));\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            ans[dp[i][j] - 1] = grid[i][j];\n    return ans;\n}",
    "{\n    int N = grid.length;\n    long[][] dp = new long[N][N];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (i > 0) {\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + grid[i][j]);\n            }\n            if (j > 0) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + grid[i][j]);\n            }\n        }\n    }\n    long[] ans = new long[k + 1];\n    for (int i = 0; i < k + 1; i++) {\n        ans[i] = dp[N - 1][N - 1];\n        for (int j = N - 2; j >= 0; j--) {\n            if (i > 0) {\n                ans[i] = Math.min(ans[i], dp[j][N - 1] + grid[j][N - 1]);\n            }\n            if (j > 0) {\n                ans[i] = Math.min(ans[i], dp[j][N - 2] + grid[j][N - 2]);\n            }\n        }\n    }\n    return ans;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k < i; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for (int k = 1; k < j; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j <= k; j++) {\n            lst[j] = Math.min(lst[j], grid[i][j]);\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for(int i = 1; i < grid.length; i++) {\n        for(int j = 1; j < grid[i].length; j++) {\n            if(grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for(int k = 1; k < i; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for(int k = 1; k < j; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) continue;\n            for (int d = 0; d < 4; d++) {\n                int x = i + d[0];\n                int y = j + d[1];\n                if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0) {\n                    lst[1] = grid[i][j];\n                    lst[2] = grid[x][y];\n                    if (lst[1] < lst[2]) {\n                        lst[0] = 1;\n                        lst[1] = grid[i][j];\n                        lst[2] = grid[x][y];\n                    }\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < grid.length; i++)\n        for (int j = 0; j < grid[i].length; j++)\n            if (grid[i][j] > 0)\n                for (int[] d : [[-1, 0], [1, 0], [0, -1], [0, 1]])\n                    if (i + d[0] >= 0 && i + d[0] < grid.length && j + d[1] >= 0 && j + d[1] < grid[i].length)\n                        if (grid[i + d[0]][j + d[1]] > 0)\n                            lst[0] = Math.min(lst[0], grid[i + d[0]][j + d[1]]);\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) \n        for (int j = 0; j < M; j++) \n            lst[0] = Math.min(lst[0], grid[i][j]);\n    for (int i = 1; i <= k; i++) \n        for (int j = 0; j < M; j++) \n            lst[i] = Math.min(lst[i], lst[i - 1] + grid[i - 1][j]);\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[][] dp = new long[grid.length][grid[0].length];\n    for(int i = 0; i < grid.length; i++)\n        for(int j = 0; j < grid[0].length; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < grid.length; i++)\n        for(int j = 0; j < grid[0].length; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k + 1];\n    for(int i = 0; i < grid.length; i++)\n        for(int j = 0; j < grid[0].length; j++)\n            for(int k = 1; k <= k; k++)\n                if(dp[i][j] == k)\n                    ans[k] = grid[i][j];\n    return ans;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < grid.length; i++)\n        for (int j = 0; j < grid[i].length; j++)\n            if (grid[i][j] > 0)\n                for (int d = 0; d < 4; d++) {\n                    int x = i + d[0], y = j + d[1];\n                    if (x >= 0 && x < grid.length && y >= 0 && y < grid[x].length && grid[x][y] > 0)\n                        lst[0] = Math.min(lst[0], grid[x][y]);\n                }\n    for (int i = 1; i < lst.length; i++)\n        lst[i] = lst[i - 1] + grid[0][0];\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    \n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    \n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            for (int dir = 0; dir < 4; dir++)\n            {\n                int nx = i + dirs[dir][0];\n                int ny = j + dirs[dir][1];\n                if (nx >= 0 && nx < N && ny >= 0 && ny < M && dp[i][j] + 1 < dp[nx][ny])\n                    dp[nx][ny] = dp[i][j] + 1;\n            }\n    \n    long[] ans = new long[k];\n    for (int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    \n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            if (dp[i][j] == ans[0])\n                for (int dir = 0; dir < 4; dir++)\n                {\n                    int nx = i + dirs[dir][0];\n                    int ny = j + dirs[dir][1];\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < M && dp[nx][ny] == ans[0])\n                        ans[0] = dp[nx][ny];\n                }\n    \n    return ans;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + grid[i][j - 1] + grid[i - 1][j] + grid[i - 1][j - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k+1];\n    result[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        result[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < result[i-1]) {\n                result[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < result[i-1]) {\n                result[i] = grid[0][j];\n            }\n        }\n    }\n    return result;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] dp = new long[N * M];\n    for (int i = 0; i < N * M; i++)\n        dp[i] = grid[i / M][i % M] + 1;\n    for (int i = 1; i <= k; i++)\n        lst[i] = dp[0];\n    for (int i = 1; i <= N * M; i++) {\n        for (int j = 1; j <= k; j++) {\n            if (i - 1 >= 0 && dp[i - 1] < dp[i])\n                lst[j] = Math.min(lst[j], dp[i - 1]);\n            if (i + 1 < N * M && dp[i + 1] < dp[i])\n                lst[j] = Math.min(lst[j], dp[i + 1]);\n            if (j - 1 >= 0 && dp[i - 1] + 1 < dp[i])\n                lst[j] = Math.min(lst[j], dp[i - 1] + 1);\n            if (j + 1 < k + 1 && dp[i + 1] + 1 < dp[i])\n                lst[j] = Math.min(lst[j], dp[i + 1] + 1);\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k+1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + lst[k-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < n; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        for (int j = 1; j < n; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k + 1];\n    int[] dirs = new int[] {0, 1, 0, -1, 0};\n    int[] dirs_rev = new int[] {0, -1, 0, 1, 0};\n    int[] dirs_rev_rev = new int[] {0, 0, 1, 0, -1};\n    int[] dirs_rev_rev_rev = new int[] {0, 0, -1, 0, 1};\n    int[] dirs_rev_rev_rev_rev = new int[] {0, 0, 0, 1, 0};\n    int[] dirs_rev_rev_rev_rev_rev = new int[] {0, 0, 0, -1, 0};\n    int[] dirs_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, 0, 0, -1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0, 0, 0, 0, 0, 1};\n    int[] dirs_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev_rev = new int[] {0, 0, 0,",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1L) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int kk = 1; kk <= k; kk++)\n                if(dp[i][j] == kk)\n                    ans[kk] = grid[i][j];\n    \n    return ans;\n}",
    "{\n    long[] lst = new long[k+1];\n    for(int i = 0; i < grid.length; i++)\n    {\n        for(int j = 0; j < grid[i].length; j++)\n        {\n            lst[0] = grid[i][j];\n            for(int k = 1; k <= k; k++)\n            {\n                lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + lst[k-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < lst[i-1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < lst[i-1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = lst[i - 1] + 1;\n        for (int j = 0; j < N; j++) {\n            for (int m = 0; m < M; m++) {\n                if (grid[j][m] == lst[i - 1]) {\n                    lst[i] = Math.min(lst[i], lst[i - 1] + 1);\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] ans = new long[k];\n    long[] lst = new long[k];\n    long[] lst_prev = new long[k];\n    long[] lst_curr = new long[k];\n    long[] lst_next = new long[k];\n    long[] lst_prev_prev = new long[k];\n    long[] lst_curr_prev = new long[k];\n    long[] lst_next_prev = new long[k];\n    long[] lst_prev_next = new long[k];\n    long[] lst_curr_next = new long[k];\n    long[] lst_next_next = new long[k];\n    long[] lst_prev_prev_prev = new long[k];\n    long[] lst_curr_prev_prev = new long[k];\n    long[] lst_next_prev_prev = new long[k];\n    long[] lst_prev_next_prev = new long[k];\n    long[] lst_curr_next_prev = new long[k];\n    long[] lst_next_next_prev = new long[k];\n    long[] lst_prev_prev_next = new long[k];\n    long[] lst_curr_prev_next = new long[k];\n    long[] lst_next_prev_next = new long[k];\n    long[] lst_prev_next_next = new long[k];\n    long[] lst_curr_next_next = new long[k];\n    long[] lst_next_next_next = new long[k];\n    long[] lst_prev_prev_prev_prev = new long[k];\n    long[] lst_curr_prev_prev_prev = new long[k];\n    long[] lst_next_prev_prev_prev = new long[k];\n    long[] lst_prev_next_prev_prev = new long[k];\n    long[] lst_curr_next_prev_prev = new long[k];\n    long[] lst_next_next_prev_prev = new long[k];\n    long[] l",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = 1;\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int[] dirs = new int[]{0, 1, 0, -1, 0};\n    int[] dir = new int[4];\n    int[] dir_count = new int[4];\n    int[] dir_index = new int[4];\n    int[] dir_index_count = new int[4];\n    int[] dir_index_count_temp = new int[4];\n    int[] dir_index_count_temp_2 = new int[4];\n    int[] dir_index_count_temp_3 = new int[4];\n    int[] dir_index_count_temp_4 = new int[4];\n    int[] dir_index_count_temp_5 = new int[4];\n    int[] dir_index_count_temp_6 = new int[4];\n    int[] dir_index_count_temp_7 = new int[4];\n    int[] dir_index_count_temp_8 = new int[4];\n    int[] dir_index_count_temp_9 = new int[4];\n    int[] dir_index_count_temp_10 = new int[4];\n    int[] dir_index_count_temp_11 = new int[4];\n    int[] dir_index_count_temp_12 = new int[4];\n    int[] dir_index_count_temp_13 = new int[4];\n    int[] dir_index_count_temp_14 = new int[4];\n    int[] dir_index_count_temp_15 = new int[4];\n    int[] dir_index_count_temp_16 = new int[4];\n    int[] dir_index_count_temp_17 = new int[4];\n    int[] dir_index_count_temp_18 = new int[4];\n    int[] dir_index_count_temp_19 = new int[4];\n    int[] dir_index_count_temp_20 = new int[4];\n    int[] dir_index_count_temp_21 = new int[4];\n    int[] dir_index_count_temp_22 = new int[4];\n    int[] dir_index_count_",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i <= k; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++)\n            for (int k = 1; k <= k; k++)\n                if (grid[i][j] > lst[k - 1])\n                    lst[k] = grid[i][j];\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    \n    long[] lst = new long[k + 1];\n    \n    for (int i = 0; i <= k; i++) {\n        lst[i] = grid[0][0];\n    }\n    \n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < M; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (i - 1 >= 0 && grid[i - 1][j] < lst[k]) {\n                    lst[k] = grid[i - 1][j];\n                }\n                if (i + 1 < N && grid[i + 1][j] < lst[k]) {\n                    lst[k] = grid[i + 1][j];\n                }\n                if (j - 1 >= 0 && grid[i][j - 1] < lst[k]) {\n                    lst[k] = grid[i][j - 1];\n                }\n                if (j + 1 < M && grid[i][j + 1] < lst[k]) {\n                    lst[k] = grid[i][j + 1];\n                }\n            }\n        }\n    }\n    \n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int kk = 1; kk <= k; kk++)\n                if(dp[i][j] == dp[i][j] + 1)\n                    ans[kk] = grid[i][j];\n    return ans;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + lst[k-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[][] dp = new long[N][N];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        ans[dp[i][j] - 1] = Math.min(ans[dp[i][j] - 1], grid[i + di][j + dj]);\n    \n    return ans;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                dfs(grid, i, j, lst, 1);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (i - 1 >= 0 && grid[i - 1][j] < lst[k]) {\n                    lst[k] = grid[i - 1][j];\n                }\n                if (j - 1 >= 0 && grid[i][j - 1] < lst[k]) {\n                    lst[k] = grid[i][j - 1];\n                }\n                if (i + 1 < N && grid[i + 1][j] < lst[k]) {\n                    lst[k] = grid[i + 1][j];\n                }\n                if (j + 1 < N && grid[i][j + 1] < lst[k]) {\n                    lst[k] = grid[i][j + 1];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for(int j = 1; j < grid.length; j++) {\n            if(grid[j][0] < lst[i-1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for(int j = 1; j < grid[0].length; j++) {\n            if(grid[0][j] < lst[i-1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k+1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + lst[k-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k-1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    long[] lst_prev = new long[k + 1];\n    long[] lst_curr = new long[k + 1];\n    long[] lst_next = new long[k + 1];\n    long[] lst_next_prev = new long[k + 1];\n    long[] lst_next_curr = new long[k + 1];\n    long[] lst_next_next = new long[k + 1];\n    long[] lst_next_next_prev = new long[k + 1];\n    long[] lst_next_next_curr = new long[k + 1];\n    long[] lst_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_prev = new long[k + 1];\n    long[] lst_next_next_next_curr = new long[k + 1];\n    long[] lst_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_prev = new long[k + 1];\n    long[] lst_next_next_next_next_curr = new long[k + 1];\n    long[] lst_next_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_next_prev = new long[k + 1];\n    long[] lst_next_next_next_next_next_curr = new long[k + 1];\n    long[] lst_next_next_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_next_next_prev = new long[k + 1];\n    long[] lst_next_next_next_next_next_next_curr = new long[k + 1];\n    long[] lst_next_next_next_next_next_next_next = new long[k + 1];\n    long[] lst_next_next_next_next_next_next_next_prev = new long[k +",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < grid.length; j++) {\n            if (grid[j][0] < lst[i-1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < grid[0].length; j++) {\n            if (grid[0][j] < lst[i-1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            for (int x = 0; x < 4; x++) {\n                int i_n = i + dx[x];\n                int j_n = j + dy[x];\n                if (i_n >= 0 && i_n < N && j_n >= 0 && j_n < M && dp[i_n][j_n] > dp[i][j] + 1) {\n                    dp[i_n][j_n] = dp[i][j] + 1;\n                }\n            }\n        }\n    }\n    \n    long[] ans = new long[k];\n    for (int i = 0; i < k; i++) {\n        ans[i] = dp[0][0];\n        for (int j = 0; j < M; j++) {\n            if (dp[0][j] > ans[i]) {\n                ans[i] = dp[0][j];\n            }\n        }\n        for (int j = 0; j < N; j++) {\n            if (dp[j][0] > ans[i]) {\n                ans[i] = dp[j][0];\n            }\n        }\n        for (int j = 0; j < M; j++) {\n            for (int x = 0; x < 4; x++) {\n                int i_n = i + dx[x];\n                int j_n = j + dy[x];\n                if (i_n >= 0 && i_n < N && j_n >= 0 && j_n < M && dp[i_n][j_n] > ans[i]) {\n                    ans[i] = dp[",
    "{\n    int n = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst[k - 1]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k+1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + lst[k-1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < M; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int[] dirs = new int[] {0, 1, 0, -1, 0};\n    int[] dir = new int[4];\n    int[] next = new int[4];\n    int[] visited = new int[grid.length * grid[0].length];\n    int[] count = new int[grid[0].length];\n    int[] index = new int[grid[0].length];\n    int[] index_next = new int[grid[0].length];\n    int[] index_prev = new int[grid[0].length];\n    int[] index_prev_next = new int[grid[0].length];\n    int[] index_prev_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next_next_next_next_next_next_next_next_next_next = new int[grid[0].length];\n    int[] index_prev_next_next_next",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] dp = new long[N * M];\n    for (int i = 0; i < N * M; i++)\n        dp[i] = grid[0][0];\n    for (int i = 0; i < N; i++)\n        for (int j = 0; j < M; j++) {\n            if (i == 0 && j == 0)\n                continue;\n            if (i == 0)\n                dp[j] = Math.min(dp[j], dp[j - 1] + grid[i][j]);\n            else if (j == 0)\n                dp[i] = Math.min(dp[i], dp[i - 1] + grid[i][j]);\n            else\n                dp[i + j] = Math.min(dp[i + j], dp[i - 1] + grid[i][j] + dp[i][j - 1]);\n        }\n    for (int i = 0; i < N * M; i++)\n        lst[i] = dp[i];\n    for (int i = 1; i < k + 1; i++)\n        lst[i] = lst[i - 1];\n    return lst;\n}\n",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < grid.length; i++)\n        for (int j = 0; j < grid[i].length; j++)\n            if (grid[i][j] > 0)\n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = i + dirr[dir][0];\n                    int ny = j + dirr[dir][1];\n                    if (nx >= 0 && nx < grid.length && ny >= 0 && ny < grid[i].length && grid[nx][ny] > 0) {\n                        lst[0] = Math.min(lst[0], grid[nx][ny]);\n                    }\n                }\n    for (int i = 1; i < lst.length; i++)\n        lst[i] = Math.min(lst[i], lst[i - 1]);\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        for (int j = 0; j < grid.length; j++) {\n            if (grid[j][i - 1] < lst[i - 1]) {\n                lst[i] = grid[j][i - 1];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    int[] dirs_count = {0, 0, 0, 0};\n    int[] dirs_index = {0, 0, 0, 0};\n    int[] dirs_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_index = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_index_count = {0, 0, 0, 0};\n    int[] dirs_index_index_index_index_index_index_index_index_index = {0, 0, 0, 0};",
    "{\n    int n = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = 1;\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i - 1][j] + 1));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int kk = 1; kk <= k; kk++)\n                if(dp[i][j] == kk)\n                    ans[kk] = grid[i][j];\n    return ans;\n}",
    "{\n    long[] result = new long[k];\n    long[] lst = new long[k];\n    int[] dirs = new int[4];\n    dirs[0] = 0; dirs[1] = 1; dirs[2] = 0; dirs[3] = -1;\n    int[] dir = new int[4];\n    int[] dir_ = new int[4];\n    int[] dir_2 = new int[4];\n    int[] dir_3 = new int[4];\n    int[] dir_4 = new int[4];\n    int[] dir_5 = new int[4];\n    int[] dir_6 = new int[4];\n    int[] dir_7 = new int[4];\n    int[] dir_8 = new int[4];\n    int[] dir_9 = new int[4];\n    int[] dir_10 = new int[4];\n    int[] dir_11 = new int[4];\n    int[] dir_12 = new int[4];\n    int[] dir_13 = new int[4];\n    int[] dir_14 = new int[4];\n    int[] dir_15 = new int[4];\n    int[] dir_16 = new int[4];\n    int[] dir_17 = new int[4];\n    int[] dir_18 = new int[4];\n    int[] dir_19 = new int[4];\n    int[] dir_20 = new int[4];\n    int[] dir_21 = new int[4];\n    int[] dir_22 = new int[4];\n    int[] dir_23 = new int[4];\n    int[] dir_24 = new int[4];\n    int[] dir_25 = new int[4];\n    int[] dir_26 = new int[4];\n    int[] dir_27 = new int[4];\n    int[] dir_28 = new int[4];\n    int[] dir_29 = new int[4];\n    int[] dir_30 = new int[4];\n    int[] dir_31 = new int[4];\n    int[] dir_32 = new int[4];\n    int[] dir_33 = new int[4];\n    ",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < N; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n        for (int j = 1; j < N; j++) {\n            if (grid[j][j] < lst[i - 1]) {\n                lst[i] = grid[j][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    int n = grid.length;\n    int m = grid[0].length;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                dfs(grid, i, j, lst, 1);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for(int i = 1; i < grid.length; i++) {\n        for(int j = 1; j < grid[i].length; j++) {\n            if(grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for(int k = 1; k <= k; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] result = new long[k];\n    int[] dirs = {-1, 0, 1};\n    int[] dir = {0, 1, 0};\n    int[] dirs2 = {-1, 0, 1, 0};\n    int[] dir2 = {0, 1, 0, 1};\n    int[] dirs3 = {-1, 0, 1, 0, 0};\n    int[] dir3 = {0, 1, 0, 1, 0};\n    int[] dirs4 = {-1, 0, 1, 0, 0, 0};\n    int[] dir4 = {0, 1, 0, 1, 0, 1};\n    int[] dirs5 = {-1, 0, 1, 0, 0, 0, 0};\n    int[] dir5 = {0, 1, 0, 1, 0, 1, 0};\n    int[] dirs6 = {-1, 0, 1, 0, 0, 0, 0, 0};\n    int[] dir6 = {0, 1, 0, 1, 0, 1, 0, 1};\n    int[] dirs7 = {-1, 0, 1, 0, 0, 0, 0, 0, 0};\n    int[] dir7 = {0, 1, 0, 1, 0, 1, 0, 1, 0};\n    int[] dirs8 = {-1, 0, 1, 0, 0, 0, 0, 0, 0, 0};\n    int[] dir8 = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n    int[] dirs9 = {-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0};\n    int[] dir9 = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n    int[] dirs10 = {-1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    int[] dir10 = {0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};\n    int[] dirs11 = {-1, 0, 1, 0, 0, 0,",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++) {\n        lst[i] = grid[0][0];\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            if (i == 0 && j == 0) {\n                continue;\n            }\n            if (i == 0) {\n                lst[0] = grid[i][j];\n                continue;\n            }\n            if (j == 0) {\n                lst[0] = grid[i][j];\n                continue;\n            }\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            if (grid[i][j] < lst[1]) {\n                lst[1] = grid[i][j];\n            }\n            if (grid[i][j] < lst[2]) {\n                lst[2] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    long[] lst = new long[k + 1];\n    int[] dirs = new int[n * n];\n    for (int i = 0; i < n * n; i++)\n        dirs[i] = 0;\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = lst[i - 1] + grid[0][i];\n        dirs[0] = 1;\n        for (int j = 1; j < n; j++) {\n            if (grid[j][i - 1] < grid[j][i]) {\n                lst[i] = Math.min(lst[i], lst[i - 1] + grid[j][i]);\n                dirs[j] = 1;\n            } else {\n                lst[i] = Math.min(lst[i], lst[i - 1] + grid[j][i - 1]);\n                dirs[j] = 0;\n            }\n        }\n    }\n    int[] res = new int[k + 1];\n    for (int i = 0; i < n * n; i++) {\n        if (dirs[i] == 1) {\n            res[k] = i;\n            break;\n        }\n    }\n    for (int i = k - 1; i >= 0; i--) {\n        res[i] = res[i + 1];\n        for (int j = 0; j < n; j++) {\n            if (dirs[res[i + 1]] == 1 && grid[j][res[i + 1]] < grid[j][res[i]]) {\n                res[i] = res[i + 1];\n                break;\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    int[] dp = new int[grid.length * grid[0].length];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            dp[i * grid[0].length + j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            for (int ii = -1; ii <= 1; ii++) {\n                for (int jj = -1; jj <= 1; jj++) {\n                    if (ii == 0 && jj == 0) continue;\n                    int n_i = i + ii;\n                    int n_j = j + jj;\n                    if (n_i < 0 || n_i >= grid.length || n_j < 0 || n_j >= grid[0].length) continue;\n                    if (dp[n_i * grid[0].length + n_j] > dp[i * grid[0].length + j] + 1) {\n                        dp[n_i * grid[0].length + n_j] = dp[i * grid[0].length + j] + 1;\n                        lst[dp[n_i * grid[0].length + n_j]] = grid[i][j];\n                    }\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < lst.length; i++)\n        lst[i] = grid[0][0];\n    for (int i = 0; i < grid.length; i++)\n        for (int j = 0; j < grid[i].length; j++)\n            if (i > 0 && j > 0)\n                lst[0] = Math.min(lst[0], grid[i - 1][j - 1]);\n            else\n                lst[0] = Math.min(lst[0], grid[i][j]);\n    for (int i = 1; i < lst.length; i++)\n        for (int j = 0; j < grid[0].length; j++)\n            if (i > 1 && j > 0)\n                lst[i] = Math.min(lst[i], grid[i - 1][j - 1] + lst[i - 1]);\n            else\n                lst[i] = Math.min(lst[i], grid[i][j] + lst[i - 1]);\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++)\n        lst[i] = grid[0][i];\n    for(int i = 1; i < grid.length; i++)\n        for(int j = 1; j < grid[i].length; j++)\n            if(grid[i][j] < lst[0])\n                lst[0] = grid[i][j];\n            else if(grid[i][j] < lst[1])\n                lst[1] = grid[i][j];\n            else if(grid[i][j] < lst[2])\n                lst[2] = grid[i][j];\n            else if(grid[i][j] < lst[3])\n                lst[3] = grid[i][j];\n            else if(grid[i][j] < lst[4])\n                lst[4] = grid[i][j];\n            else if(grid[i][j] < lst[5])\n                lst[5] = grid[i][j];\n            else if(grid[i][j] < lst[6])\n                lst[6] = grid[i][j];\n            else if(grid[i][j] < lst[7])\n                lst[7] = grid[i][j];\n            else if(grid[i][j] < lst[8])\n                lst[8] = grid[i][j];\n            else if(grid[i][j] < lst[9])\n                lst[9] = grid[i][j];\n            else if(grid[i][j] < lst[10])\n                lst[10] = grid[i][j];\n            else if(grid[i][j] < lst[11])\n                lst[11] = grid[i][j];\n            else if(grid[i][j] < lst[12])\n                lst[12] = grid[i][j];\n            else if(grid[i][j] < lst[13",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[k]) {\n                lst[k] = grid[i][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for(int i = 1; i < grid.length; i++) {\n        for(int j = 1; j < grid[0].length; j++) {\n            if(grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for(int k = 1; k < i; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for(int k = 1; k < j; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for(int k = 1; k < i; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for(int k = 1; k < j; k++) {\n                if(grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    long[] lst_prev = new long[k+1];\n    long[] lst_curr = new long[k+1];\n    \n    lst[0] = grid[0][0];\n    lst_prev[0] = lst[0];\n    \n    for(int i = 1; i <= k; i++) {\n        lst_curr[i] = grid[0][i];\n        lst_prev[i] = lst_curr[i];\n    }\n    \n    for(int i = 1; i < grid.length; i++) {\n        for(int j = 1; j < grid[i].length; j++) {\n            lst[0] = Math.min(lst[0], grid[i][j]);\n            for(int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k], grid[i][j] + lst_prev[k-1]);\n                lst_prev[k] = lst_curr[k];\n                lst_curr[k] = lst[k];\n            }\n        }\n    }\n    \n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] dp = new long[n * m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i * m + j] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 1; k <= k; k++) {\n                if (i - 1 >= 0 && j - 1 >= 0) {\n                    dp[i * m + j] = Math.min(dp[i * m + j], dp[(i - 1) * m + j - 1] + grid[i][j]);\n                }\n                if (i - 1 >= 0) {\n                    dp[i * m + j] = Math.min(dp[i * m + j], dp[(i - 1) * m + j] + grid[i][j]);\n                }\n                if (j - 1 >= 0) {\n                    dp[i * m + j] = Math.min(dp[i * m + j], dp[i * m + j - 1] + grid[i][j]);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[k] = dp[i * m + j];\n            k--;\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < M; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    int n = grid.length;\n    int m = grid[0].length;\n    int[][] dp = new int[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j] = grid[i][j] + 1;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 1; l <= k; l++) {\n                if (i - 1 >= 0 && dp[i - 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i - 1][j];\n                }\n                if (j - 1 >= 0 && dp[i][j - 1] < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1];\n                }\n                if (i + 1 < n && j + 1 < m && dp[i + 1][j + 1] < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j + 1];\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[i + j * n] = grid[i][j];\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    long[] lst_tmp = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            lst[0] = grid[i][j];\n            lst_tmp[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst_tmp[k - 1], grid[i][j] + lst_tmp[k]));\n                lst_tmp[k] = lst[k];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < n; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < m; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    \n    long[] lst = new long[k+1];\n    \n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            if(i == 0 && j == 0)\n            {\n                lst[0] = grid[i][j];\n            }\n            else if(i == 0)\n            {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            }\n            else if(j == 0)\n            {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            }\n            else\n            {\n                lst[0] = Math.min(lst[0], grid[i][j]);\n            }\n        }\n    }\n    \n    for(int i = 1; i < k+1; i++)\n    {\n        for(int j = 0; j < N; j++)\n        {\n            for(int k = 0; k < M; k++)\n            {\n                if(i == 0 && j == 0 && k == 0)\n                {\n                    continue;\n                }\n                else if(i == 0 && j == 0)\n                {\n                    lst[i] = Math.min(lst[i], grid[j][k]);\n                }\n                else if(i == 0 && k == 0)\n                {\n                    lst[i] = Math.min(lst[i], grid[j][k]);\n                }\n                else if(j == 0 && k == 0)\n                {\n                    lst[i] = Math.min(lst[i], grid[j][k]);\n                }\n                else\n                {\n                    lst[i] = Math.min(lst[i], grid[j][k]);\n                }\n            }\n        }\n    }\n    \n    return lst;\n}\n",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    long[] dp = new long[N*M];\n    for(int i = 0; i < N*M; i++)\n        dp[i] = grid[i/M][i%M];\n    for(int i = 1; i <= k; i++)\n        lst[i] = dp[0];\n    for(int i = 1; i < N*M; i++)\n    {\n        for(int j = 1; j <= k; j++)\n        {\n            if(i-1 >= 0 && dp[i-1] < dp[i])\n                lst[j] = Math.min(lst[j], dp[i-1]);\n            if(i+1 < N*M && dp[i+1] < dp[i])\n                lst[j] = Math.min(lst[j], dp[i+1]);\n            if(j-1 >= 0 && dp[i-1] < dp[i])\n                lst[j] = Math.min(lst[j], dp[i-1]);\n            if(j+1 < N*M && dp[i+1] < dp[i])\n                lst[j] = Math.min(lst[j], dp[i+1]);\n            if(i-1 >= 0 && j-1 >= 0 && dp[i-1] < dp[i] && dp[i-1] < dp[i+1])\n                lst[j] = Math.min(lst[j], dp[i-1]);\n            if(i-1 >= 0 && j+1 < N*M && dp[i-1] < dp[i] && dp[i-1] < dp[i+1])\n                lst[j] = Math.min(lst[j], dp[i-1]);\n            if(i+1 < N*M && j-1 >= 0 && dp[i+1] < dp[i]",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < M; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i <= k; i++) {\n        lst[i] = grid[0][0];\n    }\n    for (int i = 1; i < N; i++) {\n        for (int j = 1; j < N; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (i - 1 >= 0 && grid[i - 1][j] < lst[k]) {\n                    lst[k] = grid[i - 1][j];\n                }\n                if (j - 1 >= 0 && grid[i][j - 1] < lst[k]) {\n                    lst[k] = grid[i][j - 1];\n                }\n                if (i + 1 < N && grid[i + 1][j] < lst[k]) {\n                    lst[k] = grid[i + 1][j];\n                }\n                if (j + 1 < N && grid[i][j + 1] < lst[k]) {\n                    lst[k] = grid[i][j + 1];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            lst[0] = grid[i][j];\n            for(int k = 1; k <= k; k++)\n            {\n                lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j] + lst[k-1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k+1];\n    long[] lst_prev = new long[k+1];\n    for(int i=0; i<k+1; i++)\n        lst[i] = grid[0][0];\n    for(int i=0; i<grid.length; i++)\n        for(int j=0; j<grid[i].length; j++)\n            if(grid[i][j] > lst[0])\n                lst[0] = grid[i][j];\n    for(int i=0; i<grid.length; i++)\n        for(int j=0; j<grid[i].length; j++)\n            if(grid[i][j] > lst[0])\n                lst_prev[0] = grid[i][j];\n    for(int i=1; i<k+1; i++)\n    {\n        for(int j=0; j<grid.length; j++)\n            for(int k=0; k<grid[j].length; k++)\n                if(grid[j][k] > lst[i])\n                {\n                    lst[i] = grid[j][k];\n                    lst_prev[i] = lst_prev[i-1];\n                }\n                else if(grid[j][k] > lst_prev[i])\n                    lst_prev[i] = grid[j][k];\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[][] dp = new long[N][M];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k];\n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    \n    return ans;\n}",
    "{\n    int N = grid.length;\n    long[][] dp = new long[N][N];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k + 1];\n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < N; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        ans[dp[i][j] - 1] = Math.min(ans[dp[i][j] - 1], grid[i + di][j + dj]);\n    \n    return ans;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    \n    long[] lst = new long[k+1];\n    \n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            if(grid[i][j] == 1)\n            {\n                lst[0] = grid[i][j];\n                for(int k = 1; k <= k; k++)\n                {\n                    lst[k] = Math.min(lst[k-1], Math.min(lst[k], grid[i][j-1]));\n                    lst[k] = Math.min(lst[k], grid[i-1][j]);\n                    lst[k] = Math.min(lst[k], grid[i][j+1]);\n                    lst[k] = Math.min(lst[k], grid[i+1][j]);\n                }\n            }\n        }\n    }\n    \n    return lst;\n}",
    "{\n    int N = grid.length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                for (int k = 1; k <= k; k++) {\n                    lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = lst[i-1] + grid[0][0];\n        for (int j = 1; j < N; j++) {\n            lst[i] = Math.min(lst[i], lst[i-1] + grid[j][0]);\n            lst[i] = Math.min(lst[i], lst[i-1] + grid[j][M-1]);\n            for (int m = 1; m < M-1; m++) {\n                lst[i] = Math.min(lst[i], lst[i-1] + grid[j][m]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i <= k; i++)\n        lst[i] = grid[0][0];\n    for (int i = 1; i < N; i++)\n        for (int j = 1; j < M; j++)\n            lst[0] = Math.min(lst[0], grid[i][j]);\n    for (int i = 1; i <= k; i++)\n        for (int j = 1; j < M; j++)\n            for (int l = 1; l < N; l++)\n                lst[i] = Math.min(lst[i], grid[l][j] + lst[i - 1]);\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    \n    long[][] dp = new long[N][M];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            dp[i][j] = grid[i][j];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    long[] ans = new long[k];\n    \n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    \n    for(int i = 0; i < N; i++)\n        for(int j = 0; j < M; j++)\n            for(int di = -1; di <= 1; di++)\n                for(int dj = -1; dj <= 1; dj++)\n                    if(di != 0 || dj != 0)\n                        dp[i][j] = Math.min(dp[i][j], dp[i + di][j + dj] + 1);\n    \n    for(int i = 0; i < k; i++)\n        ans[i] = dp[0][0];\n    \n    return ans;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= i; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n            for (int k = 1; k <= j; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 1) {\n                lst[0] = grid[i][j];\n                dfs(grid, i, j, lst, 1);\n            }\n        }\n    }\n    \n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            if (grid[j][0] < lst[i - 1]) {\n                lst[i] = grid[j][0];\n            }\n        }\n        for (int j = 1; j < M; j++) {\n            if (grid[0][j] < lst[i - 1]) {\n                lst[i] = grid[0][j];\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    lst[0] = grid[0][0];\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][i];\n    }\n    for (int i = 1; i < grid.length; i++) {\n        for (int j = 1; j < grid[i].length; j++) {\n            if (grid[i][j] < lst[0]) {\n                lst[0] = grid[i][j];\n            }\n            for (int k = 1; k <= k; k++) {\n                if (grid[i][j] < lst[k]) {\n                    lst[k] = grid[i][j];\n                }\n                if (grid[i][j] < lst[k - 1]) {\n                    lst[k - 1] = grid[i][j];\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    long[] lst_grid = new long[N*M];\n    for(int i = 0; i < N; i++)\n    {\n        for(int j = 0; j < M; j++)\n        {\n            lst_grid[i*M+j] = grid[i][j];\n        }\n    }\n    for(int i = 1; i <= k; i++)\n    {\n        lst[i] = lst_grid[0];\n        for(int j = 1; j < N*M; j++)\n        {\n            if(lst_grid[j] < lst_grid[j-1])\n            {\n                lst[i] = Math.min(lst[i], lst_grid[j]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int n = grid.length;\n    int m = grid[0].length;\n    long[] lst = new long[k + 1];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            lst[0] = grid[i][j];\n            for (int k = 1; k <= k; k++) {\n                lst[k] = Math.min(lst[k - 1], Math.min(lst[k], grid[i][j] + lst[k - 1]));\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    long[] lst = new long[k + 1];\n    long[] lst_prev = new long[k + 1];\n    lst_prev[0] = 0;\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst_prev[i] = lst[i - 1];\n        lst[i] = lst_prev[i - 1] + grid[lst_prev[i - 1]][lst_prev[i - 1]];\n    }\n    for (int i = 0; i < grid.length; i++) {\n        for (int j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] == lst[k]) {\n                for (int kk = k; kk >= 1; kk--) {\n                    if (lst[kk] == lst[kk - 1]) {\n                        lst[kk] = lst[kk - 1] + grid[i][j];\n                    }\n                }\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    lst[0] = grid[0][0];\n    for(int i = 1; i <= k; i++)\n        lst[i] = lst[i-1] + grid[0][i];\n    for(int i = 1; i < N; i++)\n    {\n        for(int j = 1; j < M; j++)\n        {\n            lst[0] += grid[i][j];\n            for(int k = 1; k <= k; k++)\n            {\n                lst[k] = Math.min(lst[k], lst[k-1] + grid[i][j]);\n            }\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k + 1];\n    lst[0] = 0;\n    for (int i = 1; i <= k; i++) {\n        lst[i] = grid[0][0];\n        for (int j = 1; j < N; j++) {\n            lst[i] = Math.min(lst[i], grid[j][0] + grid[j][1]);\n        }\n        for (int j = 1; j < M; j++) {\n            lst[i] = Math.min(lst[i], grid[0][j] + grid[1][j]);\n        }\n    }\n    return lst;\n}",
    "{\n    int N = grid.length;\n    int M = grid[0].length;\n    long[] lst = new long[k+1];\n    long[] lst_tmp = new long[k+1];\n    long[] lst_tmp2 = new long[k+1];\n    long[] lst_tmp3 = new long[k+1];\n    long[] lst_tmp4 = new long[k+1];\n    long[] lst_tmp5 = new long[k+1];\n    long[] lst_tmp6 = new long[k+1];\n    long[] lst_tmp7 = new long[k+1];\n    long[] lst_tmp8 = new long[k+1];\n    long[] lst_tmp9 = new long[k+1];\n    long[] lst_tmp10 = new long[k+1];\n    long[] lst_tmp11 = new long[k+1];\n    long[] lst_tmp12 = new long[k+1];\n    long[] lst_tmp13 = new long[k+1];\n    long[] lst_tmp14 = new long[k+1];\n    long[] lst_tmp15 = new long[k+1];\n    long[] lst_tmp16 = new long[k+1];\n    long[] lst_tmp17 = new long[k+1];\n    long[] lst_tmp18 = new long[k+1];\n    long[] lst_tmp19 = new long[k+1];\n    long[] lst_tmp20 = new long[k+1];\n    long[] lst_tmp21 = new long[k+1];\n    long[] lst_tmp22 = new long[k+1];\n    long[] lst_tmp23 = new long[k+1];\n    long[] lst_tmp24 = new long[k+1];\n    long[] lst_tmp25 = new long[k+1];\n    long[] lst_tmp26 = new long[k+1];\n    long[] lst_tmp27 = new long[k+1];\n    long[] lst_tmp28 = new long[k+1];\n    "
  ],
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ]
}