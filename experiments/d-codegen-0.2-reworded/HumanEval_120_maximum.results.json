{
  "name": "HumanEval_120_maximum",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n",
  "tests": "unittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] maxCount = new long[k];\n    long[] minCount = new long[k];\n    long[] maxMinCount = new long[k];\n    long[] maxMinCountCount = new long[k];\n    long[] maxMinCountCountCount = new long[k];\n    long[] maxMinCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCountCount = new long[k];\n    long[] maxMinCountCountCountCountCountCountCountCountCountCount\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp4o859mts.d(58): Error: semicolon expected, not `unittest`\n/tmp/tmp4o859mts.d(58): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4o859mts.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 1;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 2;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 3;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 4;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 5;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 6;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 7;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 8;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 9;\n        }\n        else if(arr[i] > max[max_index])\n        \nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpo4biv_65.d(90): Error: found `unittest` instead of statement\n/tmp/tmpo4biv_65.d(106): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo4biv_65.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    for (i = 0; i < arr.length; i++) {\n        if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if (arr[i] > max[max_index]) {\n            max_index = max_index + 1;\n        }\n    }\n    for (i = 0; i < k; i++) {\n        result[i] = max[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpipgjtmxg.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428ae5]\n??:? void tmpipgjtmxg.__unittest_L50_C1() [0x4280db]\n??:? void tmpipgjtmxg.__modtest() [0x428864]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbc3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba56]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ce1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431190]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c6d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba2d]\n??:? runModuleUnitTests [0x42c999]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fa8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr.length == 0) return new long[0];\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    for (int i = 0; i < k; i++) max[i] = arr[0];\n    for (int i = 0; i < arr.length; i++) {\n        for (int j = 0; j < k; j++) {\n            if (arr[i] > max[j]) {\n                max[j] = arr[i];\n            }\n        }\n    }\n    for (int i = 0; i < k; i++) ans[i] = max[i];\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp3sztm0ch.d(49): unittest failure\n----------------\n??:? _d_unittestp [0x428b15]\n??:? void tmp3sztm0ch.__unittest_L45_C1() [0x42810f]\n??:? void tmp3sztm0ch.__modtest() [0x428898]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fd8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] index = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    long[] count_index = new long[k];\n    long[] index_max = new long[k];\n    long[] index_min = new long[k];\n    long[] count_index_max = new long[k];\n    long[] count_index_min = new long[k];\n    long[] max_index_max = new long[k];\n    long[] max_index_min = new long[k];\n    long[] min_index_max = new long[k];\n    long[] min_index_min = new long[k];\n    long[] count_index_max_min = new long[k];\n    long[] count_index_min_max = new long[k];\n    long[] max_index_max_min = new long[k];\n    long[] max_index_min_max = new long[k];\n    long[] min_index_max_min = new long[k];\n    long[] min_index_min_max = new long[k];\n    long[] count_index_max_min_max = new long[k];\n    long[] count_index_min_max_min = new long[k];\n    long[] max_index_max_min_min = new long[k];\n    long[] max_index_min_max_min = new long[k];\n    long[] min_index_max_min_min = new long[k];\n    long[] min_index_min_max_min = new long[k];\n    long[] count_index_max_min_min_min = new long[k];\n    long[] count_index_min_max_min_min = new long[k];\n    long[] max_index_max_min_min_min = new long[k];\n    long[] max_index_min_max\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmplf5qkbvg.d(64): Error: semicolon expected, not `unittest`\n/tmp/tmplf5qkbvg.d(64): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplf5qkbvg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    int i = 0;\n    int j = 0;\n    int kk = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[j])\n        {\n            max[j] = arr[i];\n        }\n        if(arr[i] < min[j])\n        {\n            min[j] = arr[i];\n        }\n        if(arr[i] > max[kk])\n        {\n            max[kk] = arr[i];\n        }\n        if(arr[i] < min[kk])\n        {\n            min[kk] = arr[i];\n        }\n        if(j < kk)\n        {\n            tmp[j] = arr[i];\n            j++;\n        }\n        if(kk < j)\n        {\n            tmp[kk] = arr[i];\n            kk++;\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        ans[i] = max[i];\n    }\n    for(i = 0; i < k; i++)\n    {\n        ans[i] = tmp[i];\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1ft7p7_9.d(81): unittest failure\n----------------\n??:? _d_unittestp [0x428dcd]\n??:? void tmp1ft7p7_9.__unittest_L77_C1() [0x4283c3]\n??:? void tmp1ft7p7_9.__modtest() [0x428b4c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ceab]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd3e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430fc9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431478]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430f55]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd15]\n??:? runModuleUnitTests [0x42cc81]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429290]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmprt4ktbr_.d(74): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprt4ktbr_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 1;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 2;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 3;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 4;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 5;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 6;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 7;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 8;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 9;\n        }\n        else if(arr[i] > max[max_index])\n        \nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpo4biv_65.d(90): Error: found `unittest` instead of statement\n/tmp/tmpo4biv_65.d(106): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo4biv_65.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    int i = 0;\n    int j = 0;\n    int kk = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            ans[kk] = arr[i];\n            i++;\n        }\n        else\n        {\n            ans[kk] = arr[j];\n            j++;\n        }\n        kk++;\n    }\n    while(i < arr.length)\n    {\n        ans[kk] = arr[i];\n        i++;\n        kk++;\n    }\n    while(j < k)\n    {\n        ans[kk] = arr[j];\n        j++;\n        kk++;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmppq3v5nfl.d(44): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmppq3v5nfl.maximum(long[], long) [0x427f31]\n??:? void tmppq3v5nfl.__unittest_L63_C1() [0x42809a]\n??:? void tmppq3v5nfl.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int max = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n            index = i;\n        }\n    }\n    result[0] = arr[index];\n    temp[0] = arr[index];\n    for (int i = 1; i < k; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n            index = i;\n        }\n        temp[i] = arr[i];\n    }\n    for (int i = 0; i < k; i++) {\n        result[i] = temp[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpjai0snei.d(37): Error: variable `i` is shadowing variable `tmpjai0snei.maximum.i`\n/tmp/tmpjai0snei.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmpjai0snei.d(45): Error: variable `i` is shadowing variable `tmpjai0snei.maximum.i`\n/tmp/tmpjai0snei.d(47): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmpjai0snei.d(52): Error: variable `i` is shadowing variable `tmpjai0snei.maximum.i`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjai0snei.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmppssx254m.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppssx254m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int maxIndex = 0;\n    int minIndex = 0;\n    long maxVal = 0;\n    long minVal = 0;\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > maxVal)\n        {\n            maxVal = arr[i];\n            maxIndex = i;\n        }\n        if(arr[i] < minVal)\n        {\n            minVal = arr[i];\n            minIndex = i;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        max[i] = maxVal;\n        min[i] = minVal;\n        temp[i] = 0;\n    }\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(i == maxIndex)\n        {\n            temp[index] = max[index];\n            index++;\n        }\n        else if(i == minIndex)\n        {\n            temp[index] = min[index];\n            index++;\n        }\n        else\n        {\n            temp[index] = arr[i];\n            index++;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        result[i] = temp[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz9ezgwas.d(94): unittest failure\n----------------\n??:? _d_unittestp [0x428cd5]\n??:? void tmpz9ezgwas.__unittest_L90_C1() [0x4282cf]\n??:? void tmpz9ezgwas.__modtest() [0x428a58]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdb3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc46]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ed1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431380]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e5d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc1d]\n??:? runModuleUnitTests [0x42cb89]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429198]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    for(; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            j = i;\n        }\n    }\n    for(int k = 0; k < k; k++)\n    {\n        result[k] = arr[j];\n        j = (j + 1) % arr.length;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmps6sibgr3.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmps6sibgr3.d(43): Error: variable `k` is shadowing variable `tmps6sibgr3.maximum.k`\n/tmp/tmps6sibgr3.d(46): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6sibgr3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0c2bax3q.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428d5d]\n??:? void tmp0c2bax3q.__unittest_L72_C1() [0x428353]\n??:? void tmp0c2bax3q.__modtest() [0x428adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca5]\n??:? runModuleUnitTests [0x42cc11]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429220]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    int i = 0;\n    int j = 0;\n    int kk = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[j])\n        {\n            max[j] = arr[i];\n        }\n        if(arr[i] < min[j])\n        {\n            min[j] = arr[i];\n        }\n        if(arr[i] > max[kk])\n        {\n            max[kk] = arr[i];\n        }\n        if(arr[i] < min[kk])\n        {\n            min[kk] = arr[i];\n        }\n        if(arr[i] > max[tmp[kk]])\n        {\n            max[tmp[kk]] = arr[i];\n        }\n        if(arr[i] < min[tmp[kk]])\n        {\n            min[tmp[kk]] = arr[i];\n        }\n        if(kk == 0)\n        {\n            kk = j;\n        }\n        if(j == k - 1)\n        {\n            kk = tmp[kk];\n        }\n        if(tmp[kk] == k - 1)\n        {\n            kk = j;\n        }\n        if(j == k - 1)\n        {\n            kk = tmp[kk];\n        }\n        if(tmp[kk] == k - 1)\n        {\n            kk = j;\n        }\n        if(j == k - 1)\n        {\n            kk = tmp[kk];\n        }\n        if(tmp[kk] == k - 1)\n        {\n            kk = j;\n        }\n        if(j == k - 1)\n        {\n            kk = tmp[kk];\n        }\n        if(tmp[kk] == k - 1)\n        {\n            kk = j;\n        }\n        if(j == k - 1)\n        {\n            kk = tmp[kk\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0pucmnz_.d(103): Error: found `unittest` when expecting `,`\n/tmp/tmp0pucmnz_.d(119): Error: found `void` when expecting `,`\n/tmp/tmp0pucmnz_.d(119): Error: found `{` when expecting `,`\n/tmp/tmp0pucmnz_.d(119): Error: expression expected, not `}`\n/tmp/tmp0pucmnz_.d(119): Error: found `End of File` when expecting `,`\n/tmp/tmp0pucmnz_.d(119): Error: found `End of File` when expecting `]`\n/tmp/tmp0pucmnz_.d(119): Error: found `End of File` when expecting `;` following statement\n/tmp/tmp0pucmnz_.d(119): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0pucmnz_.d(119): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp0pucmnz_.d(119): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0pucmnz_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    if (k == 0) return result;\n    \n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for (int i = 0; i < k; i++) {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for (int i = 1; i < arr.length; i++) {\n        if (arr[i] > max[0]) {\n            max[0] = arr[i];\n        }\n        if (arr[i] < min[0]) {\n            min[0] = arr[i];\n        }\n        for (int j = 1; j < k; j++) {\n            if (arr[i] > max[j]) {\n                max[j] = arr[i];\n            }\n            if (arr[i] < min[j]) {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < k; i++) {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpflz1hixp.d(69): unittest failure\n----------------\n??:? _d_unittestp [0x428d65]\n??:? void tmpflz1hixp.__unittest_L65_C1() [0x42835f]\n??:? void tmpflz1hixp.__modtest() [0x428ae8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce43]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcd6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f61]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431410]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430eed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bcad]\n??:? runModuleUnitTests [0x42cc19]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429228]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < arr.length && count < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            result[count] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while(i < arr.length)\n    {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while(j < arr.length)\n    {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp46i9a0dp.d(51): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp46i9a0dp.maximum(long[], long) [0x427f97]\n??:? void tmp46i9a0dp.__unittest_L63_C1() [0x42809a]\n??:? void tmp46i9a0dp.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr == null || arr.length == 0 || k < 1) return new long[0];\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpu7s2y13g.d(73): Error: found `unittest` when expecting `]`\n/tmp/tmpu7s2y13g.d(74): Error: semicolon expected, not `{`\n/tmp/tmpu7s2y13g.d(89): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu7s2y13g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    int[] index = new int[k];\n    int[] count = new int[k];\n    int i, j, max_index, min_index;\n    \n    for (i = 0; i < k; i++) {\n        max[i] = arr[0];\n        min[i] = arr[0];\n        index[i] = 0;\n        count[i] = 1;\n    }\n    \n    for (i = 1; i < arr.length; i++) {\n        for (j = 0; j < k; j++) {\n            if (arr[i] > max[j]) {\n                max[j] = arr[i];\n                max_index = j;\n            }\n            if (arr[i] < min[j]) {\n                min[j] = arr[i];\n                min_index = j;\n            }\n        }\n        if (max_index != min_index) {\n            count[max_index]++;\n            count[min_index]--;\n            index[min_index] = i;\n            index[max_index] = i;\n        }\n    }\n    \n    for (i = 0; i < k; i++) {\n        result[i] = max[i];\n        if (count[i] > 0) {\n            result[i] = arr[index[i]];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpfjgzoj0p.d(79): unittest failure\n----------------\n??:? _d_unittestp [0x4290d5]\n??:? void tmpfjgzoj0p.__unittest_L73_C1() [0x428833]\n??:? void tmpfjgzoj0p.__modtest() [0x428e54]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d397]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c22a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4314b5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431964]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431441]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c201]\n??:? runModuleUnitTests [0x42d16d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429598]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    long max_value = 0;\n    long min_value = 0;\n    long max_index_value = 0;\n    long min_index_value = 0;\n    long temp_value = 0;\n    long temp_index_value = 0;\n    long i = 0;\n    long j = 0;\n    long k_index = 0;\n    long k_value = 0;\n    long index = 0;\n    long value = 0;\n    long index_value = 0;\n    long max_index_value_index = 0;\n    long min_index_value_index = 0;\n    long max_index_value_value = 0;\n    long min_index_value_value = 0;\n    long max_index_value_index_value = 0;\n    long min_index_value_index_value = 0;\n    long max_index_value_index_value_index = 0;\n    long min_index_value_index_value_index = 0;\n    long max_index_value_index_value_value = 0;\n    long min_index_value_index_value_value = 0;\n    long max_index_value_index_value_index_value = 0;\n    long min_index_value_index_value_index_value = 0;\n    long max_index_value_index_value_index_value_index = 0;\n    long min_index_value_index_value_index_value_index = 0;\n    long max_index_value_index_value_index_value_value = 0;\n    long min_index_value_index_value_index_value_value = 0;\n    long max_index_value_index_value_index_value_index_value = 0;\n    long min_index_value_index_value_index_value_index_value = 0;\n    long max_index_value\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpfgnepl13.d(69): Error: semicolon expected, not `unittest`\n/tmp/tmpfgnepl13.d(69): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfgnepl13.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    long max = arr[0];\n    long max_index = 0;\n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            max_index = i;\n        }\n    }\n    for(int i = 0; i < k; i++)\n    {\n        temp[i] = max;\n    }\n    for(int i = 0; i < max_index; i++)\n    {\n        temp[i] = arr[i];\n    }\n    for(int i = max_index; i < k; i++)\n    {\n        temp[i] = arr[i];\n    }\n    for(int i = 0; i < k; i++)\n    {\n        result[i] = temp[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp47r2_8ga.d(51): Error: cannot implicitly convert expression `max_index` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47r2_8ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < arr.length && count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while (i < arr.length) {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while (j < arr.length) {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_6fxmmdy.d(46): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp_6fxmmdy.maximum(long[], long) [0x427f97]\n??:? void tmp_6fxmmdy.__unittest_L57_C1() [0x42809a]\n??:? void tmp_6fxmmdy.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr.length == 0) return new long[0];\n    if (arr.length == 1) return new long[]{arr[0]};\n    \n    long[] ans = new long[k];\n    long[] max = new long[arr.length];\n    for (int i = 0; i < arr.length; i++) max[i] = arr[i];\n    \n    for (int i = 0; i < k; i++)\n    {\n        long max_index = 0;\n        for (int j = 0; j < arr.length; j++)\n        {\n            if (max[j] > max_index) max_index = max[j];\n        }\n        ans[i] = max_index;\n        for (int j = 0; j < arr.length; j++)\n        {\n            if (max[j] == max_index) max[j] = -1;\n        }\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpknvfbk8v.d(32): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpknvfbk8v.d(32): Error: found `}` when expecting `;` following statement\n/tmp/tmpknvfbk8v.d(32): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpknvfbk8v.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    if (k == 0) return result;\n    \n    int left = 0;\n    int right = arr.length - 1;\n    int mid = (left + right) / 2;\n    \n    while (left <= right) {\n        if (arr[mid] > arr[right]) {\n            left = mid + 1;\n        } else if (arr[mid] < arr[right]) {\n            right = mid - 1;\n        } else {\n            result[right] = arr[right];\n            right--;\n        }\n        mid = (left + right) / 2;\n    }\n    \n    for (int i = 0; i < k; i++) {\n        result[i] = arr[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpbsi20j72.d(35): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbsi20j72.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp28hb4gym.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp28hb4gym.d(75): Error: semicolon expected, not `{`\n/tmp/tmp28hb4gym.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28hb4gym.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < arr.length && count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while (i < arr.length) {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while (j < arr.length) {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_6fxmmdy.d(46): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp_6fxmmdy.maximum(long[], long) [0x427f97]\n??:? void tmp_6fxmmdy.__unittest_L57_C1() [0x42809a]\n??:? void tmp_6fxmmdy.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = -1;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpf9y69fx7.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf9y69fx7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp28hb4gym.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp28hb4gym.d(75): Error: semicolon expected, not `{`\n/tmp/tmp28hb4gym.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28hb4gym.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpskki80ix.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpskki80ix.d(75): Error: semicolon expected, not `{`\n/tmp/tmpskki80ix.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskki80ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpskki80ix.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpskki80ix.d(75): Error: semicolon expected, not `{`\n/tmp/tmpskki80ix.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskki80ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpskki80ix.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpskki80ix.d(75): Error: semicolon expected, not `{`\n/tmp/tmpskki80ix.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskki80ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpdqqs5c4x.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqqs5c4x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int maxIndex = 0;\n    int minIndex = 0;\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = i;\n        }\n        if(arr[i] < min[minIndex])\n        {\n            min[minIndex] = arr[i];\n            minIndex = i;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        if(i == maxIndex)\n        {\n            res[i] = max[i];\n        }\n        else if(i == minIndex)\n        {\n            res[i] = min[i];\n        }\n        else\n        {\n            res[i] = arr[i];\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6u78prix.d(77): unittest failure\n----------------\n??:? _d_unittestp [0x428c2d]\n??:? void tmp6u78prix.__unittest_L73_C1() [0x428227]\n??:? void tmp6u78prix.__modtest() [0x4289b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cd0b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb9e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e29]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312d8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430db5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb75]\n??:? runModuleUnitTests [0x42cae1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290f0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpkbmv_pzd.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpkbmv_pzd.d(75): Error: semicolon expected, not `{`\n/tmp/tmpkbmv_pzd.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkbmv_pzd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr.length == 0) return new long[0];\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[max]) max = i;\n        if (arr[i] < arr[j]) {\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[max];\n            max++;\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = arr[max];\n        max++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpt28vycso.d(48): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c36]\n??:? long[] tmpt28vycso.maximum(long[], long) [0x428006]\n??:? void tmpt28vycso.__unittest_L59_C1() [0x42810a]\n??:? void tmpt28vycso.__modtest() [0x428904]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc63]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42baf6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d81]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431230]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430d0d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bacd]\n??:? runModuleUnitTests [0x42ca39]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int maxIndex = 0;\n    int minIndex = 0;\n    int tempIndex = 0;\n    int maxCount = 0;\n    int minCount = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > 0)\n        {\n            temp[tempIndex] = arr[i];\n            tempIndex++;\n        }\n        else\n        {\n            if(minCount == 0)\n            {\n                min[minIndex] = arr[i];\n                minIndex++;\n            }\n            else\n            {\n                if(arr[i] < min[minIndex])\n                {\n                    min[minIndex] = arr[i];\n                    minIndex++;\n                }\n            }\n            minCount++;\n        }\n    }\n    for(i = 0; i < min.length; i++)\n    {\n        if(min[i] > 0)\n        {\n            temp[tempIndex] = min[i];\n            tempIndex++;\n        }\n    }\n    for(i = 0; i < temp.length; i++)\n    {\n        if(temp[i] > 0)\n        {\n            max[maxIndex] = temp[i];\n            maxIndex++;\n        }\n    }\n    for(i = 0; i < max.length; i++)\n    {\n        if(max[i] > 0)\n        {\n            maxCount++;\n        }\n    }\n    if(maxCount == 0)\n    {\n        result[0] = 0;\n        return result;\n    }\n    for(i = 0; i < max.length; i++)\n    {\n        if(max[i] > 0)\n        {\n            result[index] = max[i];\n            index++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp1dgmn0g2.d(110): unittest failure\n----------------\n??:? _d_unittestp [0x428d95]\n??:? void tmp1dgmn0g2.__unittest_L106_C1() [0x42838b]\n??:? void tmp1dgmn0g2.__modtest() [0x428b14]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce73]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd06]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f91]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431440]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430f1d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bcdd]\n??:? runModuleUnitTests [0x42cc49]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429258]\n??:? void rt.dmain2._d",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(i < arr.length && count < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            result[count] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while(i < arr.length)\n    {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while(j < arr.length)\n    {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp46i9a0dp.d(51): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp46i9a0dp.maximum(long[], long) [0x427f97]\n??:? void tmp46i9a0dp.__unittest_L63_C1() [0x42809a]\n??:? void tmp46i9a0dp.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgz7g3x6v.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428a3d]\n??:? void tmpgz7g3x6v.__unittest_L47_C1() [0x428037]\n??:? void tmpgz7g3x6v.__modtest() [0x4287c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b985]\n??:? runModuleUnitTests [0x42c8f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr == null || arr.length == 0 || k < 1)\n        return new long[0];\n    long[] res = new long[k];\n    int i = 0, j = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            res[j] = arr[i];\n            i++;\n        } else {\n            res[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        res[j++] = arr[i++];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp4uccnby9.d(45): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bbe]\n??:? long[] tmp4uccnby9.maximum(long[], long) [0x427ff2]\n??:? void tmp4uccnby9.__unittest_L49_C1() [0x428092]\n??:? void tmp4uccnby9.__modtest() [0x42888c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbeb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba7e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d09]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311b8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c95]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba55]\n??:? runModuleUnitTests [0x42c9c1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int k1 = 0;\n    int k2 = 0;\n    int k3 = 0;\n    int k4 = 0;\n    int k5 = 0;\n    int k6 = 0;\n    int k7 = 0;\n    int k8 = 0;\n    int k9 = 0;\n    int k10 = 0;\n    int k11 = 0;\n    int k12 = 0;\n    int k13 = 0;\n    int k14 = 0;\n    int k15 = 0;\n    int k16 = 0;\n    int k17 = 0;\n    int k18 = 0;\n    int k19 = 0;\n    int k20 = 0;\n    int k21 = 0;\n    int k22 = 0;\n    int k23 = 0;\n    int k24 = 0;\n    int k25 = 0;\n    int k26 = 0;\n    int k27 = 0;\n    int k28 = 0;\n    int k29 = 0;\n    int k30 = 0;\n    int k31 = 0;\n    int k32 = 0;\n    int k33 = 0;\n    int k34 = 0;\n    int k35 = 0;\n    int k36 = 0;\n    int k37 = 0;\n    int k38 = 0;\n    int k39 = 0;\n    int k40 = 0;\n    int k41 = 0;\n    int k42 = 0;\n    int k43 = 0;\n    int k44 = 0;\n    int k45 = 0;\n    int k46 = 0;\n    int k47 = 0;\n    int k48 = 0;\n    int k49 = 0;\n    int k50 = 0;\n    int k51 = 0;\n    int k52 = 0;\n    int k53 = 0;\n    int k54 = 0;\n    int k55 = 0;\n    int k56 = 0;\n    int k57\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0o585la7.d(94): Error: semicolon expected, not `unittest`\n/tmp/tmp0o585la7.d(94): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0o585la7.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpdqqs5c4x.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqqs5c4x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmps3jttzr1.d(77): unittest failure\n----------------\n??:? _d_unittestp [0x428d6d]\n??:? void tmps3jttzr1.__unittest_L73_C1() [0x428363]\n??:? void tmps3jttzr1.__modtest() [0x428aec]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce4b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcde]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f69]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431418]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ef5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bcb5]\n??:? runModuleUnitTests [0x42cc21]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429230]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    long[] count = new long[k];\n    long[] max_count = new long[k];\n    long[] min_count = new long[k];\n    long[] max_index_count = new long[k];\n    long[] min_index_count = new long[k];\n    long[] max_index_count_temp = new long[k];\n    long[] min_index_count_temp = new long[k];\n    long[] max_index_count_temp2 = new long[k];\n    long[] min_index_count_temp2 = new long[k];\n    long[] max_index_count_temp3 = new long[k];\n    long[] min_index_count_temp3 = new long[k];\n    long[] max_index_count_temp4 = new long[k];\n    long[] min_index_count_temp4 = new long[k];\n    long[] max_index_count_temp5 = new long[k];\n    long[] min_index_count_temp5 = new long[k];\n    long[] max_index_count_temp6 = new long[k];\n    long[] min_index_count_temp6 = new long[k];\n    long[] max_index_count_temp7 = new long[k];\n    long[] min_index_count_temp7 = new long[k];\n    long[] max_index_count_temp8 = new long[k];\n    long[] min_index_count_temp8 = new long[k];\n    long[] max_index_count_temp9 = new long[k];\n    long[] min_index_count_temp9 = new long[k];\n    long[] max_index_count_temp10 = new long[k];\n    long[] min_index_count_temp10 = new long[k];\n    long[] max_index_count_temp11 = new long[\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmptj1037pn.d(63): Error: expression expected, not `unittest`\n/tmp/tmptj1037pn.d(64): Error: found `{` when expecting `]`\n/tmp/tmptj1037pn.d(65): Error: semicolon expected, not `alias`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptj1037pn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] temp = new long[k];\n    int i = 0, j = 0, kk = 0;\n    long max = arr[0];\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            kk = i;\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        temp[i] = arr[kk];\n        kk = (kk + 1) % arr.length;\n    }\n    for(i = 0; i < k; i++)\n    {\n        ans[i] = temp[i];\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpzpbkqbgt.d(46): Error: cannot implicitly convert expression `cast(ulong)(kk + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzpbkqbgt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            res[j++] = arr[i++];\n        }\n    }\n    while (i < arr.length) {\n        res[j++] = arr[i++];\n    }\n    while (j < k) {\n        res[j++] = 0;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmptj7qku8u.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptj7qku8u.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpskki80ix.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpskki80ix.d(75): Error: semicolon expected, not `{`\n/tmp/tmpskki80ix.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskki80ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    int[] count = new int[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n        count[i] = 1;\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n            count[0] = 1;\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n            count[0] = 1;\n        }\n        else\n        {\n            count[0]++;\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n                count[j] = 1;\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n                count[j] = 1;\n            }\n            else\n            {\n                count[j]++;\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        if(count[i] > 0)\n        {\n            res[i] = max[i];\n        }\n        else\n        {\n            res[i] = min[i];\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpok51iz8f.d(97): unittest failure\n----------------\n??:? _d_unittestp [0x4291ed]\n??:? void tmpok51iz8f.__unittest_L93_C1() [0x4287e7]\n??:? void tmpok51iz8f.__modtest() [0x428f70]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d4af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42c342]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4315cd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431a7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x431559]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42c319]\n??:? runModuleUnitTests [0x42d285]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4296b0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int max_index = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(max_index == k - 1)\n        {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if(arr[i] == max[max_index])\n        {\n            max_index++;\n        }\n    }\n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuw9qof8o.d(61): unittest failure\n----------------\n??:? _d_unittestp [0x428b45]\n??:? void tmpuw9qof8o.__unittest_L57_C1() [0x42813f]\n??:? void tmpuw9qof8o.__modtest() [0x4288c8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc23]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bab6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d41]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311f0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ccd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba8d]\n??:? runModuleUnitTests [0x42c9f9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429008]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < arr.length && count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while (i < arr.length) {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while (j < arr.length) {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_6fxmmdy.d(46): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp_6fxmmdy.maximum(long[], long) [0x427f97]\n??:? void tmp_6fxmmdy.__unittest_L57_C1() [0x42809a]\n??:? void tmp_6fxmmdy.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = arr[j];\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpo8_cu62c.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo8_cu62c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr == null || arr.length == 0) return new long[0];\n    if (k > arr.length) return arr;\n    if (k == 1) return new long[]{arr[0]};\n    \n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for (int i = 0; i < k; i++)\n    {\n        min[i] = arr[0];\n    }\n    \n    for (int i = 1; i < arr.length; i++)\n    {\n        if (arr[i] > min[0])\n        {\n            min[0] = arr[i];\n        }\n        else if (arr[i] < min[0])\n        {\n            for (int j = 1; j < k; j++)\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < k; i++)\n    {\n        max[i] = arr[i];\n    }\n    \n    for (int i = 1; i < arr.length; i++)\n    {\n        if (arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if (arr[i] < max[0])\n        {\n            for (int j = 1; j < k; j++)\n            {\n                max[j] = arr[i];\n            }\n        }\n    }\n    \n    return max;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpswyz3aid.d(33): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpswyz3aid.d(33): Error: found `}` when expecting `;` following statement\n/tmp/tmpswyz3aid.d(33): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpswyz3aid.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    for (i = 0; i < arr.length; i++) {\n        if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 0;\n        } else if (arr[i] > max[max_index]) {\n            max_index = (max_index + 1) % k;\n        }\n    }\n    for (i = 0; i < k; i++) {\n        result[i] = max[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpoqnicqgz.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428aed]\n??:? void tmpoqnicqgz.__unittest_L49_C1() [0x4280e3]\n??:? void tmpoqnicqgz.__modtest() [0x42886c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbcb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba5e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ce9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431198]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c75]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba35]\n??:? runModuleUnitTests [0x42c9a1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fb0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            j = i;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        temp[i] = arr[j];\n        j = (j + 1) % arr.length;\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        result[i] = temp[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp5jslmkjm.d(41): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmp5jslmkjm.d(49): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5jslmkjm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0c2bax3q.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428d5d]\n??:? void tmp0c2bax3q.__unittest_L72_C1() [0x428353]\n??:? void tmp0c2bax3q.__modtest() [0x428adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca5]\n??:? runModuleUnitTests [0x42cc11]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429220]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ret = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        for(int j = 0; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        ret[i] = max[i];\n    }\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8bmvgb0g.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x428c1d]\n??:? void tmp8bmvgb0g.__unittest_L63_C1() [0x428217]\n??:? void tmp8bmvgb0g.__modtest() [0x4289a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430da5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb65]\n??:? runModuleUnitTests [0x42cad1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            res[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        res[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        res[j] = 0;\n        j++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpzge9vuhp.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzge9vuhp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = Math.max(max, i);\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    for (int k = 0; k < result.length; k++) {\n        result[k] = result[k] + max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpm8747797.d(37): Error: undefined identifier `Math`\n/tmp/tmpm8747797.d(49): Error: variable `k` is shadowing variable `tmpm8747797.maximum.k`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm8747797.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int maxIndex = 0;\n    int minIndex = 0;\n    long maxVal = 0;\n    long minVal = 0;\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > maxVal)\n        {\n            maxVal = arr[i];\n            maxIndex = i;\n        }\n        if(arr[i] < minVal)\n        {\n            minVal = arr[i];\n            minIndex = i;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        max[i] = maxVal;\n        min[i] = minVal;\n    }\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(i == maxIndex)\n        {\n            result[index] = arr[i];\n            index++;\n        }\n        else if(i == minIndex)\n        {\n            result[index] = arr[i];\n            index++;\n        }\n        else\n        {\n            if(arr[i] > max[index])\n            {\n                max[index] = arr[i];\n            }\n            if(arr[i] < min[index])\n            {\n                min[index] = arr[i];\n            }\n            index++;\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmexgdl7r.d(94): unittest failure\n----------------\n??:? _d_unittestp [0x428cf5]\n??:? void tmpmexgdl7r.__unittest_L90_C1() [0x4282eb]\n??:? void tmpmexgdl7r.__modtest() [0x428a74]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdd3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc66]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ef1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4313a0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e7d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc3d]\n??:? runModuleUnitTests [0x42cba9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291b8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    long[] max_value = new long[k];\n    long[] min_value = new long[k];\n    long[] max_index_value = new long[k];\n    long[] min_index_value = new long[k];\n    long[] max_value_index = new long[k];\n    long[] min_value_index = new long[k];\n    long[] max_index_value_index = new long[k];\n    long[] min_index_value_index = new long[k];\n    long[] max_value_index_value = new long[k];\n    long[] min_value_index_value = new long[k];\n    long[] max_value_index_value_index = new long[k];\n    long[] min_value_index_value_index = new long[k];\n    long[] max_value_index_value_index_value = new long[k];\n    long[] min_value_index_value_index_value = new long[k];\n    long[] max_value_index_value_index_value_index = new long[k];\n    long[] min_value_index_value_index_value_index = new long[k];\n    long[] max_value_index_value_index_value_index_value = new long[k];\n    long[] min_value_index_value_index_value_index_value = new long[k];\n    long[] max_value_index_value_index_value_index_value_index = new long[k];\n    long[] min_value_index_value_index_value_index_value_index = new long[k];\n    long[] max_value_index_value_index_value_index_value_index_value = new long[k];\n    long[] min_value_index_value_index_value_index_value_index_value = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpsda2k30n.d(59): Error: found `unittest` when expecting `]`\n/tmp/tmpsda2k30n.d(60): Error: semicolon expected, not `{`\n/tmp/tmpsda2k30n.d(75): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsda2k30n.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            ans[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            ans[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        ans[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        ans[j] = -1;\n        j++;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp61o31arw.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp61o31arw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ret = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1xoj7ge2.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1xoj7ge2.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1xoj7ge2.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1xoj7ge2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < arr.length && count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while (i < arr.length) {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while (j < arr.length) {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_6fxmmdy.d(46): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp_6fxmmdy.maximum(long[], long) [0x427f97]\n??:? void tmp_6fxmmdy.__unittest_L57_C1() [0x42809a]\n??:? void tmp_6fxmmdy.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpkbmv_pzd.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpkbmv_pzd.d(75): Error: semicolon expected, not `{`\n/tmp/tmpkbmv_pzd.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkbmv_pzd.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            j = i;\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        result[i] = arr[j];\n        j = (j + 1) % arr.length;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp55m8v78d.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmp55m8v78d.d(46): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55m8v78d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    for (int i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n            j = i;\n        }\n    }\n    for (int i = 0; i < k; i++) {\n        result[i] = arr[j];\n        j = (j + 1) % arr.length;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpgpgq_hl4.d(35): Error: variable `i` is shadowing variable `tmpgpgq_hl4.maximum.i`\n/tmp/tmpgpgq_hl4.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmpgpgq_hl4.d(41): Error: variable `i` is shadowing variable `tmpgpgq_hl4.maximum.i`\n/tmp/tmpgpgq_hl4.d(43): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgpgq_hl4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    long max_val = 0;\n    long min_val = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max_val)\n        {\n            max_val = arr[i];\n        }\n        if(arr[i] < min_val)\n        {\n            min_val = arr[i];\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        max[i] = max_val;\n        min[i] = min_val;\n    }\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max_val)\n        {\n            max_val = arr[i];\n        }\n        if(arr[i] < min_val)\n        {\n            min_val = arr[i];\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        if(max[i] > min[i])\n        {\n            temp[i] = max[i];\n        }\n        else\n        {\n            temp[i] = min[i];\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        result[i] = temp[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmploxgc94g.d(37): Error: variable `k` is shadowing variable `tmploxgc94g.maximum.k`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmploxgc94g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = -1;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpx2qfyn45.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx2qfyn45.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int k1 = 0;\n    int k2 = 0;\n    int k3 = 0;\n    int k4 = 0;\n    int k5 = 0;\n    int k6 = 0;\n    int k7 = 0;\n    int k8 = 0;\n    int k9 = 0;\n    int k10 = 0;\n    int k11 = 0;\n    int k12 = 0;\n    int k13 = 0;\n    int k14 = 0;\n    int k15 = 0;\n    int k16 = 0;\n    int k17 = 0;\n    int k18 = 0;\n    int k19 = 0;\n    int k20 = 0;\n    int k21 = 0;\n    int k22 = 0;\n    int k23 = 0;\n    int k24 = 0;\n    int k25 = 0;\n    int k26 = 0;\n    int k27 = 0;\n    int k28 = 0;\n    int k29 = 0;\n    int k30 = 0;\n    int k31 = 0;\n    int k32 = 0;\n    int k33 = 0;\n    int k34 = 0;\n    int k35 = 0;\n    int k36 = 0;\n    int k37 = 0;\n    int k38 = 0;\n    int k39 = 0;\n    int k40 = 0;\n    int k41 = 0;\n    int k42 = 0;\n    int k43 = 0;\n    int k44 = 0;\n    int k45 = 0;\n    int k46 = 0;\n    int k47 = 0;\n    int k48 = 0;\n    int k49 = 0;\n    int k50 = 0;\n    int k51 = 0;\n    int k52 = 0;\n    int k53 = 0;\n    int k54 = 0;\n    int k55 = 0;\n    int k56 = 0;\n    int k57\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpt2497glk.d(94): Error: semicolon expected, not `unittest`\n/tmp/tmpt2497glk.d(94): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt2497glk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            j = i;\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        result[i] = arr[j];\n        j = (j + 1) % arr.length;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp55m8v78d.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmp55m8v78d.d(46): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55m8v78d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[max]) {\n            max = i;\n        }\n        if (arr[i] <= arr[j]) {\n            i++;\n        } else {\n            res[j++] = arr[max];\n            max = i;\n        }\n    }\n    for (; j < k; j++) {\n        res[j] = arr[max];\n        max = i;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp2r_vlfga.d(56): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmp2r_vlfga.__unittest_L52_C1() [0x4280b3]\n??:? void tmp2r_vlfga.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[max]) {\n            max = i;\n        }\n        if (arr[i] > arr[j]) {\n            res[j] = arr[i];\n            j++;\n        }\n        i++;\n    }\n    while (j < k) {\n        res[j] = arr[max];\n        j++;\n        max++;\n        if (max == arr.length) {\n            max = 0;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc009uda_.d(59): unittest failure\n----------------\n??:? _d_unittestp [0x428abd]\n??:? void tmpc009uda_.__unittest_L55_C1() [0x4280b3]\n??:? void tmpc009uda_.__modtest() [0x42883c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb9b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba2e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cb9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431168]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c45]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba05]\n??:? runModuleUnitTests [0x42c971]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f80]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int k1 = 0;\n    int k2 = 0;\n    int max_index = 0;\n    int min_index = 0;\n    int temp_index = 0;\n    long max_value = 0;\n    long min_value = 0;\n    long temp_value = 0;\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max_value)\n        {\n            max_value = arr[i];\n            max_index = i;\n        }\n        if(arr[i] < min_value)\n        {\n            min_value = arr[i];\n            min_index = i;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        max[i] = max_value;\n        min[i] = min_value;\n        temp[i] = 0;\n    }\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(i == max_index)\n        {\n            temp[k1] = max[k1] + 1;\n            k1++;\n        }\n        else if(i == min_index)\n        {\n            temp[k2] = min[k2] - 1;\n            k2++;\n        }\n        else\n        {\n            temp[k1] = arr[i];\n            k1++;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        if(temp[i] > max[i])\n        {\n            max[i] = temp[i];\n        }\n        if(temp[i] < min[i])\n        {\n            min[i] = temp[i];\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        result[i]\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp22it9hy8.d(101): Error: found `unittest` when expecting `;` following statement\n/tmp/tmp22it9hy8.d(117): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp22it9hy8.d(117): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp22it9hy8.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp28hb4gym.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp28hb4gym.d(75): Error: semicolon expected, not `{`\n/tmp/tmp28hb4gym.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28hb4gym.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        temp[i] = max[i] - min[i];\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        ans[i] = temp[i];\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpaylq5nfr.d(82): unittest failure\n----------------\n??:? _d_unittestp [0x428e1d]\n??:? void tmpaylq5nfr.__unittest_L78_C1() [0x428413]\n??:? void tmpaylq5nfr.__modtest() [0x428b9c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cefb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x431019]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4314c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430fa5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd65]\n??:? runModuleUnitTests [0x42ccd1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4292e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0c2bax3q.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428d5d]\n??:? void tmp0c2bax3q.__unittest_L72_C1() [0x428353]\n??:? void tmp0c2bax3q.__modtest() [0x428adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca5]\n??:? runModuleUnitTests [0x42cc11]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429220]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = max;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpx7idi63q.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7idi63q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    if (k == 0) return result;\n    int left = 0;\n    int right = arr.length - 1;\n    while (left <= right) {\n        if (arr[left] > arr[right]) {\n            result[left] = arr[left];\n            left++;\n        } else {\n            result[right] = arr[right];\n            right--;\n        }\n    }\n    for (int i = 0; i < k; i++) {\n        result[i] = arr[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1qgele67.d(34): Error: cannot implicitly convert expression `arr.length - 1LU` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1qgele67.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpptzn56bp.d(74): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpptzn56bp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr == null || arr.length == 0) return new long[0];\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpx9uqnfc_.d(45): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bee]\n??:? long[] tmpx9uqnfc_.maximum(long[], long) [0x427fe7]\n??:? void tmpx9uqnfc_.__unittest_L55_C1() [0x4280c6]\n??:? void tmpx9uqnfc_.__modtest() [0x4288c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42baae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430cc5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba85]\n??:? runModuleUnitTests [0x42c9f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        for(int j = 0; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf65qlv3u.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x428c1d]\n??:? void tmpf65qlv3u.__unittest_L63_C1() [0x428217]\n??:? void tmpf65qlv3u.__modtest() [0x4289a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430da5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb65]\n??:? runModuleUnitTests [0x42cad1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmppssx254m.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppssx254m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    int i = 0;\n    int j = 0;\n    int kk = 0;\n    for (i = 0; i < arr.length; i++) {\n        if (arr[i] > max[j]) {\n            max[j] = arr[i];\n        }\n        if (arr[i] < min[j]) {\n            min[j] = arr[i];\n        }\n        if (j < k - 1) {\n            if (arr[i] > max[j + 1]) {\n                max[j + 1] = arr[i];\n            }\n            if (arr[i] < min[j + 1]) {\n                min[j + 1] = arr[i];\n            }\n        }\n        if (arr[i] > max[kk]) {\n            max[kk] = arr[i];\n        }\n        if (arr[i] < min[kk]) {\n            min[kk] = arr[i];\n        }\n        if (kk < k - 1) {\n            if (arr[i] > max[kk + 1]) {\n                max[kk + 1] = arr[i];\n            }\n            if (arr[i] < min[kk + 1]) {\n                min[kk + 1] = arr[i];\n            }\n        }\n        if (arr[i] > max[0]) {\n            max[0] = arr[i];\n        }\n        if (arr[i] < min[0]) {\n            min[0] = arr[i];\n        }\n        if (i < k - 1) {\n            if (arr[i] > max[i + 1]) {\n                max[i + 1] = arr[i];\n            }\n            if (arr[i] < min[i + 1]) {\n                min[i + 1] = arr[i];\n            }\n        }\n        kk = k - 1;\n        j = k - 1;\n    }\n    for (i = 0; i < k; i++) {\n        result\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp3ai4oed5.d(85): Error: found `unittest` when expecting `;` following statement\n/tmp/tmp3ai4oed5.d(101): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp3ai4oed5.d(101): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ai4oed5.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpdqqs5c4x.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqqs5c4x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int maxIndex = 0;\n    int minIndex = 0;\n    int tempIndex = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = i;\n        }\n        if(arr[i] < min[minIndex])\n        {\n            min[minIndex] = arr[i];\n            minIndex = i;\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        if(max[i] == min[i])\n        {\n            result[i] = max[i];\n        }\n        else\n        {\n            result[i] = max[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpnc4hiuor.d(71): unittest failure\n----------------\n??:? _d_unittestp [0x428c1d]\n??:? void tmpnc4hiuor.__unittest_L67_C1() [0x428213]\n??:? void tmpnc4hiuor.__modtest() [0x42899c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430da5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb65]\n??:? runModuleUnitTests [0x42cad1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = j;\n            j++;\n        }\n        else\n        {\n            i++;\n        }\n    }\n    for(int k = 0; k < max; k++)\n    {\n        ans[k] = arr[k];\n    }\n    for(int k = max; k < k; k++)\n    {\n        ans[k] = arr[i];\n        i++;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmptnrhe1uw.d(47): Error: variable `k` is shadowing variable `tmptnrhe1uw.maximum.k`\n/tmp/tmptnrhe1uw.d(51): Error: variable `k` is shadowing variable `tmptnrhe1uw.maximum.k`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptnrhe1uw.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmprt4ktbr_.d(74): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprt4ktbr_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = Math.max(max, j);\n            result[i] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[i] = arr[i];\n        i++;\n    }\n    while (j < k) {\n        result[j] = arr[j];\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpckmhr1yh.d(37): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpckmhr1yh.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n        max_index[i] = 0;\n        min_index[i] = 0;\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[max_index[0]])\n        {\n            max[max_index[0]] = arr[i];\n            max_index[0] = i;\n        }\n        else if(arr[i] < min[min_index[0]])\n        {\n            min[min_index[0]] = arr[i];\n            min_index[0] = i;\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[max_index[j]])\n            {\n                max[max_index[j]] = arr[i];\n                max_index[j] = i;\n            }\n            else if(arr[i] < min[min_index[j]])\n            {\n                min[min_index[j]] = arr[i];\n                min_index[j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpy2m8un3q.d(85): unittest failure\n----------------\n??:? _d_unittestp [0x428fc5]\n??:? void tmpy2m8un3q.__unittest_L81_C1() [0x4285bf]\n??:? void tmpy2m8un3q.__modtest() [0x428d48]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42d0a3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bf36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4311c1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431670]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43114d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bf0d]\n??:? runModuleUnitTests [0x42ce79]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429488]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] temp = new long[k];\n    int i = 0, j = 0;\n    long max = arr[0];\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            j = i;\n        }\n    }\n    result[0] = max;\n    for(i = 1; i < k; i++)\n    {\n        temp[i] = arr[j];\n        j = (j + 1) % arr.length;\n        result[i] = max;\n    }\n    for(i = 0; i < k; i++)\n    {\n        result[i] = temp[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpy1kkdewk.d(47): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy1kkdewk.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr == null || arr.length == 0) return new long[0];\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1s6_0qns.d(74): Error: no identifier for declarator `long`\n/tmp/tmp1s6_0qns.d(74): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1s6_0qns.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ret = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[max]) {\n            max = i;\n        }\n        if (arr[i] < arr[j]) {\n            ret[j] = arr[i];\n            i++;\n        } else {\n            ret[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        ret[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        ret[j] = arr[max];\n        max++;\n        j++;\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpdr9e7jyh.d(48): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c26]\n??:? long[] tmpdr9e7jyh.maximum(long[], long) [0x427ff6]\n??:? void tmpdr9e7jyh.__unittest_L59_C1() [0x4280fe]\n??:? void tmpdr9e7jyh.__modtest() [0x4288f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc53]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bae6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d71]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431220]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430cfd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42babd]\n??:? runModuleUnitTests [0x42ca29]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int kk = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            temp[kk++] = arr[i++];\n        } else {\n            temp[kk++] = arr[j++];\n        }\n    }\n    while (i < arr.length) {\n        temp[kk++] = arr[i++];\n    }\n    while (j < k) {\n        temp[kk++] = arr[j++];\n    }\n    for (int l = 0; l < k; l++) {\n        ans[l] = temp[l];\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpq33tdud_.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c5e]\n??:? long[] tmpq33tdud_.maximum(long[], long) [0x427f58]\n??:? void tmpq33tdud_.__unittest_L54_C1() [0x428132]\n??:? void tmpq33tdud_.__modtest() [0x42892c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc8b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb1e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430da9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431258]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430d35]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42baf5]\n??:? runModuleUnitTests [0x42ca61]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgz7g3x6v.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428a3d]\n??:? void tmpgz7g3x6v.__unittest_L47_C1() [0x428037]\n??:? void tmpgz7g3x6v.__modtest() [0x4287c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b985]\n??:? runModuleUnitTests [0x42c8f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpskki80ix.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpskki80ix.d(75): Error: semicolon expected, not `{`\n/tmp/tmpskki80ix.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskki80ix.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0c2bax3q.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428d5d]\n??:? void tmp0c2bax3q.__unittest_L72_C1() [0x428353]\n??:? void tmp0c2bax3q.__modtest() [0x428adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca5]\n??:? runModuleUnitTests [0x42cc11]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429220]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while(count < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            result[count] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpsqsbi4h6.d(55): unittest failure\n----------------\n??:? _d_unittestp [0x428a3d]\n??:? void tmpsqsbi4h6.__unittest_L51_C1() [0x428037]\n??:? void tmpsqsbi4h6.__modtest() [0x4287c0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb1b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c39]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b985]\n??:? runModuleUnitTests [0x42c8f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n        if (arr[i] <= max) {\n            ans[j++] = arr[i];\n        }\n        i++;\n    }\n    while (i < arr.length) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n        ans[j++] = arr[i];\n        i++;\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpkvp9goa3.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmpkvp9goa3.d(46): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkvp9goa3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp28hb4gym.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp28hb4gym.d(75): Error: semicolon expected, not `{`\n/tmp/tmp28hb4gym.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28hb4gym.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[max]) {\n            max = i;\n        }\n        if (arr[i] > arr[j]) {\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = arr[max];\n        max++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpurlygdf7.d(48): Range violation\n----------------\n??:? _d_arrayboundsp [0x428c26]\n??:? long[] tmpurlygdf7.maximum(long[], long) [0x427ff6]\n??:? void tmpurlygdf7.__unittest_L59_C1() [0x4280fe]\n??:? void tmpurlygdf7.__modtest() [0x4288f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc53]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bae6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d71]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431220]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430cfd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42babd]\n??:? runModuleUnitTests [0x42ca29]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0c2bax3q.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428d5d]\n??:? void tmp0c2bax3q.__unittest_L72_C1() [0x428353]\n??:? void tmp0c2bax3q.__modtest() [0x428adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca5]\n??:? runModuleUnitTests [0x42cc11]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429220]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            result[j++] = arr[i];\n        }\n    }\n    while (i < arr.length) {\n        result[j++] = arr[i++];\n    }\n    while (j < k) {\n        result[j++] = 0;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpix10gsbo.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpix10gsbo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] index = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    long[] count_index = new long[k];\n    long[] index_temp = new long[k];\n    long[] max_index_temp = new long[k];\n    long[] min_index_temp = new long[k];\n    long[] count_index_temp = new long[k];\n    long[] index_temp2 = new long[k];\n    long[] max_index_temp2 = new long[k];\n    long[] min_index_temp2 = new long[k];\n    long[] count_index_temp2 = new long[k];\n    long[] index_temp3 = new long[k];\n    long[] max_index_temp3 = new long[k];\n    long[] min_index_temp3 = new long[k];\n    long[] count_index_temp3 = new long[k];\n    long[] index_temp4 = new long[k];\n    long[] max_index_temp4 = new long[k];\n    long[] min_index_temp4 = new long[k];\n    long[] count_index_temp4 = new long[k];\n    long[] index_temp5 = new long[k];\n    long[] max_index_temp5 = new long[k];\n    long[] min_index_temp5 = new long[k];\n    long[] count_index_temp5 = new long[k];\n    long[] index_temp6 = new long[k];\n    long[] max_index_temp6 = new long[k];\n    long[] min_index_temp6 = new long[k];\n    long[] count_index_temp6 = new long[k];\n    long[] index_temp7 = new long[k];\n    long[] max_index_temp7 = new long[k];\n    long[] min_index_\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpvu2zn3oy.d(67): Error: semicolon expected, not `unittest`\n/tmp/tmpvu2zn3oy.d(67): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvu2zn3oy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max)\n        {\n            max = arr[i];\n            j = i;\n        }\n    }\n    for(i = 0; i < k; i++)\n    {\n        result[i] = arr[j];\n        j = (j + 1) % arr.length;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp55m8v78d.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\n/tmp/tmp55m8v78d.d(46): Error: cannot implicitly convert expression `cast(ulong)(j + 1) % arr.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp55m8v78d.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmppssx254m.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppssx254m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    if (arr == null || arr.length == 0 || k < 1) return new long[0];\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpm1e49akf.d(45): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bb6]\n??:? long[] tmpm1e49akf.maximum(long[], long) [0x427fee]\n??:? void tmpm1e49akf.__unittest_L51_C1() [0x42808e]\n??:? void tmpm1e49akf.__modtest() [0x428888]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbe3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba76]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d01]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311b0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c8d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba4d]\n??:? runModuleUnitTests [0x42c9b9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fc8]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope void delegate()) [0x428f4f]\n??:? _d_run_main [0x428eba]\n??:? main [0x42889b]\n??:? __libc_start_main [0x47374554]\n1/1 unittests FAILED\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        for(int j = 0; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        temp[i] = max[i] - min[i];\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = temp[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp4e2z36y5.d(73): unittest failure\n----------------\n??:? _d_unittestp [0x428cdd]\n??:? void tmp4e2z36y5.__unittest_L69_C1() [0x4282d7]\n??:? void tmp4e2z36y5.__modtest() [0x428a60]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdbb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ed9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431388]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc25]\n??:? runModuleUnitTests [0x42cb91]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = max;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpx7idi63q.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7idi63q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    \nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpi_icv7v9.d(103): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi_icv7v9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int k1 = 0;\n    int k2 = 0;\n    int k3 = 0;\n    int k4 = 0;\n    int k5 = 0;\n    int k6 = 0;\n    int k7 = 0;\n    int k8 = 0;\n    int k9 = 0;\n    int k10 = 0;\n    int k11 = 0;\n    int k12 = 0;\n    int k13 = 0;\n    int k14 = 0;\n    int k15 = 0;\n    int k16 = 0;\n    int k17 = 0;\n    int k18 = 0;\n    int k19 = 0;\n    int k20 = 0;\n    int k21 = 0;\n    int k22 = 0;\n    int k23 = 0;\n    int k24 = 0;\n    int k25 = 0;\n    int k26 = 0;\n    int k27 = 0;\n    int k28 = 0;\n    int k29 = 0;\n    int k30 = 0;\n    int k31 = 0;\n    int k32 = 0;\n    int k33 = 0;\n    int k34 = 0;\n    int k35 = 0;\n    int k36 = 0;\n    int k37 = 0;\n    int k38 = 0;\n    int k39 = 0;\n    int k40 = 0;\n    int k41 = 0;\n    int k42 = 0;\n    int k43 = 0;\n    int k44 = 0;\n    int k45 = 0;\n    int k46 = 0;\n    int k47 = 0;\n    int k48 = 0;\n    int k49 = 0;\n    int k50 = 0;\n    int k51 = 0;\n    int k52 = 0;\n    int k53 = 0;\n    int k54 = 0;\n    int k55 = 0;\n    int k56 = 0;\n    int k57\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpienbn3e1.d(94): Error: semicolon expected, not `unittest`\n/tmp/tmpienbn3e1.d(94): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpienbn3e1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    int i = 0;\n    int j = 0;\n    int kk = 0;\n    for(int l = 0; l < k; l++)\n    {\n        max[l] = arr[0];\n        min[l] = arr[0];\n        tmp[l] = arr[0];\n    }\n    for(int m = 1; m < arr.length; m++)\n    {\n        if(max[kk] < arr[m])\n        {\n            max[kk] = arr[m];\n        }\n        if(min[kk] > arr[m])\n        {\n            min[kk] = arr[m];\n        }\n        if(max[kk] < min[kk])\n        {\n            tmp[kk] = max[kk];\n            max[kk] = min[kk];\n            min[kk] = tmp[kk];\n        }\n        kk = (kk + 1) % k;\n    }\n    for(int n = 0; n < k; n++)\n    {\n        ans[n] = max[n];\n    }\n    return ans;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp45l9cicr.d(72): unittest failure\n----------------\n??:? _d_unittestp [0x428dc5]\n??:? void tmp45l9cicr.__unittest_L68_C1() [0x4283bf]\n??:? void tmp45l9cicr.__modtest() [0x428b48]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cea3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bd36]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430fc1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431470]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430f4d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bd0d]\n??:? runModuleUnitTests [0x42cc79]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429288]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    for (i = 0; i < arr.length; i++) {\n        if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 1;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 2;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 3;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 4;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 5;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 6;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 7;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 8;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 9;\n        }\n        else if (arr[i] > max[max_index]) {\n            max[max_index] = arr[i];\n            max_index = 10;\n        \nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp6okj5j2e.d(81): Error: found `unittest` instead of statement\n/tmp/tmp6okj5j2e.d(97): Error: found `End of File` when expecting `}` following compound statement\n/tmp/tmp6okj5j2e.d(97): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6okj5j2e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            result[max++] = arr[i++];\n        } else {\n            result[max++] = arr[j++];\n        }\n    }\n    while (i < arr.length) {\n        result[max++] = arr[i++];\n    }\n    while (j < k) {\n        result[max++] = arr[j++];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpqj4bqxu6.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bd6]\n??:? long[] tmpqj4bqxu6.maximum(long[], long) [0x427f3d]\n??:? void tmpqj4bqxu6.__unittest_L50_C1() [0x4280aa]\n??:? void tmpqj4bqxu6.__modtest() [0x4288a4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cc03]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba96]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d21]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311d0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430cad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba6d]\n??:? runModuleUnitTests [0x42c9d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = Math.max(max, j);\n            result[j] = arr[i];\n            i++;\n        } else {\n            max = Math.max(max, i);\n            result[i] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        max = Math.max(max, i);\n        result[i] = arr[i];\n        i++;\n    }\n    while (j < k) {\n        max = Math.max(max, j);\n        result[j] = arr[j];\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmp4wvxd20z.d(37): Error: undefined identifier `Math`\n/tmp/tmp4wvxd20z.d(41): Error: undefined identifier `Math`\n/tmp/tmp4wvxd20z.d(47): Error: undefined identifier `Math`\n/tmp/tmp4wvxd20z.d(52): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4wvxd20z.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i1 = 0;\n    int j1 = 0;\n    int k1 = 0;\n    int l1 = 0;\n    int m1 = 0;\n    int n1 = 0;\n    int o1 = 0;\n    int p1 = 0;\n    int q1 = 0;\n    int r1 = 0;\n    int s1 = 0;\n    int t1 = 0;\n    int u1 = 0;\n    int v1 = 0;\n    int w1 = 0;\n    int x1 = 0;\n    int y1 = 0;\n    int z1 = 0;\n    int a1 = 0;\n    int b1 = 0;\n    int c1 = 0;\n    int d1 = 0;\n    int e1 = 0;\n    int f1 = 0;\n    int g1 = 0;\n    int h1 = 0;\n    int i2 = 0;\n    int j2 = 0;\n    int k2 = 0;\n    int l2 = 0;\n    int m2 = 0;\n    int n2 = 0;\n    int o2 = 0;\n    int p2 = 0;\n    int q2 = 0;\n    int r2 = 0;\n    int s\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpxngtzvwg.d(97): Error: semicolon expected, not `unittest`\n/tmp/tmpxngtzvwg.d(97): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxngtzvwg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int count = 0;\n    while (i < arr.length && count < k) {\n        if (arr[i] > arr[j]) {\n            result[count] = arr[i];\n            i++;\n        } else {\n            result[count] = arr[j];\n            j++;\n        }\n        count++;\n    }\n    while (i < arr.length) {\n        result[count] = arr[i];\n        i++;\n        count++;\n    }\n    while (j < arr.length) {\n        result[count] = arr[j];\n        j++;\n        count++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_6fxmmdy.d(46): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bc6]\n??:? long[] tmp_6fxmmdy.maximum(long[], long) [0x427f97]\n??:? void tmp_6fxmmdy.__unittest_L57_C1() [0x42809a]\n??:? void tmp_6fxmmdy.__modtest() [0x428894]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbf3]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba86]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430d11]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311c0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c9d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba5d]\n??:? runModuleUnitTests [0x42c9c9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int functio",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int maxIndex = 0;\n    for(int i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 0;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 1;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 2;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 3;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 4;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 5;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 6;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 7;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 8;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 9;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = 10;\n        }\n        else if(arr[i] > max[maxIndex])\n        {\n            max[\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmptwhvz3w5.d(94): Error: expression expected, not `unittest`\n/tmp/tmptwhvz3w5.d(95): Error: found `{` when expecting `,`\n/tmp/tmptwhvz3w5.d(96): Error: expression expected, not `alias`\n/tmp/tmptwhvz3w5.d(96): Error: found `candidate` when expecting `,`\n/tmp/tmptwhvz3w5.d(96): Error: expression expected, not `=`\n/tmp/tmptwhvz3w5.d(96): Error: found `maximum` when expecting `,`\n/tmp/tmptwhvz3w5.d(96): Error: expression expected, not `;`\n/tmp/tmptwhvz3w5.d(98): Error: found `assert` when expecting `,`\n/tmp/tmptwhvz3w5.d(98): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(99): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(100): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(101): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(102): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(103): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(104): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(105): Error: found `;` when expecting `,`\n/tmp/tmptwhvz3w5.d(106): Err",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            result[j] = arr[i];\n            max = Math.max(max, i);\n            i++;\n        } else {\n            result[j] = arr[j];\n            max = Math.max(max, j);\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        max = Math.max(max, i);\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = arr[max];\n        j++;\n        max = Math.max(max, max);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpy04ifh00.d(38): Error: undefined identifier `Math`\n/tmp/tmpy04ifh00.d(42): Error: undefined identifier `Math`\n/tmp/tmpy04ifh00.d(48): Error: undefined identifier `Math`\n/tmp/tmpy04ifh00.d(55): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy04ifh00.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    int min_index = 0;\n    \n    for(i = 0; i < arr.length; i++)\n    {\n        if(i < k)\n        {\n            min[i] = arr[i];\n            max[i] = arr[i];\n        }\n        else\n        {\n            if(arr[i] > max[max_index])\n            {\n                max[max_index] = arr[i];\n                max_index = i;\n            }\n            else if(arr[i] < min[min_index])\n            {\n                min[min_index] = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        if(i == max_index)\n        {\n            result[i] = max[i];\n        }\n        else if(i == min_index)\n        {\n            result[i] = min[i];\n        }\n        else\n        {\n            result[i] = arr[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn5__kx5s.d(83): unittest failure\n----------------\n??:? _d_unittestp [0x428cdd]\n??:? void tmpn5__kx5s.__unittest_L79_C1() [0x4282d7]\n??:? void tmpn5__kx5s.__modtest() [0x428a60]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdbb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ed9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431388]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc25]\n??:? runModuleUnitTests [0x42cb91]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp28hb4gym.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp28hb4gym.d(75): Error: semicolon expected, not `{`\n/tmp/tmp28hb4gym.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28hb4gym.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    long[] tmp2 = new long[k];\n    long[] tmp3 = new long[k];\n    long[] tmp4 = new long[k];\n    long[] tmp5 = new long[k];\n    long[] tmp6 = new long[k];\n    long[] tmp7 = new long[k];\n    long[] tmp8 = new long[k];\n    long[] tmp9 = new long[k];\n    long[] tmp10 = new long[k];\n    long[] tmp11 = new long[k];\n    long[] tmp12 = new long[k];\n    long[] tmp13 = new long[k];\n    long[] tmp14 = new long[k];\n    long[] tmp15 = new long[k];\n    long[] tmp16 = new long[k];\n    long[] tmp17 = new long[k];\n    long[] tmp18 = new long[k];\n    long[] tmp19 = new long[k];\n    long[] tmp20 = new long[k];\n    long[] tmp21 = new long[k];\n    long[] tmp22 = new long[k];\n    long[] tmp23 = new long[k];\n    long[] tmp24 = new long[k];\n    long[] tmp25 = new long[k];\n    long[] tmp26 = new long[k];\n    long[] tmp27 = new long[k];\n    long[] tmp28 = new long[k];\n    long[] tmp29 = new long[k];\n    long[] tmp30 = new long[k];\n    long[] tmp31 = new long[k];\n    long[] tmp32 = new long[k];\n    long[] tmp33 = new long[k];\n    long[] tmp34 = new long[k];\n    long[] tmp35 = new long[k];\n    long[] tmp36 = new long[k];\n    long[] tmp37 = new long[k];\n    long[] tmp38 = new long[k];\n    long[] tmp39 = new long[k];\n    long[] tmp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp28hb4gym.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp28hb4gym.d(75): Error: semicolon expected, not `{`\n/tmp/tmp28hb4gym.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp28hb4gym.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpdqqs5c4x.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdqqs5c4x.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = max;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpx7idi63q.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7idi63q.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] max_count = new long[k];\n    long[] min_count = new long[k];\n    long[] max_index = new long[k];\n    long[] min_index = new long[k];\n    long[] count_index = new long[k];\n    long[] max_index_count = new long[k];\n    long[] min_index_count = new long[k];\n    long[] count_index_count = new long[k];\n    long[] max_index_count_index = new long[k];\n    long[] min_index_count_index = new long[k];\n    long[] count_index_count_index = new long[k];\n    long[] max_index_count_index_count = new long[k];\n    long[] min_index_count_index_count = new long[k];\n    long[] count_index_count_index_count = new long[k];\n    long[] max_index_count_index_count_index = new long[k];\n    long[] min_index_count_index_count_index = new long[k];\n    long[] count_index_count_index_count_index = new long[k];\n    long[] max_index_count_index_count_index_count = new long[k];\n    long[] min_index_count_index_count_index_count = new long[k];\n    long[] count_index_count_index_count_index_count = new long[k];\n    long[] max_index_count_index_count_index_count_index = new long[k];\n    long[] min_index_count_index_count_index_count_index = new long[k];\n    long[] count_index_count_index_count_index_count_index = new long[k];\n    long[] max_index_count_index_count_index_count_index_count = new long[k];\n    long[] min_index_count_index_count_index\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpx868j45t.d(60): Error: semicolon expected, not `unittest`\n/tmp/tmpx868j45t.d(60): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx868j45t.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] temp = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] count = new long[k];\n    long[] maxCount = new long[k];\n    long[] minCount = new long[k];\n    long[] countMax = new long[k];\n    long[] countMin = new long[k];\n    long[] countMaxMin = new long[k];\n    long[] countMaxMinMax = new long[k];\n    long[] countMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMin = new long[k];\n    long[] countMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMaxMinMax\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "/tmp/tmpy4lr_08c.d(59): Error: semicolon expected, not `unittest`\n/tmp/tmpy4lr_08c.d(59): Error: found `unittest` instead of statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy4lr_08c.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        for(int j = 0; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf65qlv3u.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x428c1d]\n??:? void tmpf65qlv3u.__unittest_L63_C1() [0x428217]\n??:? void tmpf65qlv3u.__modtest() [0x4289a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430da5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb65]\n??:? runModuleUnitTests [0x42cad1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        for(int j = 0; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf65qlv3u.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x428c1d]\n??:? void tmpf65qlv3u.__unittest_L63_C1() [0x428217]\n??:? void tmpf65qlv3u.__modtest() [0x4289a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430da5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb65]\n??:? runModuleUnitTests [0x42cad1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[0])\n        {\n            max[0] = arr[i];\n        }\n        else if(arr[i] < min[0])\n        {\n            min[0] = arr[i];\n        }\n        \n        for(int j = 1; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            else if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0c2bax3q.d(76): unittest failure\n----------------\n??:? _d_unittestp [0x428d5d]\n??:? void tmp0c2bax3q.__unittest_L72_C1() [0x428353]\n??:? void tmp0c2bax3q.__modtest() [0x428adc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ce3b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bcce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430f59]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431408]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ee5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bca5]\n??:? runModuleUnitTests [0x42cc11]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x429220]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < arr.length && j < k) {\n        if (arr[i] > arr[j]) {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        } else {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while (i < arr.length) {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while (j < k) {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp0qovbahu.d(37): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0qovbahu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    int i = 0;\n    int j = 0;\n    int max = 0;\n    while(i < arr.length && j < k)\n    {\n        if(arr[i] > arr[j])\n        {\n            max = arr[i];\n            result[j] = arr[i];\n            i++;\n        }\n        else\n        {\n            result[j] = arr[j];\n            j++;\n        }\n    }\n    while(i < arr.length)\n    {\n        result[j] = arr[i];\n        i++;\n        j++;\n    }\n    while(j < k)\n    {\n        result[j] = 0;\n        j++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpxnumkpem.d(39): Error: cannot implicitly convert expression `arr[cast(ulong)i]` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxnumkpem.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] res = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmp1bowzflj.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmp1bowzflj.d(75): Error: semicolon expected, not `{`\n/tmp/tmp1bowzflj.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1bowzflj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpcgu_v2_4.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpcgu_v2_4.d(75): Error: semicolon expected, not `{`\n/tmp/tmpcgu_v2_4.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgu_v2_4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    for(i = 0; i < arr.length; i++)\n    {\n        if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 0;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 1;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 2;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 3;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 4;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 5;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 6;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 7;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 8;\n        }\n        else if(arr[i] > max[max_index])\n        {\n            max[max_index] = arr[i];\n            max_index = 9;\n        }\n        else if(arr[i] > max[max_index])\n        \nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpo4biv_65.d(90): Error: found `unittest` instead of statement\n/tmp/tmpo4biv_65.d(106): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo4biv_65.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    int i = 0;\n    int j = 0;\n    int index = 0;\n    int maxIndex = 0;\n    int minIndex = 0;\n    \n    for(i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(i = 1; i < arr.length; i++)\n    {\n        if(arr[i] > max[maxIndex])\n        {\n            max[maxIndex] = arr[i];\n            maxIndex = i;\n        }\n        else if(arr[i] < min[minIndex])\n        {\n            min[minIndex] = arr[i];\n            minIndex = i;\n        }\n    }\n    \n    for(i = 0; i < k; i++)\n    {\n        if(max[i] == min[i])\n        {\n            result[i] = max[i];\n        }\n        else\n        {\n            result[i] = max[i];\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptqp8javo.d(79): unittest failure\n----------------\n??:? _d_unittestp [0x428ced]\n??:? void tmptqp8javo.__unittest_L75_C1() [0x4282e3]\n??:? void tmptqp8javo.__modtest() [0x428a6c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdcb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc5e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ee9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431398]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e75]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc35]\n??:? runModuleUnitTests [0x42cba1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291b0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    \n    for(int i = 0; i < k; i++)\n    {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for(int i = 1; i < arr.length; i++)\n    {\n        for(int j = 0; j < k; j++)\n        {\n            if(arr[i] > max[j])\n            {\n                max[j] = arr[i];\n            }\n            if(arr[i] < min[j])\n            {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for(int i = 0; i < k; i++)\n    {\n        result[i] = max[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpf65qlv3u.d(67): unittest failure\n----------------\n??:? _d_unittestp [0x428c1d]\n??:? void tmpf65qlv3u.__unittest_L63_C1() [0x428217]\n??:? void tmpf65qlv3u.__modtest() [0x4289a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ccfb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bb8e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430e19]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4312c8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430da5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bb65]\n??:? runModuleUnitTests [0x42cad1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4290e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] result = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] tmp = new long[k];\n    \n    for (int i = 0; i < k; i++) {\n        max[i] = arr[0];\n        min[i] = arr[0];\n    }\n    \n    for (int i = 1; i < arr.length; i++) {\n        for (int j = 0; j < k; j++) {\n            if (arr[i] > max[j]) {\n                max[j] = arr[i];\n            }\n            if (arr[i] < min[j]) {\n                min[j] = arr[i];\n            }\n        }\n    }\n    \n    for (int i = 0; i < k; i++) {\n        tmp[i] = max[i] - min[i];\n    }\n    \n    for (int i = 0; i < k; i++) {\n        result[i] = tmp[i];\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292997,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmx6vdr_3.d(66): unittest failure\n----------------\n??:? _d_unittestp [0x428cdd]\n??:? void tmpmx6vdr_3.__unittest_L62_C1() [0x4282d7]\n??:? void tmpmx6vdr_3.__modtest() [0x428a60]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cdbb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc4e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ed9]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431388]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e65]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bc25]\n??:? runModuleUnitTests [0x42cb91]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4291a0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n\n    Given an array arr of integers and a positive integer k, return a sorted array \n    of length k with the maximum k numbers in arr.\n\n    Example 1:\n\n    >>> maximum([-3L, -4L, 5L], 3L)\n    [-4L, -3L, 5L]\n\n    Example 2:\n\n    >>> maximum([4L, -4L, 4L], 2L)\n    [4L, 4L]\n\n    Example 3:\n\n    >>> maximum([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L)\n    [2L]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \n*/\nlong[] maximum(long[] arr, long k) \n{\n    long[] ans = new long[k];\n    long[] max = new long[k];\n    long[] min = new long[k];\n    long[] temp = new long[k];\n    long[] temp2 = new long[k];\n    long[] temp3 = new long[k];\n    long[] temp4 = new long[k];\n    long[] temp5 = new long[k];\n    long[] temp6 = new long[k];\n    long[] temp7 = new long[k];\n    long[] temp8 = new long[k];\n    long[] temp9 = new long[k];\n    long[] temp10 = new long[k];\n    long[] temp11 = new long[k];\n    long[] temp12 = new long[k];\n    long[] temp13 = new long[k];\n    long[] temp14 = new long[k];\n    long[] temp15 = new long[k];\n    long[] temp16 = new long[k];\n    long[] temp17 = new long[k];\n    long[] temp18 = new long[k];\n    long[] temp19 = new long[k];\n    long[] temp20 = new long[k];\n    long[] temp21 = new long[k];\n    long[] temp22 = new long[k];\n    long[] temp23 = new long[k];\n    long[] temp24 = new long[k];\n    long[] temp25 = new long[k];\n    long[] temp26 = new long[k];\n    long[] temp27 = new long[k];\n    long[] temp28 = new long[k];\n    long[] temp29 = new long[k];\n    long[] temp30 = new long[k];\n    long[] temp31 = new long[k];\n    long[] temp32 = new long[k];\n    long[] temp33 = new long[k];\n    long[] temp34 = new long[k];\n    long[] temp35 = new long[k];\n    long[] temp36 = new long[k];\n    long[] temp37 = new long[k];\n    long[] temp38 = new long[k];\n    long[] temp39 = new long[k];\n    long[] temp40 = new long[k\nunittest\n{\n    alias candidate = maximum;\n\n    assert(candidate([-3L, -4L, 5L], 3L) == [-4L, -3L, 5L]);\n    assert(candidate([4L, -4L, 4L], 2L) == [4L, 4L]);\n    assert(candidate([-3L, 2L, 1L, 2L, -1L, -2L, 1L], 1L) == [2L]);\n    assert(candidate([123L, -123L, 20L, 0L, 1L, 2L, -3L], 3L) == [2L, 20L, 123L]);\n    assert(candidate([-123L, 20L, 0L, 1L, 2L, -3L], 4L) == [0L, 1L, 2L, 20L]);\n    assert(candidate([5L, 15L, 0L, 3L, -13L, -8L, 0L], 7L) == [-13L, -8L, 0L, 0L, 3L, 5L, 15L]);\n    assert(candidate([-1L, 0L, 2L, 5L, 3L, -10L], 2L) == [3L, 5L]);\n    assert(candidate([1L, 0L, 5L, -7L], 1L) == [5L]);\n    assert(candidate([4L, -4L], 2L) == [-4L, 4L]);\n    assert(candidate([-10L, 10L], 2L) == [-10L, 10L]);\n    assert(candidate([1L, 2L, 3L, -23L, 243L, -400L, 0L], 0L) == []);\n}\nvoid main(){}",
      "timestamp": 1664292996,
      "stdout": "",
      "stderr": "/tmp/tmpq88s11ga.d(74): Error: found `unittest` when expecting `]`\n/tmp/tmpq88s11ga.d(75): Error: semicolon expected, not `{`\n/tmp/tmpq88s11ga.d(90): Error: found `End of File` when expecting `}` following compound statement\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq88s11ga.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}