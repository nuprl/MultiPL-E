{
  "name": "HumanEval_130_tri",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n",
  "tests": "unittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 1)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    for (int i = 2; i < n + 1; i++)\n        result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp7itsvunb.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp7itsvunb.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmp7itsvunb.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp7itsvunb.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp7itsvunb.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmp7itsvunb.d(29): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7itsvunb.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n must be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1, 3};\n    if (n == 2)\n        return new long[]{1, 1, 3};\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    for (int i = 2; i < n + 1; i++)\n        result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmptsflp54g.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmptsflp54g.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmptsflp54g.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmptsflp54g.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmptsflp54g.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmptsflp54g.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptsflp54g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6jc_cm1t.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428a85]\n??:? void tmp6jc_cm1t.__unittest_L42_C1() [0x428235]\n??:? void tmp6jc_cm1t.__modtest() [0x428808]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43110c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a9]\n??:? runModuleUnitTests [0x42c915]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 2; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmplsl5zzgm.d(32): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\n/tmp/tmplsl5zzgm.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplsl5zzgm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n < 2) return result;\n    if (n % 2 == 0)\n    {\n        for (int i = 3; i <= n; i += 2)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        for (int i = 3; i <= n; i += 2)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmprxynyq68.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a0e]\n??:? long[] tmprxynyq68.tri(long) [0x42804a]\n??:? void tmprxynyq68.__unittest_L45_C1() [0x42808f]\n??:? void tmprxynyq68.__modtest() [0x4286dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b881]\n??:? runModuleUnitTests [0x42c7ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmppozhocv9.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b3e]\n??:? long[] tmppozhocv9.tri(long) [0x4280b5]\n??:? void tmppozhocv9.__unittest_L42_C1() [0x4281c3]\n??:? void tmppozhocv9.__modtest() [0x428810]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb47]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9da]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c65]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431114]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bf1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9b1]\n??:? runModuleUnitTests [0x42c91d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpimlfm_mt.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpimlfm_mt.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpimlfm_mt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpotvl02_m.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpotvl02_m.tri(long) [0x4280ce]\n??:? void tmpotvl02_m.__unittest_L48_C1() [0x4281df]\n??:? void tmpotvl02_m.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp_cyj1oda.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmp_cyj1oda.d(38): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_cyj1oda.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (long i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplok0phwo.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42883d]\n??:? void tmplok0phwo.__unittest_L33_C1() [0x427fe9]\n??:? void tmplok0phwo.__modtest() [0x4285bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a15]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ec4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b761]\n??:? runModuleUnitTests [0x42c6cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpfbkypyv2.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpfbkypyv2.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfbkypyv2.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpd_q8apvy.d(33): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\n/tmp/tmpd_q8apvy.d(41): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd_q8apvy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpk8eu87z6.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a0e]\n??:? long[] tmpk8eu87z6.tri(long) [0x42804a]\n??:? void tmpk8eu87z6.__unittest_L40_C1() [0x42808f]\n??:? void tmpk8eu87z6.__modtest() [0x4286dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b881]\n??:? runModuleUnitTests [0x42c7ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpuej37xi4.d(33): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\n/tmp/tmpuej37xi4.d(41): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuej37xi4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[2] = 2;\n        for (int i = 3; i < n + 1; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    } else {\n        result[2] = 1;\n        for (int i = 3; i < n + 1; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpb56_fvft.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428975]\n??:? void tmpb56_fvft.__unittest_L42_C1() [0x428121]\n??:? void tmpb56_fvft.__modtest() [0x4286f4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b4d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ffc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b899]\n??:? runModuleUnitTests [0x42c805]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    res[0] = 0;\n    res[1] = 1;\n    if (n == 0) return res;\n    if (n == 1) return res;\n    if (n % 2 == 0) {\n        res[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            res[i] = res[i - 1] + res[i - 2] + res[i - 3];\n        }\n    } else {\n        res[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            res[i] = res[i - 1] + res[i - 2] + res[i - 3];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjcp26o0_.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmpjcp26o0_.__unittest_L42_C1() [0x428115]\n??:? void tmpjcp26o0_.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpro5i7le_.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b7e]\n??:? long[] tmpro5i7le_.tri(long) [0x4280de]\n??:? void tmpro5i7le_.__unittest_L44_C1() [0x4281ff]\n??:? void tmpro5i7le_.__modtest() [0x42884c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb87]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba1a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ca5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431154]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c31]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9f1]\n??:? runModuleUnitTests [0x42c95d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[2] = 1;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmph782r6iy.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmph782r6iy.__unittest_L49_C1() [0x428115]\n??:? void tmph782r6iy.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n must be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L, 3L};\n    if (n == 2)\n        return new long[]{1L, 2L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    for (int i = 2; i < n + 1; i++)\n        result[i] = 1L + (i / 2) + result[i - 1] + result[i - 2];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp7auft7ki.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp7auft7ki.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmp7auft7ki.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp7auft7ki.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp7auft7ki.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmp7auft7ki.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7auft7ki.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[2] = 1;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz0rnv482.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmpz0rnv482.__unittest_L47_C1() [0x428115]\n??:? void tmpz0rnv482.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[2] = 2;\n        for (int i = 3; i < n + 1; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    } else {\n        result[2] = 1 + result[1];\n        for (int i = 3; i < n + 1; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmptlkekyi6.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x4289c5]\n??:? void tmptlkekyi6.__unittest_L42_C1() [0x428171]\n??:? void tmptlkekyi6.__modtest() [0x428744]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca7f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b912]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b9d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43104c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b29]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8e9]\n??:? runModuleUnitTests [0x42c855]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e88]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n == 0) return new long[0];\n    if (n == 1) return new long[]{1L, 3L};\n    if (n == 2) return new long[]{1L, 2L, 3L};\n    if (n == 3) return new long[]{1L, 1L, 2L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n    {\n        for (int i = 2; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        for (int i = 2; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp3r6lgvwt.d(25): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3r6lgvwt.d(25): Error: found `}` when expecting `;` following statement\n/tmp/tmp3r6lgvwt.d(25): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp3r6lgvwt.d(26): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3r6lgvwt.d(26): Error: found `}` when expecting `;` following statement\n/tmp/tmp3r6lgvwt.d(26): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp3r6lgvwt.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3r6lgvwt.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmp3r6lgvwt.d(27): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3r6lgvwt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[3] = 2;\n        for (int i = 4; i <= n; i++)\n        {\n            result[i] = result[i - 2] + result[i - 1] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[3] = 3;\n        for (int i = 4; i <= n; i++)\n        {\n            result[i] = result[i - 2] + result[i - 1] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuyq5i0n6.d(54): unittest failure\n----------------\n??:? _d_unittestp [0x428985]\n??:? void tmpuyq5i0n6.__unittest_L50_C1() [0x428135]\n??:? void tmpuyq5i0n6.__modtest() [0x428708]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43100c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ae9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8a9]\n??:? runModuleUnitTests [0x42c815]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 1)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    if (n % 2 == 0)\n        return new long[]{1L, 1L + n / 2L, 1L + n / 2L, 1L + n / 2L + n / 2L};\n    else\n        return new long[]{1L, 1L + n / 2L, 1L + n / 2L, 1L + n / 2L + n / 2L, 1L + n / 2L + n / 2L + n / 2L};\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmphe_dvjlj.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmphe_dvjlj.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmphe_dvjlj.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmphe_dvjlj.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmphe_dvjlj.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmphe_dvjlj.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmphe_dvjlj.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmphe_dvjlj.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmphe_dvjlj.d(31): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmphe_dvjlj.d(32): Error: found `else` without a corresponding `if`, `version` or `debug` statement\n/tmp/tmphe_dvjlj.d(34): Error: unrecognized declaration\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphe_dvjlj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyc_fzsn9.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpyc_fzsn9.tri(long) [0x428000]\n??:? void tmpyc_fzsn9.__unittest_L37_C1() [0x428037]\n??:? void tmpyc_fzsn9.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpqcqn0ne9.d(38): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b66]\n??:? long[] tmpqcqn0ne9.tri(long) [0x4280c9]\n??:? void tmpqcqn0ne9.__unittest_L44_C1() [0x4281eb]\n??:? void tmpqcqn0ne9.__modtest() [0x428838]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb6f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba02]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c8d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43113c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c19]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d9]\n??:? runModuleUnitTests [0x42c945]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 1)\n        throw new Error(\"tri(n) expects n >= 1\");\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 2] + result[n - 1] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpvzkcilk_.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a6e]\n??:? long[] tmpvzkcilk_.tri(long) [0x428029]\n??:? void tmpvzkcilk_.__unittest_L40_C1() [0x42805f]\n??:? void tmpvzkcilk_.__modtest() [0x4286ac]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cd83]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42bc0e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ea1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431350]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430e2d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42bbe5]\n??:? runModuleUnitTests [0x42cb59]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpj5po7kzd.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmpj5po7kzd.tri(long) [0x4280a8]\n??:? void tmpj5po7kzd.__unittest_L48_C1() [0x428193]\n??:? void tmpj5po7kzd.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i >= 2; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i >= 2; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpvv482k7f.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpvv482k7f.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvv482k7f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpr32j5c8t.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a0e]\n??:? long[] tmpr32j5c8t.tri(long) [0x42804a]\n??:? void tmpr32j5c8t.__unittest_L40_C1() [0x42808f]\n??:? void tmpr32j5c8t.__modtest() [0x4286dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b881]\n??:? runModuleUnitTests [0x42c7ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[] {1L, 3L};\n    if (n == 2)\n        return new long[] {1L, 2L, 8L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n        for (int i = 2; i < n; i += 2)\n            result[i] = result[i - 2] + result[i - 1] + result[i + 1];\n    else\n        for (int i = 2; i < n; i += 2)\n            result[i] = result[i - 2] + result[i - 1] + result[i + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp7s2ime3a.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp7s2ime3a.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmp7s2ime3a.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp7s2ime3a.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp7s2ime3a.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmp7s2ime3a.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7s2ime3a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpd_q8apvy.d(33): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\n/tmp/tmpd_q8apvy.d(41): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd_q8apvy.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[2] = 1 + result[1] + result[2];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp8jwkyurw.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x4289ad]\n??:? void tmp8jwkyurw.__unittest_L47_C1() [0x428159]\n??:? void tmp8jwkyurw.__modtest() [0x42872c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431034]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8d1]\n??:? runModuleUnitTests [0x42c83d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv0796i6f.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x42896d]\n??:? void tmpv0796i6f.__unittest_L41_C1() [0x42811d]\n??:? void tmpv0796i6f.__modtest() [0x4286f0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca27]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ba]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b45]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ff4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b891]\n??:? runModuleUnitTests [0x42c7fd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e30]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    for (int i = 2; i < n + 1; i++)\n    {\n        result[i] = 1L + (i / 2) + result[i - 1] + result[i - 2];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpfiuakdva.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpfiuakdva.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpfiuakdva.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpfiuakdva.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpfiuakdva.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpfiuakdva.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfiuakdva.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n < 2)\n        return result;\n    if (n % 2 == 0)\n        result[2] = 2;\n    else\n        result[2] = 1 + (n / 2);\n    for (int i = 3; i <= n; i++)\n        result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpzn4nt6mz.d(25): Error: undefined identifier `IllegalArgumentException`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzn4nt6mz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuy3615su.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpuy3615su.__unittest_L34_C1() [0x427fe5]\n??:? void tmpuy3615su.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp31ar66q3.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmp31ar66q3.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp31ar66q3.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpngs9v3st.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpngs9v3st.tri(long) [0x428000]\n??:? void tmpngs9v3st.__unittest_L41_C1() [0x428037]\n??:? void tmpngs9v3st.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmphbgdzv69.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmphbgdzv69.__unittest_L41_C1() [0x428115]\n??:? void tmphbgdzv69.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpta4bis93.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpta4bis93.tri(long) [0x428000]\n??:? void tmpta4bis93.__unittest_L40_C1() [0x428037]\n??:? void tmpta4bis93.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 1) return result;\n    if (n == 2) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp08w5qfnn.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmp08w5qfnn.tri(long) [0x4280a8]\n??:? void tmp08w5qfnn.__unittest_L48_C1() [0x428193]\n??:? void tmp08w5qfnn.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpm2q3xyfo.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmpm2q3xyfo.tri(long) [0x4280a8]\n??:? void tmpm2q3xyfo.__unittest_L46_C1() [0x428193]\n??:? void tmpm2q3xyfo.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L, 3L};\n    if (n == 2)\n        return new long[]{1L, 2L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    for (int i = 2; i < n + 1; i++)\n        result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmp9281ozjt.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp9281ozjt.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmp9281ozjt.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp9281ozjt.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp9281ozjt.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmp9281ozjt.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9281ozjt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpao2zgdgj.d(33): Range violation\n----------------\n??:? _d_arrayboundsp [0x42899e]\n??:? long[] tmpao2zgdgj.tri(long) [0x427feb]\n??:? void tmpao2zgdgj.__unittest_L36_C1() [0x42801f]\n??:? void tmpao2zgdgj.__modtest() [0x42866c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9a7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b83a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ac5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f74]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a51]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b811]\n??:? runModuleUnitTests [0x42c77d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyc_fzsn9.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpyc_fzsn9.tri(long) [0x428000]\n??:? void tmpyc_fzsn9.__unittest_L37_C1() [0x428037]\n??:? void tmpyc_fzsn9.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6jc_cm1t.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428a85]\n??:? void tmp6jc_cm1t.__unittest_L42_C1() [0x428235]\n??:? void tmp6jc_cm1t.__modtest() [0x428808]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43110c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a9]\n??:? runModuleUnitTests [0x42c915]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (long i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplok0phwo.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42883d]\n??:? void tmplok0phwo.__unittest_L33_C1() [0x427fe9]\n??:? void tmplok0phwo.__modtest() [0x4285bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a15]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ec4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b761]\n??:? runModuleUnitTests [0x42c6cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n + 1; i < result.length; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpu91_tkpt.d(32): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\n/tmp/tmpu91_tkpt.d(37): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu91_tkpt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (long i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplok0phwo.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42883d]\n??:? void tmplok0phwo.__unittest_L33_C1() [0x427fe9]\n??:? void tmplok0phwo.__modtest() [0x4285bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a15]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ec4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b761]\n??:? runModuleUnitTests [0x42c6cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyzu_ky26.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpyzu_ky26.tri(long) [0x4280ce]\n??:? void tmpyzu_ky26.__unittest_L43_C1() [0x4281df]\n??:? void tmpyzu_ky26.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpuutm67w9.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmpuutm67w9.tri(long) [0x4280a8]\n??:? void tmpuutm67w9.__unittest_L48_C1() [0x428193]\n??:? void tmpuutm67w9.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpn861obm7.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpn861obm7.tri(long) [0x428000]\n??:? void tmpn861obm7.__unittest_L37_C1() [0x428037]\n??:? void tmpn861obm7.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1, 3};\n    if (n == 2)\n        return new long[]{1, 2, 3};\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    for (int i = 2; i < n + 1; i++)\n    {\n        result[i] = 1 + (i / 2);\n        if (i % 2 == 0)\n            result[i] += result[i - 2];\n        else\n            result[i] += result[i - 1] + result[i - 2];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpo6dqxrh1.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpo6dqxrh1.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpo6dqxrh1.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpo6dqxrh1.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpo6dqxrh1.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpo6dqxrh1.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo6dqxrh1.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpotvl02_m.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpotvl02_m.tri(long) [0x4280ce]\n??:? void tmpotvl02_m.__unittest_L48_C1() [0x4281df]\n??:? void tmpotvl02_m.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpnezreoca.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpnezreoca.d(38): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnezreoca.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    else\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp13y7699i.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289ce]\n??:? long[] tmp13y7699i.tri(long) [0x42801c]\n??:? void tmp13y7699i.__unittest_L38_C1() [0x428053]\n??:? void tmp13y7699i.__modtest() [0x4286a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9d7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b86a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430af5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fa4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a81]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b841]\n??:? runModuleUnitTests [0x42c7ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 2; i >= 0; i--)\n        {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 2; i >= 0; i--)\n        {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmptne52cus.d(33): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\n/tmp/tmptne52cus.d(41): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptne52cus.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpo0vh53ez.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmpo0vh53ez.__unittest_L41_C1() [0x428115]\n??:? void tmpo0vh53ez.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_k4_rlkm.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b7e]\n??:? long[] tmp_k4_rlkm.tri(long) [0x4280de]\n??:? void tmp_k4_rlkm.__unittest_L48_C1() [0x4281ff]\n??:? void tmp_k4_rlkm.__modtest() [0x42884c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb87]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba1a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ca5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431154]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c31]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9f1]\n??:? runModuleUnitTests [0x42c95d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp56gks2cg.d(42): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmp56gks2cg.tri(long) [0x4280a8]\n??:? void tmp56gks2cg.__unittest_L50_C1() [0x428193]\n??:? void tmp56gks2cg.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyc_fzsn9.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpyc_fzsn9.tri(long) [0x428000]\n??:? void tmpyc_fzsn9.__unittest_L37_C1() [0x428037]\n??:? void tmpyc_fzsn9.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpu2p_exc2.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b7e]\n??:? long[] tmpu2p_exc2.tri(long) [0x4280de]\n??:? void tmpu2p_exc2.__unittest_L48_C1() [0x4281ff]\n??:? void tmpu2p_exc2.__modtest() [0x42884c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb87]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba1a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ca5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431154]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c31]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9f1]\n??:? runModuleUnitTests [0x42c95d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L, 3L};\n    if (n == 2)\n        return new long[]{1L, 2L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n        for (int i = 2; i < n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    else\n        for (int i = 2; i < n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpwsi4d6mp.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpwsi4d6mp.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpwsi4d6mp.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpwsi4d6mp.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpwsi4d6mp.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpwsi4d6mp.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwsi4d6mp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i > 0; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpg9fd3mda.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpg9fd3mda.d(38): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg9fd3mda.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpr32j5c8t.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a0e]\n??:? long[] tmpr32j5c8t.tri(long) [0x42804a]\n??:? void tmpr32j5c8t.__unittest_L40_C1() [0x42808f]\n??:? void tmpr32j5c8t.__modtest() [0x4286dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b881]\n??:? runModuleUnitTests [0x42c7ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i >= 2; i--)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i >= 2; i--)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpdyepmoib.d(33): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpdyepmoib.d(41): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdyepmoib.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpdls0dr3y.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpdls0dr3y.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdls0dr3y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (long i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmplok0phwo.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x42883d]\n??:? void tmplok0phwo.__unittest_L33_C1() [0x427fe9]\n??:? void tmplok0phwo.__modtest() [0x4285bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8f7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b78a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a15]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ec4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309a1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b761]\n??:? runModuleUnitTests [0x42c6cd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmppy9yl_k5.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmppy9yl_k5.__unittest_L34_C1() [0x427fe5]\n??:? void tmppy9yl_k5.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    else\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1426vd8k.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289a6]\n??:? long[] tmp1426vd8k.tri(long) [0x427ff7]\n??:? void tmp1426vd8k.__unittest_L38_C1() [0x42802b]\n??:? void tmp1426vd8k.__modtest() [0x428678]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b842]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430acd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a59]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b819]\n??:? runModuleUnitTests [0x42c785]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[] {1, 3};\n    if (n == 2)\n        return new long[] {1, 3, 2, 8};\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    long n2 = n - 2;\n    long n1 = n - 1;\n    long n3 = n;\n    for (int i = 2; i < n + 1; i++) {\n        result[i] = 1 + n2 / 2;\n        if (i % 2 == 0)\n            n2 = n2 - result[i - 1];\n        else\n            n3 = n3 - result[i - 1] - result[i - 2];\n        result[i] = result[i - 1] + result[i - 2] + result[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpn1aenio4.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpn1aenio4.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpn1aenio4.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpn1aenio4.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpn1aenio4.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpn1aenio4.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn1aenio4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyzu_ky26.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpyzu_ky26.tri(long) [0x4280ce]\n??:? void tmpyzu_ky26.__unittest_L43_C1() [0x4281df]\n??:? void tmpyzu_ky26.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpvoi3_xz4.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmpvoi3_xz4.tri(long) [0x4280a8]\n??:? void tmpvoi3_xz4.__unittest_L48_C1() [0x428193]\n??:? void tmpvoi3_xz4.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        return result;\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp966mww_f.d(47): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmp966mww_f.__unittest_L43_C1() [0x4280bd]\n??:? void tmp966mww_f.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b85a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a71]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b831]\n??:? runModuleUnitTests [0x42c79d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n must be non-negative\");\n    if (n == 0)\n        return new long[] {0L};\n    if (n == 1)\n        return new long[] {1L, 3L};\n    if (n == 2)\n        return new long[] {1L, 2L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 0L;\n    result[1] = 1L;\n    result[2] = 2L;\n    long n_1 = n - 1;\n    long n_2 = n - 2;\n    long n_3 = n - 3;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = 1L + n_1 / 2L;\n        if (i % 2 == 0)\n            result[i] += result[i - 2];\n        else\n            result[i] += result[i - 1] + result[i - 2] + result[i - 3];\n        n_1 = n_2;\n        n_2 = n_3;\n        n_3 = i - 1;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmphi7_mrpm.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmphi7_mrpm.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmphi7_mrpm.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmphi7_mrpm.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmphi7_mrpm.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmphi7_mrpm.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmphi7_mrpm.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmphi7_mrpm.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmphi7_mrpm.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphi7_mrpm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn2ce80gb.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42895d]\n??:? void tmpn2ce80gb.__unittest_L40_C1() [0x428109]\n??:? void tmpn2ce80gb.__modtest() [0x4286dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b881]\n??:? runModuleUnitTests [0x42c7ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i >= 2; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i >= 2; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmpvv482k7f.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpvv482k7f.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvv482k7f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpfi7s7ol7.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpfi7s7ol7.tri(long) [0x4280ce]\n??:? void tmpfi7s7ol7.__unittest_L43_C1() [0x4281df]\n??:? void tmpfi7s7ol7.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpzmzs5kjb.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmpzmzs5kjb.__unittest_L37_C1() [0x4280bd]\n??:? void tmpzmzs5kjb.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b85a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a71]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b831]\n??:? runModuleUnitTests [0x42c79d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_u5nrl7s.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x428afe]\n??:? long[] tmp_u5nrl7s.tri(long) [0x428093]\n??:? void tmp_u5nrl7s.__unittest_L42_C1() [0x42817f]\n??:? void tmp_u5nrl7s.__modtest() [0x4287cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b99a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310d4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bb1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b971]\n??:? runModuleUnitTests [0x42c8dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 3] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i - 4] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpx9qf6pdz.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428ba6]\n??:? long[] tmpx9qf6pdz.tri(long) [0x4280f2]\n??:? void tmpx9qf6pdz.__unittest_L48_C1() [0x42822b]\n??:? void tmpx9qf6pdz.__modtest() [0x428878]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbaf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba42]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ccd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43117c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c59]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba19]\n??:? runModuleUnitTests [0x42c985]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i > 1; i--)\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i > 1; i--)\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpdhm84beg.d(35): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpdhm84beg.d(41): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdhm84beg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n % 2 == 0) {\n        result[2] = 2;\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        result[2] = 1 + (n / 2);\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpe7e1qprn.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a4e]\n??:? long[] tmpe7e1qprn.tri(long) [0x42808b]\n??:? void tmpe7e1qprn.__unittest_L41_C1() [0x4280cf]\n??:? void tmpe7e1qprn.__modtest() [0x42871c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca57]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8ea]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b75]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431024]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b01]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8c1]\n??:? runModuleUnitTests [0x42c82d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n        result[n / 2] = result[n / 2 - 1] + result[n / 2 - 2] + result[n / 2 + 1];\n    else\n        result[n / 2] = result[n / 2 - 1] + result[n / 2 - 2] + result[n / 2 + 1];\n    for (int i = 3; i <= n; i++)\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmplx12tbj6.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x428a8e]\n??:? long[] tmplx12tbj6.tri(long) [0x427ffc]\n??:? void tmplx12tbj6.__unittest_L40_C1() [0x428113]\n??:? void tmplx12tbj6.__modtest() [0x428760]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca97]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b92a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430bb5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431064]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b41]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b901]\n??:? runModuleUnitTests [0x42c86d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxbjngwtg.d(45): unittest failure\n----------------\n??:? _d_unittestp [0x428975]\n??:? void tmpxbjngwtg.__unittest_L41_C1() [0x428125]\n??:? void tmpxbjngwtg.__modtest() [0x4286f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b4d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ffc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b899]\n??:? runModuleUnitTests [0x42c805]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpba9xo0ub.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpba9xo0ub.tri(long) [0x4280ce]\n??:? void tmpba9xo0ub.__unittest_L44_C1() [0x4281df]\n??:? void tmpba9xo0ub.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyc_fzsn9.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpyc_fzsn9.tri(long) [0x428000]\n??:? void tmpyc_fzsn9.__unittest_L37_C1() [0x428037]\n??:? void tmpyc_fzsn9.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n + 1; i < result.length; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpdhs3xnha.d(32): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\n/tmp/tmpdhs3xnha.d(40): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdhs3xnha.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[2] = 1;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpz0rnv482.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428965]\n??:? void tmpz0rnv482.__unittest_L47_C1() [0x428115]\n??:? void tmpz0rnv482.__modtest() [0x4286e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca1f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8b2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b3d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fec]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b889]\n??:? runModuleUnitTests [0x42c7f5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e28]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 2; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 2; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmppsb_k79f.d(32): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\n/tmp/tmppsb_k79f.d(37): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppsb_k79f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    } else {\n        result[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpc8csy835.d(46): unittest failure\n----------------\n??:? _d_unittestp [0x428975]\n??:? void tmpc8csy835.__unittest_L42_C1() [0x428125]\n??:? void tmpc8csy835.__modtest() [0x4286f8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca2f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8c2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b4d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ffc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ad9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b899]\n??:? runModuleUnitTests [0x42c805]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e38]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n < 2) return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[2] = 1;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpv6_3xy8t.d(50): unittest failure\n----------------\n??:? _d_unittestp [0x42894d]\n??:? void tmpv6_3xy8t.__unittest_L46_C1() [0x4280fd]\n??:? void tmpv6_3xy8t.__modtest() [0x4286d0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b89a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fd4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ab1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b871]\n??:? runModuleUnitTests [0x42c7dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    else\n    {\n        result[2] = 1 + result[1] + result[2];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpqbidda28.d(53): unittest failure\n----------------\n??:? _d_unittestp [0x4289ad]\n??:? void tmpqbidda28.__unittest_L49_C1() [0x428159]\n??:? void tmpqbidda28.__modtest() [0x42872c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431034]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430b11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8d1]\n??:? runModuleUnitTests [0x42c83d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e70]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 2; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "/tmp/tmplsl5zzgm.d(32): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\n/tmp/tmplsl5zzgm.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplsl5zzgm.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 1;\n    result[1] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[2] = 2;\n        for (int i = 3; i < n + 1; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    else\n    {\n        result[2] = 1;\n        for (int i = 3; i < n + 1; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmh3bnp89.d(51): unittest failure\n----------------\n??:? _d_unittestp [0x428985]\n??:? void tmpmh3bnp89.__unittest_L47_C1() [0x428131]\n??:? void tmpmh3bnp89.__modtest() [0x428704]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca3f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8d2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b5d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x43100c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ae9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b8a9]\n??:? runModuleUnitTests [0x42c815]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e48]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpjtcen0qy.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpjtcen0qy.tri(long) [0x428000]\n??:? void tmpjtcen0qy.__unittest_L43_C1() [0x428037]\n??:? void tmpjtcen0qy.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    if (n == 0)\n        return res;\n    if (n == 1)\n        return new long[]{1, 3};\n    if (n == 2)\n        return new long[]{1, 2, 3};\n    if (n % 2 == 0)\n        res[0] = 1;\n    for (int i = 1; i < n; i++)\n        res[i] = 1 + (i / 2);\n    for (int i = 0; i < n; i++)\n        res[i] = res[i] + res[i + 1] + res[i + 2];\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp5qq2o6nj.d(28): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp5qq2o6nj.d(28): Error: found `}` when expecting `;` following statement\n/tmp/tmp5qq2o6nj.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp5qq2o6nj.d(30): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp5qq2o6nj.d(30): Error: found `}` when expecting `;` following statement\n/tmp/tmp5qq2o6nj.d(30): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5qq2o6nj.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n must be non-negative\");\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n < 2)\n        return result;\n    long[] prev = result;\n    result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = prev[i - 1] + prev[i - 2] + prev[i - 3];\n        prev = result;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpskao7out.d(25): Error: undefined identifier `IllegalArgumentException`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpskao7out.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    for (int i = 2; i < n + 1; i++)\n        result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpqgl238iz.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpqgl238iz.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpqgl238iz.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpqgl238iz.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpqgl238iz.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpqgl238iz.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqgl238iz.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    else\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp1426vd8k.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289a6]\n??:? long[] tmp1426vd8k.tri(long) [0x427ff7]\n??:? void tmp1426vd8k.__unittest_L38_C1() [0x42802b]\n??:? void tmp1426vd8k.__modtest() [0x428678]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9af]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b842]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430acd]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f7c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a59]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b819]\n??:? runModuleUnitTests [0x42c785]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyc_fzsn9.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpyc_fzsn9.tri(long) [0x428000]\n??:? void tmpyc_fzsn9.__unittest_L37_C1() [0x428037]\n??:? void tmpyc_fzsn9.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp79zhkph_.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmp79zhkph_.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp79zhkph_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpuqzq64pq.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpuqzq64pq.tri(long) [0x428000]\n??:? void tmpuqzq64pq.__unittest_L43_C1() [0x428037]\n??:? void tmpuqzq64pq.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n + 1; i < result.length; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n + 1; i < result.length; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp0y9yjdle.d(32): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\n/tmp/tmp0y9yjdle.d(37): Error: cannot implicitly convert expression `n + 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0y9yjdle.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmparvewijb.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428afe]\n??:? long[] tmparvewijb.tri(long) [0x428093]\n??:? void tmparvewijb.__unittest_L43_C1() [0x42817f]\n??:? void tmparvewijb.__modtest() [0x4287cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb07]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b99a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310d4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bb1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b971]\n??:? runModuleUnitTests [0x42c8dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    if (n == 0)\n        return res;\n    if (n == 1)\n        return new long[] {1, 3};\n    if (n == 2)\n        return new long[] {1, 2, 3};\n    if (n % 2 == 0)\n        res[0] = 1;\n    else\n        res[0] = 3;\n    for (int i = 1; i < n; i++)\n        res[i] = 1 + (i / 2) + res[i - 1] + res[i - 2] + res[i + 1];\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpivyp20yt.d(28): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpivyp20yt.d(28): Error: found `}` when expecting `;` following statement\n/tmp/tmpivyp20yt.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpivyp20yt.d(30): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpivyp20yt.d(30): Error: found `}` when expecting `;` following statement\n/tmp/tmpivyp20yt.d(30): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpivyp20yt.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp0mo9t19f.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmp0mo9t19f.__unittest_L40_C1() [0x4280bd]\n??:? void tmp0mo9t19f.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b85a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a71]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b831]\n??:? runModuleUnitTests [0x42c79d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp7uf3cx3f.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmp7uf3cx3f.__unittest_L33_C1() [0x427fe5]\n??:? void tmp7uf3cx3f.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpeik4gnk9.d(48): unittest failure\n----------------\n??:? _d_unittestp [0x428a7d]\n??:? void tmpeik4gnk9.__unittest_L44_C1() [0x42822d]\n??:? void tmpeik4gnk9.__modtest() [0x428800]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb37]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9ca]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c55]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431104]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430be1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9a1]\n??:? runModuleUnitTests [0x42c90d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428f40]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpuzwv589b.d(42): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmpuzwv589b.tri(long) [0x4280a8]\n??:? void tmpuzwv589b.__unittest_L50_C1() [0x428193]\n??:? void tmpuzwv589b.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i >= 2; i--)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i >= 2; i--)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpav8gr9a4.d(33): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpav8gr9a4.d(41): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpav8gr9a4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n must be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n        for (int i = 2; i < n; i++)\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n    else\n        for (int i = 2; i < n; i++)\n            result[i] = result[i - 2] + result[i - 1] + result[i - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpp_5ds5tf.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpp_5ds5tf.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpp_5ds5tf.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpp_5ds5tf.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpp_5ds5tf.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpp_5ds5tf.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpp_5ds5tf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp6cr1p91k.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmp6cr1p91k.d(38): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6cr1p91k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\npublic class Tribonacci {\n    public static void main(String[] args) {\n        long n = 3L;\n        long[] result = tri(n);\n        for (long i = 0; i < result.length; i++) {\n            System.out.print(result[i] + \" \");\n        }\n        System.out.println();\n    }\n}\n\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpty9fya24.d(42): Error: identifier expected following `.`, not `out`\n/tmp/tmpty9fya24.d(44): Error: identifier expected following `.`, not `out`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpty9fya24.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n must be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n    {\n        for (int i = 2; i < n; i++)\n        {\n            result[i] = 1L + (i / 2);\n        }\n    }\n    else\n    {\n        for (int i = 2; i < n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpjg0yk2dc.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpjg0yk2dc.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpjg0yk2dc.d(29): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpjg0yk2dc.d(31): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpjg0yk2dc.d(31): Error: found `}` when expecting `;` following statement\n/tmp/tmpjg0yk2dc.d(31): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjg0yk2dc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpn861obm7.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpn861obm7.tri(long) [0x428000]\n??:? void tmpn861obm7.__unittest_L37_C1() [0x428037]\n??:? void tmpn861obm7.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i > 1; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpotal0umo.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpotal0umo.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpotal0umo.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpkhf08z4x.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b0e]\n??:? long[] tmpkhf08z4x.tri(long) [0x4280a8]\n??:? void tmpkhf08z4x.__unittest_L46_C1() [0x428193]\n??:? void tmpkhf08z4x.__modtest() [0x4287e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4310e4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430bc1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b981]\n??:? runModuleUnitTests [0x42c8ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if(n == 0)\n        return new long[0];\n    if(n == 1)\n        return new long[]{1L, 3L};\n    if(n == 2)\n        return new long[]{1L, 2L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if(n % 2 == 0)\n        for(int i = 2; i < n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    else\n        for(int i = 2; i < n; i++)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp3u32iqy_.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3u32iqy_.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmp3u32iqy_.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp3u32iqy_.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3u32iqy_.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmp3u32iqy_.d(29): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3u32iqy_.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 1)\n        throw new Error(\"n should be positive\");\n    if (n == 1)\n        return new long[] {1L, 3L, 2L, 8L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    result[2] = 2L;\n    result[3] = 8L;\n    for (int i = 4; i < n + 1; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpsn5e2w09.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpsn5e2w09.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmpsn5e2w09.d(27): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsn5e2w09.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    if (n == 0)\n        return new long[0];\n    if (n == 1)\n        return new long[] {1L, 3L, 2L, 8L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n    {\n        for (int i = 2; i < n; i += 2)\n        {\n            result[i] = result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    else\n    {\n        for (int i = 2; i < n; i += 2)\n        {\n            result[i] = result[i - 2] + result[i - 1] + result[i + 1];\n        }\n        result[n] = result[n - 2] + result[n - 1] + result[1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpt56667tc.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpt56667tc.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmpt56667tc.d(29): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt56667tc.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpmx0jc4vs.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmpmx0jc4vs.__unittest_L40_C1() [0x4280bd]\n??:? void tmpmx0jc4vs.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b85a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a71]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b831]\n??:? runModuleUnitTests [0x42c79d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n    else\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpyxi6m2bx.d(42): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmpyxi6m2bx.__unittest_L38_C1() [0x4280bd]\n??:? void tmpyxi6m2bx.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b85a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a71]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b831]\n??:? runModuleUnitTests [0x42c79d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpuy3615su.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpuy3615su.__unittest_L34_C1() [0x427fe5]\n??:? void tmpuy3615su.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpro5i7le_.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b7e]\n??:? long[] tmpro5i7le_.tri(long) [0x4280de]\n??:? void tmpro5i7le_.__unittest_L44_C1() [0x4281ff]\n??:? void tmpro5i7le_.__modtest() [0x42884c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb87]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba1a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ca5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431154]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c31]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9f1]\n??:? runModuleUnitTests [0x42c95d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++)\n        {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 1] + result[i - 2] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp6kfbm8oi.d(40): Range violation\n----------------\n??:? _d_arrayboundsp [0x428bce]\n??:? long[] tmp6kfbm8oi.tri(long) [0x428105]\n??:? void tmp6kfbm8oi.__unittest_L48_C1() [0x42824f]\n??:? void tmp6kfbm8oi.__modtest() [0x42889c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cbd7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42ba6a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430cf5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x4311a4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c81]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42ba41]\n??:? runModuleUnitTests [0x42c9ad]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428fe0]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    if (n == 0) return res;\n    if (n == 1) return new long[]{1L, 3L};\n    if (n == 2) return new long[]{1L, 2L, 3L};\n    if (n == 3) return new long[]{1L, 1L, 1L, 3L};\n    if (n % 2 == 0)\n    {\n        res[0] = 1L;\n        res[1] = 3L;\n        for (int i = 2; i < n; i++)\n        {\n            res[i] = 1L + (i / 2);\n        }\n    }\n    else\n    {\n        res[0] = 1L;\n        res[1] = 2L;\n        for (int i = 2; i < n; i++)\n        {\n            res[i] = 1L + (i - 1) / 2 + (i - 2) / 2 + (i + 1) / 2;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmplvnijl2k.d(26): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmplvnijl2k.d(26): Error: found `}` when expecting `;` following statement\n/tmp/tmplvnijl2k.d(26): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmplvnijl2k.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmplvnijl2k.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmplvnijl2k.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmplvnijl2k.d(28): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmplvnijl2k.d(28): Error: found `}` when expecting `;` following statement\n/tmp/tmplvnijl2k.d(28): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplvnijl2k.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n < 2) return result;\n    if (n % 2 == 0) {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i];\n        }\n    } else {\n        for (int i = 3; i <= n; i += 2) {\n            result[i] = result[i - 2] + result[i - 1] + result[i - 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpe9yy2lvw.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x42895d]\n??:? void tmpe9yy2lvw.__unittest_L40_C1() [0x428109]\n??:? void tmpe9yy2lvw.__modtest() [0x4286dc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42ca17]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b8aa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430b35]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430ac1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b881]\n??:? runModuleUnitTests [0x42c7ed]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428e20]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpuqzq64pq.d(39): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpuqzq64pq.tri(long) [0x428000]\n??:? void tmpuqzq64pq.__unittest_L43_C1() [0x428037]\n??:? void tmpuqzq64pq.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 3) return result;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpypshk1dl.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42884d]\n??:? void tmpypshk1dl.__unittest_L35_C1() [0x427ff9]\n??:? void tmpypshk1dl.__modtest() [0x4285cc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c907]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b79a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a25]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ed4]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309b1]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b771]\n??:? runModuleUnitTests [0x42c6dd]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428d10]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp6kmc65x5.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmp6kmc65x5.tri(long) [0x428000]\n??:? void tmp6kmc65x5.__unittest_L41_C1() [0x428037]\n??:? void tmp6kmc65x5.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyc_fzsn9.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpyc_fzsn9.tri(long) [0x428000]\n??:? void tmpyc_fzsn9.__unittest_L37_C1() [0x428037]\n??:? void tmpyc_fzsn9.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = 3; i <= n; i++) {\n            result[i] = result[i - 1] + result[i - 2] + result[i - 3] + result[i + 1];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpyzu_ky26.d(36): Range violation\n----------------\n??:? _d_arrayboundsp [0x428b5e]\n??:? long[] tmpyzu_ky26.tri(long) [0x4280ce]\n??:? void tmpyzu_ky26.__unittest_L43_C1() [0x4281df]\n??:? void tmpyzu_ky26.__modtest() [0x42882c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42cb67]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b9fa]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430c85]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x431134]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430c11]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b9d1]\n??:? runModuleUnitTests [0x42c93d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n == 0) return new long[0];\n    if (n == 1) return new long[]{1L};\n    if (n == 2) return new long[]{1L, 3L};\n    long[] res = new long[n + 1];\n    res[0] = 1L;\n    res[1] = 3L;\n    if (n % 2 == 0) {\n        for (int i = 2; i < n; i++) {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    } else {\n        for (int i = 2; i < n; i++) {\n            res[i] = res[i - 1] + res[i - 2] + res[i + 1];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpts472rgg.d(25): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpts472rgg.d(25): Error: found `}` when expecting `;` following statement\n/tmp/tmpts472rgg.d(25): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpts472rgg.d(26): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpts472rgg.d(26): Error: found `}` when expecting `;` following statement\n/tmp/tmpts472rgg.d(26): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpts472rgg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++)\n    {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpbkeovqzt.d(38): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpbkeovqzt.__unittest_L34_C1() [0x427fe5]\n??:? void tmpbkeovqzt.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n < 2) return result;\n    long[] prev = tri(n - 1);\n    long[] next = tri(n - 2);\n    for (int i = 3; i <= n; i++) {\n        result[i] = prev[i - 1] + next[i - 2] + prev[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpz54zvpo5.d(27): Range violation\n----------------\n??:? _d_arrayboundsp [0x428946]\n??:? long[] tmpz54zvpo5.tri(long) [0x427e79]\n??:? long[] tmpz54zvpo5.tri(long) [0x427ea9]\n??:? long[] tmpz54zvpo5.tri(long) [0x427ea9]\n??:? void tmpz54zvpo5.__unittest_L36_C1() [0x427fc7]\n??:? void tmpz54zvpo5.__modtest() [0x428614]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c94f]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b7e2]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a6d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f1c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4309f9]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b7b9]\n??:? runModuleUnitTests ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    if (n == 0)\n        return res;\n    if (n == 1)\n        return new long[]{1L, 3L};\n    if (n == 2)\n        return new long[]{1L, 2L, 3L};\n    if (n % 2 == 0)\n        res[0] = 1L;\n    for (int i = 1; i < n; i++)\n        res[i] = 1L + (i / 2) + res[i - 1] + res[i - 2];\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmplbhj2aft.d(28): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmplbhj2aft.d(28): Error: found `}` when expecting `;` following statement\n/tmp/tmplbhj2aft.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmplbhj2aft.d(30): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmplbhj2aft.d(30): Error: found `}` when expecting `;` following statement\n/tmp/tmplbhj2aft.d(30): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplbhj2aft.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 0)\n        throw new IllegalArgumentException(\"n should be non-negative\");\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 2; i >= 1; i--)\n            result[i] = result[i + 1] + result[i];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 2; i >= 1; i--)\n            result[i] = result[i + 1] + result[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpu8rgoaew.d(25): Error: undefined identifier `IllegalArgumentException`\n/tmp/tmpu8rgoaew.d(37): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\n/tmp/tmpu8rgoaew.d(43): Error: cannot implicitly convert expression `n - 2L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu8rgoaew.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpgscv1xdl.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpgscv1xdl.tri(long) [0x428000]\n??:? void tmpgscv1xdl.__unittest_L37_C1() [0x428037]\n??:? void tmpgscv1xdl.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpn0h4jh2m.d(37): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpn0h4jh2m.tri(long) [0x428000]\n??:? void tmpn0h4jh2m.__unittest_L40_C1() [0x428037]\n??:? void tmpn0h4jh2m.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    for (int i = 3; i <= n; i++) {\n        result[i] = result[i - 1] + result[i - 2] + result[i - 3];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293175,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpgugfsn5l.d(37): unittest failure\n----------------\n??:? _d_unittestp [0x428835]\n??:? void tmpgugfsn5l.__unittest_L33_C1() [0x427fe5]\n??:? void tmpgugfsn5l.__modtest() [0x4285b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c8ef]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b782]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430a0d]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430ebc]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430999]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b759]\n??:? runModuleUnitTests [0x42c6c5]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428cf8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 1; i >= 2; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    } else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 1; i >= 2; i--) {\n            result[i] = result[i - 1] + result[i - 2] + result[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpdxeity2f.d(32): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmpdxeity2f.d(37): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdxeity2f.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n == 0) return new long[0];\n    if (n == 1) return new long[]{1L, 3L};\n    if (n == 2) return new long[]{1L, 2L, 3L};\n    long[] ret = new long[n + 1];\n    ret[0] = 1L;\n    ret[1] = 3L;\n    if (n % 2 == 0)\n    {\n        for (int i = 2; i < n; i++)\n        {\n            ret[i] = 1L + (i / 2);\n        }\n    }\n    else\n    {\n        for (int i = 2; i < n; i++)\n        {\n            ret[i] = ret[i - 1] + ret[i - 2] + ret[i + 1];\n        }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpqz0w0oki.d(25): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpqz0w0oki.d(25): Error: found `}` when expecting `;` following statement\n/tmp/tmpqz0w0oki.d(25): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmpqz0w0oki.d(26): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmpqz0w0oki.d(26): Error: found `}` when expecting `;` following statement\n/tmp/tmpqz0w0oki.d(26): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqz0w0oki.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n - 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6r5pe139.d(44): unittest failure\n----------------\n??:? _d_unittestp [0x428905]\n??:? void tmp6r5pe139.__unittest_L40_C1() [0x4280b5]\n??:? void tmp6r5pe139.__modtest() [0x428688]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dc8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpn8quancr.d(41): unittest failure\n----------------\n??:? _d_unittestp [0x42890d]\n??:? void tmpn8quancr.__unittest_L37_C1() [0x4280bd]\n??:? void tmpn8quancr.__modtest() [0x428690]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9c7]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b85a]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430ae5]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f94]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a71]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b831]\n??:? runModuleUnitTests [0x42c79d]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428dd0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 2;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 2] + result[n - 1] + result[n];\n        for (int i = n - 3; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    else {\n        result[n] = result[n - 1] + result[n - 2] + result[n];\n        for (int i = n - 3; i >= 0; i--) {\n            result[i] = result[i + 1] + result[i + 2] + result[i + 3];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmpfam5181o.d(32): Error: cannot implicitly convert expression `n - 3L` of type `long` to `int`\n/tmp/tmpfam5181o.d(38): Error: cannot implicitly convert expression `n - 3L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfam5181o.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] res = new long[n + 1];\n    if (n == 0)\n        return res;\n    if (n == 1)\n        return new long[] {1L, 3L};\n    if (n == 2)\n        return new long[] {1L, 2L, 3L};\n    if (n % 2 == 0)\n        res[0] = 1L;\n    else\n        res[0] = 3L;\n    for (int i = 1; i < n; i++)\n        res[i] = 1L + i / 2L + res[i - 1] + res[i - 2] + res[i + 1];\n    return res;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp4b34jjtu.d(28): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp4b34jjtu.d(28): Error: found `}` when expecting `;` following statement\n/tmp/tmp4b34jjtu.d(28): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp4b34jjtu.d(30): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp4b34jjtu.d(30): Error: found `}` when expecting `;` following statement\n/tmp/tmp4b34jjtu.d(30): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4b34jjtu.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0)\n        return result;\n    if (n == 1)\n        return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i >= 2; i--)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    else\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        for (int i = n - 1; i >= 2; i--)\n            result[i] = result[i - 1] + result[i - 2] + result[i + 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp8fjvo0gf.d(35): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\n/tmp/tmp8fjvo0gf.d(41): Error: cannot implicitly convert expression `n - 1L` of type `long` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8fjvo0gf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 1;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0)\n    {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293177,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpqvj0fhdq.d(35): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpqvj0fhdq.tri(long) [0x428000]\n??:? void tmpqvj0fhdq.__unittest_L38_C1() [0x428037]\n??:? void tmpqvj0fhdq.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    long[] result = new long[n + 1];\n    result[0] = 0;\n    result[1] = 1;\n    result[2] = 3;\n    if (n == 0) return result;\n    if (n == 1) return result;\n    if (n % 2 == 0) {\n        result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n        return result;\n    }\n    result[n] = result[n - 1] + result[n - 2] + result[n + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpn861obm7.d(34): Range violation\n----------------\n??:? _d_arrayboundsp [0x4289b6]\n??:? long[] tmpn861obm7.tri(long) [0x428000]\n??:? void tmpn861obm7.__unittest_L37_C1() [0x428037]\n??:? void tmpn861obm7.__modtest() [0x428684]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c9bf]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b852]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430add]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430f8c]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430a69]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b829]\n??:? runModuleUnitTests [0x42c795]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return an array of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    >>> tri(3L)\n    [1L, 3L, 2L, 8L]\n    \n*/\nlong[] tri(long n) \n{\n    if (n < 1)\n        return new long[0];\n    if (n == 1)\n        return new long[]{1L};\n    if (n == 2)\n        return new long[]{1L, 3L};\n    long[] result = new long[n + 1];\n    result[0] = 1L;\n    result[1] = 3L;\n    if (n % 2 == 0)\n        for (int i = 2; i < n; i += 2)\n            result[i] = result[i - 2] + result[i - 1] + result[i + 1];\n    else\n        for (int i = 2; i < n; i += 2)\n            result[i] = result[i - 2] + result[i - 1] + result[i + 1];\n    return result;\n}\nunittest\n{\n    alias candidate = tri;\n\n    assert(candidate(3L) == [1L, 3L, 2L, 8L]);\n    assert(candidate(4L) == [1L, 3L, 2L, 8L, 3L]);\n    assert(candidate(5L) == [1L, 3L, 2L, 8L, 3L, 15L]);\n    assert(candidate(6L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L]);\n    assert(candidate(7L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L]);\n    assert(candidate(8L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L]);\n    assert(candidate(9L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L]);\n    assert(candidate(20L) == [1L, 3L, 2L, 8L, 3L, 15L, 4L, 24L, 5L, 35L, 6L, 48L, 7L, 63L, 8L, 80L, 9L, 99L, 10L, 120L, 11L]);\n    assert(candidate(0L) == [1L]);\n    assert(candidate(1L) == [1L, 3L]);\n}\nvoid main(){}",
      "timestamp": 1664293176,
      "stdout": "",
      "stderr": "/tmp/tmp3z1z6z9a.d(27): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3z1z6z9a.d(27): Error: found `}` when expecting `;` following statement\n/tmp/tmp3z1z6z9a.d(27): Deprecation: use `{ }` for an empty statement, not `;`\n/tmp/tmp3z1z6z9a.d(29): Error: found `{` when expecting `;` following `return` statement\n/tmp/tmp3z1z6z9a.d(29): Error: found `}` when expecting `;` following statement\n/tmp/tmp3z1z6z9a.d(29): Deprecation: use `{ }` for an empty statement, not `;`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3z1z6z9a.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}