{
  "name": "HumanEval_9_rolling_max",
  "language": "d",
  "prompt": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n",
  "tests": "unittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
  "stop_tokens": [
    "\n\n",
    "\nvoid",
    "\nbool",
    "\nint"
  ],
  "results": [
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmppxxdt64r.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmppxxdt64r.rolling_max(long[]) [0x427e62]\n??:? void tmppxxdt64r.__unittest_L19_C1() [0x427fae]\n??:? void tmppxxdt64r.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++) {\n            if(numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxx1iwlon.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpxx1iwlon.__unittest_L23_C1() [0x4280a9]\n??:? void tmpxx1iwlon.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(long n : numbers)\n    {\n        result[i] = n;\n        i++;\n        if(i == numbers.length)\n        {\n            i = 0;\n        }\n        else\n        {\n            result[i] = Math.max(result[i], numbers[i]);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpjh1asj84.d(14): Error: semicolon expected, not `:`\n/tmp/tmpjh1asj84.d(14): Error: expression expected, not `:`\n/tmp/tmpjh1asj84.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjh1asj84.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > numbers[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9_dm7g_4.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42851d]\n??:? void tmp9_dm7g_4.__unittest_L23_C1() [0x4280a1]\n??:? void tmp9_dm7g_4.__modtest() [0x4282a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmphokrqrqr.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmphokrqrqr.rolling_max(long[]) [0x427e62]\n??:? void tmphokrqrqr.__unittest_L22_C1() [0x427f4a]\n??:? void tmphokrqrqr.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmphokrqrqr.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmphokrqrqr.rolling_max(long[]) [0x427e62]\n??:? void tmphokrqrqr.__unittest_L22_C1() [0x427f4a]\n??:? void tmphokrqrqr.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long max = numbers[0];\n    for(i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n            j = i;\n        }\n    }\n    result[0] = max;\n    for(i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n            j = i;\n        }\n        else\n        {\n            result[i] = max;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpsd91xll0.d(15): Range violation\n----------------\n??:? _d_arrayboundsp [0x428606]\n??:? long[] tmpsd91xll0.rolling_max(long[]) [0x427e67]\n??:? void tmpsd91xll0.__unittest_L39_C1() [0x427fea]\n??:? void tmpsd91xll0.__modtest() [0x4282d8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c633]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4c6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430751]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c00]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306dd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b49d]\n??:? runModuleUnitTests [0x42c409]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i - 1; j >= 0; j--)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long n : numbers) {\n        result[i++] = Math.max(n, result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpgyvquhe0.d(14): Error: semicolon expected, not `:`\n/tmp/tmpgyvquhe0.d(14): Error: expression expected, not `:`\n/tmp/tmpgyvquhe0.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgyvquhe0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i - 1; j >= 0; j--)\n        {\n            if(numbers[j] > numbers[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++) {\n            if(numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxx1iwlon.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpxx1iwlon.__unittest_L23_C1() [0x4280a9]\n??:? void tmpxx1iwlon.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    while(i < numbers.length)\n    {\n        result[i] = numbers[i];\n        for(int j = i+1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmph962h5fe.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmph962h5fe.__unittest_L28_C1() [0x4280a9]\n??:? void tmph962h5fe.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long number : numbers) {\n        if (i == 0) {\n            result[i] = number;\n        } else {\n            if (number > result[i - 1]) {\n                result[i] = number;\n            } else {\n                result[i] = result[i - 1];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmp_fztit_m.d(14): Error: semicolon expected, not `:`\n/tmp/tmp_fztit_m.d(14): Error: expression expected, not `:`\n/tmp/tmp_fztit_m.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_fztit_m.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(long number : numbers)\n    {\n        result[i++] = number;\n        if(i == numbers.length)\n        {\n            i = 0;\n        }\n        else\n        {\n            result[i] = Math.max(result[i], numbers[i]);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpt3wnhuwe.d(14): Error: semicolon expected, not `:`\n/tmp/tmpt3wnhuwe.d(14): Error: expression expected, not `:`\n/tmp/tmpt3wnhuwe.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt3wnhuwe.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n    }\n    result[0] = numbers[max_index];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpxiv4u5cd.d(21): Range violation\n----------------\n??:? _d_arrayboundsp [0x42860e]\n??:? long[] tmpxiv4u5cd.rolling_max(long[]) [0x427eca]\n??:? void tmpxiv4u5cd.__unittest_L32_C1() [0x427ff2]\n??:? void tmpxiv4u5cd.__modtest() [0x4282e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c63b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a5]\n??:? runModuleUnitTests [0x42c411]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp5eqypppg.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5eqypppg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[i] > numbers[j])\n                result[i] = numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp97x86_9s.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428535]\n??:? void tmp97x86_9s.__unittest_L25_C1() [0x428156]\n??:? void tmp97x86_9s.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c613]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430731]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b47d]\n??:? runModuleUnitTests [0x42c3e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i+1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr_0cr_7o.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpr_0cr_7o.__unittest_L26_C1() [0x4280a9]\n??:? void tmpr_0cr_7o.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n                result[i] = numbers[j];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdl2md0au.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpdl2md0au.__unittest_L24_C1() [0x4280a9]\n??:? void tmpdl2md0au.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i - 1; j >= 0; j--) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpjuuzw4os.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428616]\n??:? long[] tmpjuuzw4os.rolling_max(long[]) [0x427e62]\n??:? void tmpjuuzw4os.__unittest_L24_C1() [0x427ff6]\n??:? void tmpjuuzw4os.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i - 1; j >= 0; j--) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpjuuzw4os.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428616]\n??:? long[] tmpjuuzw4os.rolling_max(long[]) [0x427e62]\n??:? void tmpjuuzw4os.__unittest_L24_C1() [0x427ff6]\n??:? void tmpjuuzw4os.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i - 1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp5eqypppg.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5eqypppg.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    \n    for (i = 0; i < numbers.length; i++) {\n        for (j = 0; j < numbers.length - i; j++) {\n            if (numbers[j] < numbers[j+1]) {\n                result[j] = numbers[j];\n            } else {\n                result[j] = numbers[j+1];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp8_w8_n5w.d(18): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285e6]\n??:? long[] tmp8_w8_n5w.rolling_max(long[]) [0x427ec8]\n??:? void tmp8_w8_n5w.__unittest_L27_C1() [0x42804e]\n??:? void tmp8_w8_n5w.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c613]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430731]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b47d]\n??:? runModuleUnitTests [0x42c3e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpdmj5qxse.d(16): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdmj5qxse.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i - 1] ? numbers[i] : result[i - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpqx_ptxfl.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpqx_ptxfl.rolling_max(long[]) [0x427e62]\n??:? void tmpqx_ptxfl.__unittest_L19_C1() [0x427fae]\n??:? void tmpqx_ptxfl.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++) {\n            if(numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxx1iwlon.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpxx1iwlon.__unittest_L23_C1() [0x4280a9]\n??:? void tmpxx1iwlon.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++) {\n            if(numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxx1iwlon.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpxx1iwlon.__unittest_L23_C1() [0x4280a9]\n??:? void tmpxx1iwlon.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmplm5rcokx.d(16): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplm5rcokx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmphokrqrqr.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmphokrqrqr.rolling_max(long[]) [0x427e62]\n??:? void tmphokrqrqr.__unittest_L22_C1() [0x427f4a]\n??:? void tmphokrqrqr.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    while (i < numbers.length) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdv_7mw0r.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpdv_7mw0r.__unittest_L25_C1() [0x4280a9]\n??:? void tmpdv_7mw0r.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i - 1; j >= 0; j--) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpjuuzw4os.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428616]\n??:? long[] tmpjuuzw4os.rolling_max(long[]) [0x427e62]\n??:? void tmpjuuzw4os.__unittest_L24_C1() [0x427ff6]\n??:? void tmpjuuzw4os.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[i] > numbers[j])\n            {\n                result[i] = numbers[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp90b1qdpe.d(34): unittest failure\n----------------\n??:? _d_unittestp [0x42853d]\n??:? void tmp90b1qdpe.__unittest_L28_C1() [0x42815a]\n??:? void tmp90b1qdpe.__modtest() [0x4282bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c61b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430739]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b485]\n??:? runModuleUnitTests [0x42c3f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp56s64m9h.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp56s64m9h.rolling_max(long[]) [0x427e62]\n??:? void tmp56s64m9h.__unittest_L22_C1() [0x427f4a]\n??:? void tmp56s64m9h.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpo2l9v8ia.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpo2l9v8ia.rolling_max(long[]) [0x427e62]\n??:? void tmpo2l9v8ia.__unittest_L20_C1() [0x427fae]\n??:? void tmpo2l9v8ia.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp89vgsn0e.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp89vgsn0e.rolling_max(long[]) [0x427e62]\n??:? void tmp89vgsn0e.__unittest_L24_C1() [0x427f4a]\n??:? void tmp89vgsn0e.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    while(i < numbers.length)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp08lq_rme.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmp08lq_rme.__unittest_L28_C1() [0x4280a9]\n??:? void tmp08lq_rme.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[i] > numbers[j])\n                result[i] = numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpp5tfnfoq.d(32): unittest failure\n----------------\n??:? _d_unittestp [0x428535]\n??:? void tmpp5tfnfoq.__unittest_L26_C1() [0x428156]\n??:? void tmpp5tfnfoq.__modtest() [0x4282b8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c613]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430731]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b47d]\n??:? runModuleUnitTests [0x42c3e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n                result[i] = numbers[j];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpdl2md0au.d(29): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpdl2md0au.__unittest_L24_C1() [0x4280a9]\n??:? void tmpdl2md0au.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long n : numbers) {\n        result[i++] = Math.max(n, result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpgyvquhe0.d(14): Error: semicolon expected, not `:`\n/tmp/tmpgyvquhe0.d(14): Error: expression expected, not `:`\n/tmp/tmpgyvquhe0.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgyvquhe0.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long number : numbers)\n    {\n        if (i == 0)\n        {\n            result[i] = number;\n        }\n        else\n        {\n            if (number > result[i - 1])\n            {\n                result[i] = number;\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpr5ia1hz9.d(14): Error: semicolon expected, not `:`\n/tmp/tmpr5ia1hz9.d(14): Error: expression expected, not `:`\n/tmp/tmpr5ia1hz9.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr5ia1hz9.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++) {\n            if(numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpxx1iwlon.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpxx1iwlon.__unittest_L23_C1() [0x4280a9]\n??:? void tmpxx1iwlon.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long number : numbers) {\n        result[i] = Math.max(number, result[i]);\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp26rgwgz4.d(14): Error: semicolon expected, not `:`\n/tmp/tmp26rgwgz4.d(14): Error: expression expected, not `:`\n/tmp/tmp26rgwgz4.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp26rgwgz4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    while(i < numbers.length)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp08lq_rme.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmp08lq_rme.__unittest_L28_C1() [0x4280a9]\n??:? void tmp08lq_rme.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[j] < numbers[i])\n                result[i] = numbers[j];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp6pnav26j.d(30): unittest failure\n----------------\n??:? _d_unittestp [0x42852d]\n??:? void tmp6pnav26j.__unittest_L25_C1() [0x4280b1]\n??:? void tmp6pnav26j.__modtest() [0x4282b0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c60b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b49e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430729]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306b5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b475]\n??:? runModuleUnitTests [0x42c3e1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpo2l9v8ia.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpo2l9v8ia.rolling_max(long[]) [0x427e62]\n??:? void tmpo2l9v8ia.__unittest_L20_C1() [0x427fae]\n??:? void tmpo2l9v8ia.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpdmj5qxse.d(16): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdmj5qxse.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    int max_index = 0;\n    \n    for (i = 0; i < numbers.length; i++) {\n        if (j == 0) {\n            result[i] = numbers[i];\n        } else {\n            if (numbers[i] > result[max_index]) {\n                result[i] = numbers[i];\n                max_index = i;\n            }\n        }\n        j++;\n        if (j == numbers.length) {\n            j = 0;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpftj5nkmu.d(39): unittest failure\n----------------\n??:? _d_unittestp [0x42853d]\n??:? void tmpftj5nkmu.__unittest_L33_C1() [0x42815a]\n??:? void tmpftj5nkmu.__modtest() [0x4282bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c61b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430739]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b485]\n??:? runModuleUnitTests [0x42c3f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpdmj5qxse.d(16): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdmj5qxse.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpt0fvd2hn.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt0fvd2hn.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp56s64m9h.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp56s64m9h.rolling_max(long[]) [0x427e62]\n??:? void tmp56s64m9h.__unittest_L22_C1() [0x427f4a]\n??:? void tmp56s64m9h.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n    }\n    result[0] = numbers[max_index];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[max_index];\n        max_index = (max_index + 1) % numbers.length;\n        if (numbers[max_index] > numbers[i]) {\n            result[i] = numbers[max_index];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp9lmlqf4g.d(22): Error: cannot implicitly convert expression `cast(ulong)(max_index + 1) % numbers.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9lmlqf4g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmphokrqrqr.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmphokrqrqr.rolling_max(long[]) [0x427e62]\n??:? void tmphokrqrqr.__unittest_L22_C1() [0x427f4a]\n??:? void tmphokrqrqr.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(long number : numbers)\n    {\n        result[i] = Math.max(number, result[i]);\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp5j0ovzv4.d(14): Error: semicolon expected, not `:`\n/tmp/tmp5j0ovzv4.d(14): Error: expression expected, not `:`\n/tmp/tmp5j0ovzv4.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5j0ovzv4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i - 1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpm48ot8gi.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm48ot8gi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmphokrqrqr.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmphokrqrqr.rolling_max(long[]) [0x427e62]\n??:? void tmphokrqrqr.__unittest_L22_C1() [0x427f4a]\n??:? void tmphokrqrqr.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long number : numbers) {\n        result[i++] = Math.max(number, result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp_r6ft6a6.d(14): Error: semicolon expected, not `:`\n/tmp/tmp_r6ft6a6.d(14): Error: expression expected, not `:`\n/tmp/tmp_r6ft6a6.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_r6ft6a6.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpipwic8pm.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmpipwic8pm.rolling_max(long[]) [0x427e62]\n??:? void tmpipwic8pm.__unittest_L22_C1() [0x427f4a]\n??:? void tmpipwic8pm.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp89vgsn0e.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp89vgsn0e.rolling_max(long[]) [0x427e62]\n??:? void tmp89vgsn0e.__unittest_L24_C1() [0x427f4a]\n??:? void tmp89vgsn0e.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp56s64m9h.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp56s64m9h.rolling_max(long[]) [0x427e62]\n??:? void tmp56s64m9h.__unittest_L22_C1() [0x427f4a]\n??:? void tmp56s64m9h.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i + 1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpjrl6mkbq.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpjrl6mkbq.__unittest_L26_C1() [0x4280a9]\n??:? void tmpjrl6mkbq.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] max_numbers = new long[numbers.length];\n    max_numbers[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        max_numbers[i] = Math.max(max_numbers[i-1], numbers[i]);\n    }\n    return max_numbers;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpzwf2mklp.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzwf2mklp.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n    }\n    result[0] = numbers[max_index];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpafrd6xix.d(19): Range violation\n----------------\n??:? _d_arrayboundsp [0x42860e]\n??:? long[] tmpafrd6xix.rolling_max(long[]) [0x427eca]\n??:? void tmpafrd6xix.__unittest_L28_C1() [0x427ff2]\n??:? void tmpafrd6xix.__modtest() [0x4282e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c63b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a5]\n??:? runModuleUnitTests [0x42c411]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n        {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp89vgsn0e.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp89vgsn0e.rolling_max(long[]) [0x427e62]\n??:? void tmp89vgsn0e.__unittest_L24_C1() [0x427f4a]\n??:? void tmp89vgsn0e.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmplm5rcokx.d(16): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplm5rcokx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp56s64m9h.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmp56s64m9h.rolling_max(long[]) [0x427e62]\n??:? void tmp56s64m9h.__unittest_L22_C1() [0x427f4a]\n??:? void tmp56s64m9h.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i+1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpr_0cr_7o.d(31): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpr_0cr_7o.__unittest_L26_C1() [0x4280a9]\n??:? void tmpr_0cr_7o.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long n : numbers)\n    {\n        if (i == 0)\n        {\n            result[i] = n;\n        }\n        else\n        {\n            if (n > result[i - 1])\n            {\n                result[i] = n;\n            }\n            else\n            {\n                result[i] = result[i - 1];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmptrftf06e.d(14): Error: semicolon expected, not `:`\n/tmp/tmptrftf06e.d(14): Error: expression expected, not `:`\n/tmp/tmptrftf06e.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptrftf06e.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n    }\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[max_index];\n        max_index = (max_index + 1) % numbers.length;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpgl40_t15.d(21): Error: cannot implicitly convert expression `cast(ulong)(max_index + 1) % numbers.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgl40_t15.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    int j = 0;\n    long max = numbers[0];\n    \n    for (i = 0; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        \n        if (i == numbers.length - 1) {\n            result[j] = max;\n        }\n        else {\n            result[j] = max;\n            for (j = i + 1; j < numbers.length; j++) {\n                if (numbers[j] > max) {\n                    max = numbers[j];\n                }\n            }\n            result[j] = max;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp5b5ah9yn.d(15): Range violation\n----------------\n??:? _d_arrayboundsp [0x42864e]\n??:? long[] tmp5b5ah9yn.rolling_max(long[]) [0x427e6a]\n??:? void tmp5b5ah9yn.__unittest_L37_C1() [0x42802e]\n??:? void tmp5b5ah9yn.__modtest() [0x42831c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c67b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b50e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430799]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c48]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x430725]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4e5]\n??:? runModuleUnitTests [0x42c451]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmplm5rcokx.d(16): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplm5rcokx.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long number : numbers) {\n        result[i++] = Math.max(result[i-1], number);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp9u9vfae4.d(14): Error: semicolon expected, not `:`\n/tmp/tmp9u9vfae4.d(14): Error: expression expected, not `:`\n/tmp/tmp9u9vfae4.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9u9vfae4.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = 0; j < i; j++) {\n            if (numbers[i] > result[j]) {\n                result[i] = numbers[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpxskr796t.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428616]\n??:? long[] tmpxskr796t.rolling_max(long[]) [0x427e62]\n??:? void tmpxskr796t.__unittest_L24_C1() [0x427ffa]\n??:? void tmpxskr796t.__modtest() [0x4282e8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n    }\n    result[0] = numbers[max_index];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[max_index];\n        max_index = (max_index + 1) % numbers.length;\n        if (numbers[max_index] > numbers[i]) {\n            result[i] = numbers[max_index];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp9lmlqf4g.d(22): Error: cannot implicitly convert expression `cast(ulong)(max_index + 1) % numbers.length` of type `ulong` to `int`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9lmlqf4g.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(long n : numbers)\n    {\n        if(i == 0)\n        {\n            result[i] = n;\n        }\n        else\n        {\n            if(n > result[i-1])\n            {\n                result[i] = n;\n            }\n            else\n            {\n                result[i] = result[i-1];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpzc8xa327.d(14): Error: semicolon expected, not `:`\n/tmp/tmpzc8xa327.d(14): Error: expression expected, not `:`\n/tmp/tmpzc8xa327.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzc8xa327.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for(long number : numbers)\n    {\n        if(i == 0)\n        {\n            result[i] = number;\n        }\n        else\n        {\n            if(number > result[i-1])\n            {\n                result[i] = number;\n            }\n            else\n            {\n                result[i] = result[i-1];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmple81dllf.d(14): Error: semicolon expected, not `:`\n/tmp/tmple81dllf.d(14): Error: expression expected, not `:`\n/tmp/tmple81dllf.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmple81dllf.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n    \n    for(int i = 1; i < numbers.length; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[i] > numbers[j])\n            {\n                result[i] = numbers[i];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpkf12nxyx.d(35): unittest failure\n----------------\n??:? _d_unittestp [0x42853d]\n??:? void tmpkf12nxyx.__unittest_L29_C1() [0x42815a]\n??:? void tmpkf12nxyx.__modtest() [0x4282bc]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c61b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ae]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430739]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306c5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b485]\n??:? runModuleUnitTests [0x42c3f1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x428a00]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for (int i = 0; i < numbers.length; i++) {\n        if (numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[i] > numbers[j])\n            {\n                result[i] = numbers[i];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp_9zypqzm.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x42860e]\n??:? long[] tmp_9zypqzm.rolling_max(long[]) [0x427e62]\n??:? void tmp_9zypqzm.__unittest_L27_C1() [0x427ff2]\n??:? void tmp_9zypqzm.__modtest() [0x4282e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c63b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a5]\n??:? runModuleUnitTests [0x42c411]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    while(i < numbers.length)\n    {\n        result[i] = numbers[i];\n        for(int j = i+1; j < numbers.length; j++)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmph962h5fe.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmph962h5fe.__unittest_L28_C1() [0x4280a9]\n??:? void tmph962h5fe.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for(int i = 0; i < numbers.length; i++)\n        result[i] = numbers[i];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        for(int j = 0; j < i; j++)\n        {\n            if(numbers[j] < numbers[i])\n            {\n                result[i] = numbers[j];\n                break;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpoz761uf8.d(33): unittest failure\n----------------\n??:? _d_unittestp [0x428535]\n??:? void tmpoz761uf8.__unittest_L28_C1() [0x4280b5]\n??:? void tmpoz761uf8.__modtest() [0x4282b4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c613]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4a6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430731]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430be0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306bd]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b47d]\n??:? runModuleUnitTests [0x42c3e9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289f8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i-1] ? numbers[i] : result[i-1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpeg4j2ofe.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpeg4j2ofe.rolling_max(long[]) [0x427e62]\n??:? void tmpeg4j2ofe.__unittest_L19_C1() [0x427fae]\n??:? void tmpeg4j2ofe.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = numbers[i] > result[i - 1] ? numbers[i] : result[i - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpqx_ptxfl.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x4285ce]\n??:? long[] tmpqx_ptxfl.rolling_max(long[]) [0x427e62]\n??:? void tmpqx_ptxfl.__unittest_L19_C1() [0x427fae]\n??:? void tmpqx_ptxfl.__modtest() [0x42829c]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > max)\n            max = numbers[i];\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpipwic8pm.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmpipwic8pm.rolling_max(long[]) [0x427e62]\n??:? void tmpipwic8pm.__unittest_L22_C1() [0x427f4a]\n??:? void tmpipwic8pm.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > numbers[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmp9_dm7g_4.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x42851d]\n??:? void tmp9_dm7g_4.__unittest_L23_C1() [0x4280a1]\n??:? void tmp9_dm7g_4.__modtest() [0x4282a0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c5fb]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b48e]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430719]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bc8]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306a5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b465]\n??:? runModuleUnitTests [0x42c3d1]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e0]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i - 1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpm48ot8gi.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm48ot8gi.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(numbers[i], result[i-1]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293212,
      "stdout": "",
      "stderr": "/tmp/tmpltuhdd20.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpltuhdd20.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int i = 0;\n    for (long num : numbers) {\n        result[i++] = num;\n        if (i == numbers.length) {\n            i = 0;\n        }\n        for (int j = i - 1; j >= 0; j--) {\n            if (result[j] < num) {\n                result[j] = num;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmp30mfa31y.d(14): Error: semicolon expected, not `:`\n/tmp/tmp30mfa31y.d(14): Error: expression expected, not `:`\n/tmp/tmp30mfa31y.d(14): Error: found `numbers` when expecting `;` following `for` condition\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp30mfa31y.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        result[i] = Math.max(result[i-1], numbers[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "/tmp/tmpo99e1scs.d(15): Error: undefined identifier `Math`\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo99e1scs.d\", \"-I/tmp\"]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    long max = numbers[0];\n    for (int i = 1; i < numbers.length; i++) {\n        if (numbers[i] > max) {\n            max = numbers[i];\n        }\n        result[i] = max;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmphokrqrqr.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428566]\n??:? long[] tmphokrqrqr.rolling_max(long[]) [0x427e62]\n??:? void tmphokrqrqr.__unittest_L22_C1() [0x427f4a]\n??:? void tmphokrqrqr.__modtest() [0x428238]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c593]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b426]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x4306b1]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430b60]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x43063d]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b3fd]\n??:? runModuleUnitTests [0x42c369]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++) {\n        if(numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++) {\n        if(numbers[i] > numbers[max_index]) {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    result[0] = numbers[0];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        result[i] = numbers[i];\n        for(int j = i - 1; j >= 0; j--)\n        {\n            if(numbers[j] > result[i])\n            {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293214,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmp2hy_9aam.d(13): Range violation\n----------------\n??:? _d_arrayboundsp [0x428616]\n??:? long[] tmp2hy_9aam.rolling_max(long[]) [0x427e62]\n??:? void tmp2hy_9aam.__unittest_L27_C1() [0x427ff6]\n??:? void tmp2hy_9aam.__modtest() [0x4282e4]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c643]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4d6]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430761]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c10]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ed]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4ad]\n??:? runModuleUnitTests [0x42c419]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    for (int i = 0; i < numbers.length; i++) {\n        result[i] = numbers[i];\n        for (int j = i + 1; j < numbers.length; j++) {\n            if (numbers[j] > result[i]) {\n                result[i] = numbers[j];\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.AssertError@/tmp/tmpd9oy9y75.d(28): unittest failure\n----------------\n??:? _d_unittestp [0x428525]\n??:? void tmpd9oy9y75.__unittest_L23_C1() [0x4280a9]\n??:? void tmpd9oy9y75.__modtest() [0x4282a8]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c603]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b496]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430721]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430bd0]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306ad]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b46d]\n??:? runModuleUnitTests [0x42c3d9]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll() [0x4289e8]\n??:? void rt.dmain2._d_r",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "import std.typecons;\nimport std.math;\n/*\n From a given array of integers, generate an array of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1L, 2L, 3L, 2L, 3L, 4L, 2L])\n    [1L, 2L, 3L, 3L, 3L, 4L, 4L]\n    \n*/\nlong[] rolling_max(long[] numbers) \n{\n    long[] result = new long[numbers.length];\n    int max_index = 0;\n    for(int i = 0; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n    }\n    result[0] = numbers[max_index];\n    for(int i = 1; i < numbers.length; i++)\n    {\n        if(numbers[i] > numbers[max_index])\n        {\n            max_index = i;\n        }\n        result[i] = numbers[max_index];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = rolling_max;\n\n    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 1L]) == [4L, 4L, 4L, 4L]);\n    assert(candidate([3L, 2L, 3L, 100L, 3L]) == [3L, 3L, 3L, 100L, 100L]);\n}\nvoid main(){}",
      "timestamp": 1664293213,
      "stdout": "",
      "stderr": "core.exception.RangeError@/tmp/tmpxiv4u5cd.d(21): Range violation\n----------------\n??:? _d_arrayboundsp [0x42860e]\n??:? long[] tmpxiv4u5cd.rolling_max(long[]) [0x427eca]\n??:? void tmpxiv4u5cd.__unittest_L32_C1() [0x427ff2]\n??:? void tmpxiv4u5cd.__modtest() [0x4282e0]\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*) [0x42c63b]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*)) [0x42b4ce]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref rt.sections_elf_shared.DSO) [0x430759]\n??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO)) [0x430c08]\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))) [0x4306e5]\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b4a5]\n??:? runModuleUnitTests [0x42c411]\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}